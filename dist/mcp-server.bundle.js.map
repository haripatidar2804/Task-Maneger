{
  "version": 3,
  "sources": ["../src/config.js", "../src/utils/logger.js", "../src/db.js", "../src/logic/TextTokenizerLogic.js", "../src/logic/RelationshipContextManagerLogic.js", "../src/logic/ContextCompressorLogic.js", "../src/main.js", "../src/tools/initializeConversationContext.tool.js", "../src/logic/ConversationIntelligence.js", "../src/logic/ContextIndexerLogic.js", "../src/logic/CodeStructureAnalyzerLogic.js", "../src/logic/SmartSearchServiceLogic.js", "../src/logic/ContextPrioritizerLogic.js", "../src/logic/ConversationSegmenter.js", "../src/logic/ConversationPurposeDetector.js", "../src/logic/IntentPredictorLogic.js", "../src/logic/TimelineManagerLogic.js", "../src/logic/ActiveContextManager.js", "../src/logic/GlobalPatternRepository.js", "../src/schemas/toolSchemas.js", "../src/tools/updateConversationContext.tool.js", "../src/logic/KnowledgeProcessor.js", "../src/tools/retrieveRelevantContext.tool.js", "../src/logic/InsightEngine.js", "../src/tools/recordMilestoneContext.tool.js", "../src/logic/LearningSystem.js", "../src/logic/SemanticPatternRecognizerLogic.js", "../src/tools/finalizeConversationContext.tool.js", "../src/logic/LearningSystems.js", "../src/tools/index.js", "../src/tools/mcpDevContextTools.js"],
  "sourcesContent": ["/**\n * Configuration module that loads and exports environment variables\n */\n\nimport dotenv from \"dotenv\";\n\n// Load environment variables from .env file\ndotenv.config();\n\n// Critical TursoDB credentials - required for server operation\nexport const TURSO_DATABASE_URL = process.env.TURSO_DATABASE_URL;\nexport const TURSO_AUTH_TOKEN = process.env.TURSO_AUTH_TOKEN;\n\n// Logging configuration\nexport const LOG_LEVEL = process.env.LOG_LEVEL || \"INFO\";\nexport const DB_LOGGING_ENABLED = process.env.DB_LOGGING_ENABLED === \"true\";\n\n// Context retrieval configuration\nexport const DEFAULT_TOKEN_BUDGET = parseInt(\n  process.env.DEFAULT_TOKEN_BUDGET || \"4000\",\n  10\n);\nexport const CONTEXT_DECAY_RATE = parseFloat(\n  process.env.CONTEXT_DECAY_RATE || \"0.95\"\n);\nexport const MAX_CACHE_SIZE = parseInt(\n  process.env.MAX_CACHE_SIZE || \"1000\",\n  10\n);\n", "/**\n * Logger utility module\n * Provides logging functionality with level-based filtering and optional DB persistence\n */\n\nimport { LOG_LEVEL, DB_LOGGING_ENABLED } from \"../config.js\";\n\n// Log level priorities (higher number = higher priority)\nconst LOG_LEVELS = {\n  DEBUG: 0,\n  INFO: 1,\n  WARN: 2,\n  ERROR: 3,\n};\n\n// Multiple ways to detect MCP mode to be absolutely sure\nfunction isInMcpMode() {\n  return (\n    process.env.MCP_MODE === \"true\" ||\n    process.env.MCP_MODE === true ||\n    global.MCP_MODE === true\n  );\n}\n\n// MCP mode is set in main.js BEFORE any imports run\n// This ensures we detect it correctly\nconst IN_MCP_MODE = isInMcpMode();\n\n/**\n * Logs a message with the specified level and optional data\n * @param {string} level - Log level ('DEBUG', 'INFO', 'WARN', 'ERROR')\n * @param {string} message - Log message\n * @param {object|null} data - Optional data to include with the log\n */\nexport const logMessage = (level, message, data = null) => {\n  // Defense in depth: Triple-check MCP mode to be absolutely certain\n  // This is critical for MCP operation\n  if (isInMcpMode() || IN_MCP_MODE || process.env.MCP_MODE === \"true\") {\n    return;\n  }\n\n  // Convert level to uppercase for consistency\n  const upperLevel = level.toUpperCase();\n\n  // Only log if the message level is at or above the configured level\n  if (\n    !LOG_LEVELS.hasOwnProperty(upperLevel) ||\n    LOG_LEVELS[upperLevel] < LOG_LEVELS[LOG_LEVEL]\n  ) {\n    return;\n  }\n\n  // Create timestamp\n  const timestamp = new Date().toISOString();\n\n  // Normal mode - human readable format\n  // Format the log message\n  let logString = `[${timestamp}] [${upperLevel}]: ${message}`;\n  if (data) {\n    const dataString = typeof data === \"string\" ? data : JSON.stringify(data);\n    logString += ` - ${dataString}`;\n  }\n\n  // Final safety check before output\n  if (isInMcpMode() || IN_MCP_MODE || process.env.MCP_MODE === \"true\") {\n    return;\n  }\n\n  // Output to appropriate stream\n  if (upperLevel === \"DEBUG\" || upperLevel === \"INFO\") {\n    console.log(logString);\n  } else {\n    console.error(logString);\n  }\n\n  // Database logging would happen here, but we're avoiding circular dependency\n  // If DB_LOGGING_ENABLED is true, we would log to the database\n  // But since we need to avoid importing from db.js, we'll skip this part\n};\n\nexport default logMessage;\n", "/**\n * Database client module for TursoDB connections\n * Manages the connection to the TursoDB database and provides query utilities\n */\n\nimport { createClient } from \"@libsql/client\";\nimport { TURSO_DATABASE_URL, TURSO_AUTH_TOKEN } from \"./config.js\";\nimport { logMessage } from \"./utils/logger.js\";\n\n// Module-scoped singleton instance\nlet dbClient = null;\n\n/**\n * Initialize and return a TursoDB client instance (singleton)\n * @returns {Object} TursoDB client instance\n * @throws {Error} If database URL or auth token is missing\n */\nexport const getDbClient = () => {\n  // Check if we're in MCP mode - never log in MCP mode\n  const inMcpMode = process.env.MCP_MODE === \"true\";\n\n  if (dbClient) {\n    return dbClient;\n  }\n\n  if (!TURSO_DATABASE_URL) {\n    const errorMsg =\n      \"TURSO_DATABASE_URL is not defined in environment variables\";\n    if (inMcpMode) {\n      // In MCP mode, don't throw with a message that could be logged\n      throw new Error();\n    } else {\n      throw new Error(errorMsg);\n    }\n  }\n\n  if (!TURSO_AUTH_TOKEN) {\n    const errorMsg = \"TURSO_AUTH_TOKEN is not defined in environment variables\";\n    if (inMcpMode) {\n      // In MCP mode, don't throw with a message that could be logged\n      throw new Error();\n    } else {\n      throw new Error(errorMsg);\n    }\n  }\n\n  dbClient = createClient({\n    url: TURSO_DATABASE_URL,\n    authToken: TURSO_AUTH_TOKEN,\n  });\n\n  // Only log in non-MCP mode\n  if (!inMcpMode) {\n    logMessage(\"info\", \"Database client created\", {\n      url: TURSO_DATABASE_URL.substring(0, 20) + \"...\", // Don't log full URL for security\n    });\n  }\n\n  return dbClient;\n};\n\n/**\n * Test the database connection by executing a simple query\n * @param {Object} client - TursoDB client instance from getDbClient()\n * @returns {Promise<boolean>} True if connection is successful\n * @throws {Error} If connection fails\n */\nexport const testDbConnection = async (client = null) => {\n  // Check if we're in MCP mode - never log in MCP mode\n  const inMcpMode = process.env.MCP_MODE === \"true\";\n\n  try {\n    // Maximum number of retry attempts\n    const maxRetries = 3;\n    let retryCount = 0;\n\n    while (retryCount < maxRetries) {\n      try {\n        const dbClient = client || getDbClient();\n        await dbClient.execute(\"SELECT 1\");\n        return true;\n      } catch (connError) {\n        retryCount++;\n\n        // If we've reached max retries, handle the error\n        if (retryCount >= maxRetries) {\n          // In MCP mode, just return false instead of throwing\n          if (inMcpMode) {\n            return false;\n          }\n          throw new Error(\n            `Database connection test failed: ${connError.message}`\n          );\n        }\n\n        // Wait before retrying (exponential backoff)\n        const waitTime = Math.pow(2, retryCount) * 100;\n        await new Promise((resolve) => setTimeout(resolve, waitTime));\n\n        // Reset client for retry if we're using the singleton\n        if (!client) {\n          dbClient = null;\n        }\n      }\n    }\n\n    return true; // Should never reach here but just in case\n  } catch (error) {\n    // In MCP mode, just return false instead of throwing\n    if (inMcpMode) {\n      return false;\n    }\n    throw new Error(`Database connection test failed: ${error.message}`);\n  }\n};\n\n/**\n * Execute a SQL query with optional parameters\n * @param {string} sqlQuery - SQL query to execute\n * @param {Array} [args=[]] - Optional array of query parameters for parameterized queries\n * @returns {Promise<Object>} Query result\n * @throws {Error} If query execution fails\n */\nexport const executeQuery = async (sqlQuery, args = []) => {\n  // Strict MCP mode check to prevent any possible logging\n  const inMcpMode = process.env.MCP_MODE === \"true\";\n\n  try {\n    // Only log if not in MCP mode - double check to be absolutely sure\n    if (!inMcpMode) {\n      // Log the query for debugging\n      logMessage(\"debug\", \"DB - EXECUTING QUERY\", {\n        sql: sqlQuery.substring(0, 150) + (sqlQuery.length > 150 ? \"...\" : \"\"),\n        args:\n          args.length > 0\n            ? JSON.stringify(args.slice(0, 3)) + (args.length > 3 ? \"...\" : \"\")\n            : \"[]\",\n      });\n    }\n\n    // Maximum number of retry attempts\n    const maxRetries = 3;\n    let retryCount = 0;\n    let result;\n\n    while (retryCount < maxRetries) {\n      try {\n        const client = getDbClient();\n        result = await client.execute({\n          sql: sqlQuery,\n          args: args,\n        });\n        break; // If query succeeds, exit the retry loop\n      } catch (queryError) {\n        retryCount++;\n\n        // Check if this is a connection error that can be retried\n        const isConnectionError =\n          queryError.message?.includes(\"connection\") ||\n          queryError.message?.includes(\"timeout\") ||\n          queryError.message?.includes(\"closed\");\n\n        // If we've reached max retries or it's not a connection error, rethrow\n        if (retryCount >= maxRetries || !isConnectionError) {\n          throw queryError;\n        }\n\n        // Wait before retrying (exponential backoff)\n        const waitTime = Math.pow(2, retryCount) * 100;\n        await new Promise((resolve) => setTimeout(resolve, waitTime));\n\n        // Reset client for retry\n        dbClient = null;\n      }\n    }\n\n    // Only log if not in MCP mode - double check to be absolutely sure\n    if (!inMcpMode) {\n      // Log the result for debugging\n      logMessage(\"debug\", \"DB - QUERY RESULT\", {\n        rowCount: result.rows?.length || 0,\n        rowsPreview:\n          result.rows?.length > 0\n            ? JSON.stringify(result.rows[0]).substring(0, 100) + \"...\"\n            : \"No rows\",\n        affectedRows: result.rowsAffected || 0,\n      });\n    }\n\n    return result;\n  } catch (error) {\n    // Only log if not in MCP mode - double check to be absolutely sure\n    if (!inMcpMode) {\n      logMessage(\"error\", \"DB - QUERY ERROR\", {\n        message: error.message,\n        query: sqlQuery.substring(0, 150),\n        args: args.length > 0 ? JSON.stringify(args.slice(0, 3)) : \"[]\",\n      });\n    }\n\n    // In MCP mode, throw a plain error without any message to prevent logging\n    if (inMcpMode) {\n      throw new Error();\n    } else {\n      throw new Error(\n        `Query execution failed: ${error.message}\\nQuery: ${sqlQuery}`\n      );\n    }\n  }\n};\n\n/**\n * Migrate the project_patterns table to add the language column if it doesn't exist\n * @returns {Promise<void>}\n */\nasync function migrateProjectPatternsTable() {\n  // Silent operation in MCP mode - triple check to be safe\n  const inMcpMode = process.env.MCP_MODE === \"true\";\n\n  try {\n    // First check if the table exists - use a more robust approach with error handling\n    let tableExists = false;\n    try {\n      const tableExistsQuery = await executeQuery(`\n        SELECT name FROM sqlite_master\n        WHERE type='table' AND name='project_patterns'\n      `);\n\n      tableExists =\n        tableExistsQuery &&\n        tableExistsQuery.rows &&\n        tableExistsQuery.rows.length > 0;\n    } catch (tableCheckError) {\n      // If error checking table existence, assume table doesn't exist\n      if (!inMcpMode) {\n        logMessage(\n          \"warn\",\n          `Error checking table existence: ${tableCheckError.message}`\n        );\n      }\n      return; // Exit early, nothing to migrate\n    }\n\n    // If table doesn't exist, nothing to migrate\n    if (!tableExists) {\n      if (!inMcpMode) {\n        logMessage(\n          \"info\",\n          \"project_patterns table doesn't exist yet, skipping migration\"\n        );\n      }\n      return;\n    }\n\n    // Check if the language column exists directly with a query\n    // This avoids relying on the columnExists function that might get minified\n    let hasLanguageColumn = false;\n    try {\n      const columnCheckQuery = await executeQuery(`\n        PRAGMA table_info(project_patterns)\n      `);\n\n      if (columnCheckQuery && columnCheckQuery.rows) {\n        // Check each row for the language column\n        for (const row of columnCheckQuery.rows) {\n          if (row && row.name === \"language\") {\n            hasLanguageColumn = true;\n            break;\n          }\n        }\n      }\n    } catch (columnCheckError) {\n      // If error checking column existence, be safe and skip migration\n      if (!inMcpMode) {\n        logMessage(\n          \"warn\",\n          `Error checking column existence: ${columnCheckError.message}`\n        );\n      }\n      return; // Exit early, skip migration on error\n    }\n\n    // If language column already exists, nothing to do\n    if (hasLanguageColumn) {\n      if (!inMcpMode) {\n        logMessage(\n          \"debug\",\n          \"Language column already exists in project_patterns table\"\n        );\n      }\n      return;\n    }\n\n    // Only reach here if table exists and column doesn't exist\n    if (!inMcpMode) {\n      logMessage(\"info\", \"Adding language column to project_patterns table\");\n    }\n\n    try {\n      // Add the language column to the table - wrap in try/catch\n      await executeQuery(\n        \"ALTER TABLE project_patterns ADD COLUMN language TEXT\"\n      );\n\n      if (!inMcpMode) {\n        logMessage(\n          \"info\",\n          \"Successfully added language column to project_patterns table\"\n        );\n      }\n    } catch (alterError) {\n      // Handle column already exists error - SQLite specific\n      if (\n        alterError.message &&\n        alterError.message.includes(\"duplicate column\")\n      ) {\n        if (!inMcpMode) {\n          logMessage(\"info\", \"Language column already exists, skipping\");\n        }\n      } else {\n        // For other errors in non-MCP mode, log warning but don't fail\n        if (!inMcpMode) {\n          logMessage(\n            \"warn\",\n            `Error adding language column: ${alterError.message}`\n          );\n        }\n        return; // Skip index creation on error\n      }\n    }\n\n    // Create index for the language column if needed - with separate error handling\n    try {\n      await executeQuery(\n        \"CREATE INDEX IF NOT EXISTS idx_project_patterns_language ON project_patterns(language)\"\n      );\n      if (!inMcpMode) {\n        logMessage(\"info\", \"Created index for language column\");\n      }\n    } catch (indexError) {\n      // Log index creation error but don't fail - not critical\n      if (!inMcpMode) {\n        logMessage(\"warn\", `Error creating index: ${indexError.message}`);\n      }\n    }\n  } catch (error) {\n    // In MCP mode, don't throw or log errors - just silently fail\n    if (!inMcpMode) {\n      // Log error but don't throw - make migration non-fatal\n      logMessage(\"warn\", `Migration warning: ${error.message}`);\n    }\n  }\n}\n\n/**\n * Initialize the database schema by creating all required tables and indexes\n * This function executes all CREATE TABLE, CREATE INDEX and CREATE TRIGGER statements\n * defined in the project blueprint\n * @returns {Promise<boolean>} True if schema initialization was successful\n */\nexport const initializeDatabaseSchema = async () => {\n  // Check if we're in MCP mode - triple check to prevent any logging\n  const inMcpMode = process.env.MCP_MODE === \"true\";\n\n  try {\n    const client = getDbClient();\n    let success = true;\n\n    // First, check if we need to migrate the project_patterns table by adding the language column\n    // Wrap in try/catch and continue regardless of migration outcome\n    try {\n      await migrateProjectPatternsTable();\n    } catch (migrationError) {\n      // Completely ignore migration errors in MCP mode\n      if (!inMcpMode) {\n        logMessage(\"warn\", `Migration warning: ${migrationError.message}`);\n      }\n      // Continue with schema initialization, migration error is not fatal\n    }\n\n    // Array of SQL statements to execute sequentially\n    const schemaStatements = [\n      // ========= CODE ENTITIES =========\n      `CREATE TABLE IF NOT EXISTS code_entities (\n        entity_id TEXT PRIMARY KEY, -- UUID\n        file_path TEXT, -- Full path for file entities, or path to file containing the entity\n        entity_type TEXT NOT NULL, -- e.g., 'file', 'function', 'class', 'method', 'variable', 'interface', 'comment_block'\n        name TEXT, -- Name of the function, class, variable etc.\n        start_line INTEGER,\n        end_line INTEGER,\n        content_hash TEXT, -- Hash of the raw content to detect changes\n        raw_content TEXT,\n        summary TEXT, -- AI or rule-based summary\n        language TEXT, -- Programming language\n        parent_entity_id TEXT, -- For hierarchical structure (e.g., function inside a class, class inside a file)\n        last_modified_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        last_accessed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- For recency\n        importance_score REAL DEFAULT 1.0, -- For prioritization, can decay\n        custom_metadata TEXT, -- JSON blob for other properties\n        FOREIGN KEY (parent_entity_id) REFERENCES code_entities(entity_id) ON DELETE CASCADE\n      )`,\n\n      // Indexes for code_entities\n      `CREATE INDEX IF NOT EXISTS idx_code_entities_file_path ON code_entities(file_path)`,\n      `CREATE INDEX IF NOT EXISTS idx_code_entities_type ON code_entities(entity_type)`,\n      `CREATE INDEX IF NOT EXISTS idx_code_entities_name ON code_entities(name)`,\n      `CREATE INDEX IF NOT EXISTS idx_code_entities_last_accessed ON code_entities(last_accessed_at DESC)`,\n      `CREATE INDEX IF NOT EXISTS idx_code_entities_importance ON code_entities(importance_score DESC)`,\n\n      // ========= ENTITY KEYWORDS =========\n      `CREATE TABLE IF NOT EXISTS entity_keywords (\n        keyword_id INTEGER PRIMARY KEY AUTOINCREMENT,\n        entity_id TEXT NOT NULL,\n        keyword TEXT NOT NULL,\n        term_frequency REAL,\n        weight REAL DEFAULT 1.0,\n        keyword_type TEXT, -- e.g., 'identifier', 'comment', 'string_literal', 'n_gram_2', 'n_gram_3'\n        FOREIGN KEY (entity_id) REFERENCES code_entities(entity_id) ON DELETE CASCADE\n      )`,\n\n      // Indexes for entity_keywords\n      `CREATE INDEX IF NOT EXISTS idx_entity_keywords_keyword ON entity_keywords(keyword)`,\n      `CREATE INDEX IF NOT EXISTS idx_entity_keywords_entity ON entity_keywords(entity_id)`,\n      `CREATE UNIQUE INDEX IF NOT EXISTS idx_entity_keywords_entity_keyword_type ON entity_keywords(entity_id, keyword, keyword_type)`,\n\n      // ========= FULL-TEXT SEARCH =========\n      `CREATE VIRTUAL TABLE IF NOT EXISTS code_entities_fts USING fts5(\n        entity_id UNINDEXED,\n        name,\n        searchable_content\n      )`,\n\n      // Triggers to keep FTS table in sync with code_entities\n      `CREATE TRIGGER IF NOT EXISTS code_entities_ai AFTER INSERT ON code_entities BEGIN\n        INSERT INTO code_entities_fts (entity_id, name, searchable_content)\n        VALUES (new.entity_id, new.name, new.raw_content || ' ' || COALESCE(new.summary, ''));\n      END`,\n\n      `CREATE TRIGGER IF NOT EXISTS code_entities_ad AFTER DELETE ON code_entities BEGIN\n        DELETE FROM code_entities_fts WHERE entity_id = old.entity_id;\n      END`,\n\n      `CREATE TRIGGER IF NOT EXISTS code_entities_au AFTER UPDATE ON code_entities BEGIN\n        UPDATE code_entities_fts SET\n          name = new.name,\n          searchable_content = new.raw_content || ' ' || COALESCE(new.summary, '')\n        WHERE entity_id = old.entity_id;\n      END`,\n\n      // ========= CODE RELATIONSHIPS =========\n      `CREATE TABLE IF NOT EXISTS code_relationships (\n        relationship_id TEXT PRIMARY KEY, -- UUID\n        source_entity_id TEXT NOT NULL,\n        target_entity_id TEXT NOT NULL,\n        relationship_type TEXT NOT NULL,\n        weight REAL DEFAULT 1.0,\n        metadata TEXT, -- JSON blob\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (source_entity_id) REFERENCES code_entities(entity_id) ON DELETE CASCADE,\n        FOREIGN KEY (target_entity_id) REFERENCES code_entities(entity_id) ON DELETE CASCADE\n      )`,\n\n      // Indexes for code_relationships\n      `CREATE INDEX IF NOT EXISTS idx_code_relationships_source ON code_relationships(source_entity_id, relationship_type)`,\n      `CREATE INDEX IF NOT EXISTS idx_code_relationships_target ON code_relationships(target_entity_id, relationship_type)`,\n      `CREATE UNIQUE INDEX IF NOT EXISTS idx_code_relationships_unique ON code_relationships(source_entity_id, target_entity_id, relationship_type)`,\n\n      // ========= CONVERSATION HISTORY =========\n      `CREATE TABLE IF NOT EXISTS conversation_history (\n        message_id TEXT PRIMARY KEY, -- UUID\n        conversation_id TEXT NOT NULL,\n        role TEXT NOT NULL, -- 'user', 'assistant', 'system'\n        content TEXT NOT NULL,\n        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        related_context_entity_ids TEXT, -- JSON array of entity_ids\n        summary TEXT,\n        user_intent TEXT,\n        topic_segment_id TEXT,        -- Reference to topic segment\n        semantic_markers TEXT,        -- JSON array of semantic markers found in message\n        sentiment_indicators TEXT      -- JSON structure for sentiment analysis\n      )`,\n\n      // Indexes for conversation_history\n      `CREATE INDEX IF NOT EXISTS idx_conversation_history_conversation_ts ON conversation_history(conversation_id, timestamp DESC)`,\n      `CREATE INDEX IF NOT EXISTS idx_conversation_history_topic ON conversation_history(topic_segment_id)`,\n\n      // ========= CONVERSATION TOPICS =========\n      `CREATE TABLE IF NOT EXISTS conversation_topics (\n        topic_id TEXT PRIMARY KEY, -- UUID\n        conversation_id TEXT NOT NULL,\n        topic_name TEXT NOT NULL,\n        description TEXT,\n        start_message_id TEXT NOT NULL,\n        end_message_id TEXT,    -- NULL if ongoing\n        start_timestamp TIMESTAMP NOT NULL,\n        end_timestamp TIMESTAMP,  -- NULL if ongoing\n        primary_entities TEXT,    -- JSON array of entity_ids\n        keywords TEXT,            -- JSON array of keywords\n        summary TEXT,\n        parent_topic_id TEXT,     -- For hierarchical topic structure\n        FOREIGN KEY (start_message_id) REFERENCES conversation_history(message_id) ON DELETE CASCADE,\n        FOREIGN KEY (parent_topic_id) REFERENCES conversation_topics(topic_id) ON DELETE SET NULL\n      )`,\n\n      // Indexes for conversation_topics\n      `CREATE INDEX IF NOT EXISTS idx_conversation_topics_conversation ON conversation_topics(conversation_id)`,\n      `CREATE INDEX IF NOT EXISTS idx_conversation_topics_timestamps ON conversation_topics(start_timestamp, end_timestamp)`,\n\n      // ========= CONVERSATION PURPOSES =========\n      `CREATE TABLE IF NOT EXISTS conversation_purposes (\n        purpose_id TEXT PRIMARY KEY, -- UUID\n        conversation_id TEXT NOT NULL,\n        purpose_type TEXT NOT NULL,  -- 'debugging', 'feature_planning', 'code_review', etc.\n        confidence REAL DEFAULT 0.0, -- Confidence score (0.0 to 1.0)\n        start_timestamp TEXT NOT NULL, -- ISO timestamp\n        end_timestamp TEXT, -- ISO timestamp, NULL if still active\n        metadata TEXT -- Additional metadata in JSON format\n      )`,\n\n      // Indexes for conversation_purposes\n      `CREATE INDEX IF NOT EXISTS idx_conversation_purposes_conversation ON conversation_purposes(conversation_id)`,\n      `CREATE INDEX IF NOT EXISTS idx_conversation_purposes_type ON conversation_purposes(purpose_type, confidence DESC)`,\n\n      // ========= TIMELINE EVENTS =========\n      `CREATE TABLE IF NOT EXISTS timeline_events (\n        event_id TEXT PRIMARY KEY, -- UUID\n        event_type TEXT NOT NULL,\n        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        data TEXT, -- JSON blob\n        associated_entity_ids TEXT, -- JSON array of code_entity_ids\n        conversation_id TEXT -- If related to a specific conversation\n      )`,\n\n      // Indexes for timeline_events\n      `CREATE INDEX IF NOT EXISTS idx_timeline_events_ts ON timeline_events(timestamp DESC)`,\n      `CREATE INDEX IF NOT EXISTS idx_timeline_events_type ON timeline_events(event_type)`,\n\n      // ========= CONTEXT SNAPSHOTS =========\n      `CREATE TABLE IF NOT EXISTS context_snapshots (\n        snapshot_id TEXT PRIMARY KEY, -- UUID\n        name TEXT,\n        description TEXT,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        timeline_event_id TEXT,\n        snapshot_data TEXT NOT NULL, -- JSON blob\n        FOREIGN KEY (timeline_event_id) REFERENCES timeline_events(event_id) ON DELETE SET NULL\n      )`,\n\n      // Indexes for context_snapshots\n      `CREATE INDEX IF NOT EXISTS idx_context_snapshots_name ON context_snapshots(name)`,\n\n      // ========= FOCUS AREAS =========\n      `CREATE TABLE IF NOT EXISTS focus_areas (\n        focus_id TEXT PRIMARY KEY, -- UUID\n        focus_type TEXT NOT NULL,\n        identifier TEXT,\n        description TEXT,\n        related_entity_ids TEXT, -- JSON array of code_entity_ids\n        keywords TEXT, -- JSON array of defining keywords\n        last_activated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        is_active BOOLEAN DEFAULT FALSE\n      )`,\n\n      // Indexes for focus_areas\n      `CREATE INDEX IF NOT EXISTS idx_focus_areas_active ON focus_areas(is_active, last_activated_at DESC)`,\n\n      // ========= PROJECT PATTERNS =========\n      `CREATE TABLE IF NOT EXISTS project_patterns (\n        pattern_id TEXT PRIMARY KEY, -- UUID\n        pattern_type TEXT NOT NULL,\n        name TEXT,\n        description TEXT,\n        representation TEXT NOT NULL, -- JSON or textual\n        detection_rules TEXT,\n        frequency INTEGER DEFAULT 0,\n        last_detected_at TIMESTAMP,\n        utility_score REAL DEFAULT 0.0,\n        confidence_score REAL DEFAULT 0.5, -- confidence in pattern validity\n        reinforcement_count INTEGER DEFAULT 1, -- times pattern was reinforced\n        is_global BOOLEAN DEFAULT FALSE, -- indicates if promoted to global status\n        session_origin_id TEXT, -- originating session if any\n        language TEXT, -- NEW COLUMN: programming language the pattern applies to\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )`,\n\n      // Indexes for project_patterns\n      `CREATE INDEX IF NOT EXISTS idx_project_patterns_type ON project_patterns(pattern_type)`,\n      `CREATE INDEX IF NOT EXISTS idx_project_patterns_global ON project_patterns(is_global, confidence_score DESC)`,\n      `CREATE INDEX IF NOT EXISTS idx_project_patterns_utility ON project_patterns(utility_score DESC)`,\n\n      // ========= PATTERN OBSERVATIONS =========\n      `CREATE TABLE IF NOT EXISTS pattern_observations (\n        observation_id TEXT PRIMARY KEY, -- UUID\n        pattern_id TEXT NOT NULL,\n        conversation_id TEXT,\n        context_entities TEXT, -- JSON array of entity_ids\n        observation_type TEXT NOT NULL, -- 'usage', 'confirmation', 'rejection'\n        observation_data TEXT, -- JSON with details\n        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (pattern_id) REFERENCES project_patterns(pattern_id) ON DELETE CASCADE\n      )`,\n\n      // Indexes for pattern_observations\n      `CREATE INDEX IF NOT EXISTS idx_pattern_observations_pattern ON pattern_observations(pattern_id)`,\n      `CREATE INDEX IF NOT EXISTS idx_pattern_observations_type_ts ON pattern_observations(observation_type, timestamp DESC)`,\n\n      // ========= SYSTEM LOGS =========\n      `CREATE TABLE IF NOT EXISTS system_logs (\n        log_id INTEGER PRIMARY KEY AUTOINCREMENT,\n        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        level TEXT NOT NULL, -- 'INFO', 'WARN', 'ERROR', 'DEBUG'\n        message TEXT NOT NULL,\n        data TEXT -- Optional JSON blob\n      )`,\n\n      // Indexes for system_logs\n      `CREATE INDEX IF NOT EXISTS idx_system_logs_timestamp_level ON system_logs(timestamp DESC, level)`,\n\n      // Make sure knowledge_items table exists\n      `CREATE TABLE IF NOT EXISTS knowledge_items (\n        item_id TEXT PRIMARY KEY, -- UUID\n        item_type TEXT NOT NULL, -- Type of knowledge item (concept, code_pattern, domain_term, etc.)\n        name TEXT NOT NULL, -- Display name of the knowledge item\n        content TEXT, -- JSON or raw content depending on type\n        metadata TEXT, -- Additional metadata as JSON\n        confidence_score REAL DEFAULT 0.5, -- Confidence score\n        created_at TEXT NOT NULL, -- Creation timestamp\n        updated_at TEXT NOT NULL, -- Last update timestamp\n        conversation_id TEXT -- Source conversation ID\n      )`,\n\n      // Indexes for knowledge_items\n      `CREATE INDEX IF NOT EXISTS idx_knowledge_items_type ON knowledge_items(item_type)`,\n      `CREATE INDEX IF NOT EXISTS idx_knowledge_items_conversation ON knowledge_items(conversation_id)`,\n      `CREATE INDEX IF NOT EXISTS idx_knowledge_items_confidence ON knowledge_items(confidence_score DESC)`,\n\n      // Make sure context_states table exists\n      `CREATE TABLE IF NOT EXISTS context_states (\n        state_id TEXT PRIMARY KEY, -- UUID\n        milestone_id TEXT,\n        conversation_id TEXT,\n        topic_id TEXT,\n        state_type TEXT NOT NULL, -- Type of context state\n        state_data TEXT, -- JSON data representing the state\n        created_at TEXT NOT NULL, -- Creation timestamp\n        metadata TEXT -- Additional metadata as JSON\n      )`,\n\n      // Indexes for context_states\n      `CREATE INDEX IF NOT EXISTS idx_context_states_milestone ON context_states(milestone_id)`,\n      `CREATE INDEX IF NOT EXISTS idx_context_states_conversation ON context_states(conversation_id)`,\n    ];\n\n    // Execute each statement in sequence\n    for (const statement of schemaStatements) {\n      try {\n        await client.execute(statement);\n      } catch (error) {\n        // Only log error in non-MCP mode\n        if (!inMcpMode) {\n          logMessage(\n            \"error\",\n            `Error executing schema statement: ${error.message}`\n          );\n          logMessage(\n            \"error\",\n            `Failed statement: ${statement.substring(0, 100)}...`\n          );\n        }\n        success = false;\n      }\n    }\n\n    return success;\n  } catch (error) {\n    if (inMcpMode) {\n      // In MCP mode, return false silently instead of throwing\n      return false;\n    }\n    throw new Error(`Database schema initialization failed: ${error.message}`);\n  }\n};\n\nexport default {\n  getDbClient,\n  testDbConnection,\n  executeQuery,\n  initializeDatabaseSchema,\n};\n", "/**\n * TextTokenizerLogic.js\n *\n * Provides text tokenization with language-specific enhancements\n * for more accurate code analysis and context understanding.\n */\n\n/**\n * Tokenizes input text with language-specific tokenization rules\n *\n * @param {string} text - The text to tokenize\n * @param {string} language - The programming language of the text (default: 'plaintext')\n * @returns {string[]} An array of tokens\n */\nexport function tokenize(text, language = \"plaintext\") {\n  // Normalize to lowercase as requested\n  const normalizedText = text.toLowerCase();\n\n  // Handle language-specific tokenization based on the language parameter\n  switch (language) {\n    case \"javascript\":\n    case \"typescript\":\n    case \"jsx\":\n    case \"tsx\":\n      return tokenizeJavaScript(normalizedText);\n    case \"python\":\n      return tokenizePython(normalizedText);\n    case \"java\":\n    case \"csharp\":\n    case \"c#\":\n      return tokenizeJavaLike(normalizedText);\n    case \"ruby\":\n      return tokenizeRuby(normalizedText);\n    case \"go\":\n      return tokenizeGo(normalizedText);\n    case \"plaintext\":\n    default:\n      return tokenizeGeneric(normalizedText);\n  }\n}\n\n/**\n * Generates n-grams from an array of tokens, respecting semantic boundaries where possible\n *\n * @param {string[]} tokens - Array of tokens (from tokenize function)\n * @param {number} n - Size of n-grams to generate (e.g., 2 for bigrams, 3 for trigrams)\n * @returns {string[]} Array of n-gram strings\n */\nexport function generateNgrams(tokens, n) {\n  // Handle edge cases\n  if (!tokens || tokens.length === 0) return [];\n  if (n <= 0) return [];\n  if (tokens.length < n) return [tokens.join(\" \")];\n\n  const ngrams = [];\n\n  // Track positions where we should avoid generating n-grams\n  // These represent semantic boundaries\n  const semanticBoundaries = new Set();\n\n  // Identify potential semantic boundaries\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n\n    // Break at special tokens that indicate syntactic boundaries\n    if (token.startsWith(\"__\") && token.endsWith(\"__\")) {\n      semanticBoundaries.add(i);\n      semanticBoundaries.add(i + 1);\n    }\n\n    // Break at common punctuation that signals the end of statements\n    if ([\";\", \".\", \"{\", \"}\", \"(\", \")\", \"[\", \"]\"].includes(token)) {\n      semanticBoundaries.add(i);\n      semanticBoundaries.add(i + 1);\n    }\n  }\n\n  // Generate n-grams by sliding a window of size n over the tokens array\n  // Skip windows that cross semantic boundaries\n  for (let i = 0; i <= tokens.length - n; i++) {\n    // Check if any semantic boundary exists within this window\n    let hasBoundary = false;\n    for (let j = i; j < i + n - 1; j++) {\n      if (semanticBoundaries.has(j + 1)) {\n        hasBoundary = true;\n        break;\n      }\n    }\n\n    // If no semantic boundaries in this window, generate the n-gram\n    if (!hasBoundary) {\n      const ngram = tokens.slice(i, i + n).join(\" \");\n      ngrams.push(ngram);\n    }\n  }\n\n  return ngrams;\n}\n\n/**\n * Extracts n-grams from an array of tokens (alias for generateNgrams)\n *\n * @param {string[]} tokens - Array of tokens (from tokenize function)\n * @param {number} n - Size of n-grams to generate (e.g., 2 for bigrams, 3 for trigrams)\n * @returns {string[]} Array of n-gram strings\n */\nexport function extractNGrams(tokens, n) {\n  return generateNgrams(tokens, n);\n}\n\n/**\n * Identifies language-specific idioms in code text\n *\n * @param {string} text - Raw text to analyze\n * @param {string} language - Programming language of the text\n * @returns {{idiom: string, type: string, location: {start: number, end: number}}[]} Array of identified idioms\n */\nexport function identifyLanguageSpecificIdioms(text, language) {\n  // Handle empty input\n  if (!text) return [];\n\n  const idioms = [];\n\n  // Normalize language parameter\n  const normalizedLanguage = language.toLowerCase();\n\n  // Use language-specific idiom detection\n  switch (normalizedLanguage) {\n    case \"javascript\":\n    case \"typescript\":\n    case \"jsx\":\n    case \"tsx\":\n      identifyJavaScriptIdioms(text, idioms);\n      break;\n    case \"python\":\n      identifyPythonIdioms(text, idioms);\n      break;\n    case \"csharp\":\n    case \"c#\":\n      identifyCSharpIdioms(text, idioms);\n      break;\n    // Add more languages as needed\n  }\n\n  return idioms;\n}\n\n/**\n * Identifies JavaScript-specific idioms\n *\n * @param {string} text - JavaScript code text\n * @param {Array} idioms - Array to add identified idioms to\n * @private\n */\nfunction identifyJavaScriptIdioms(text, idioms) {\n  // 1. Detect Promise chains (.then().catch())\n  const promiseChainRegex =\n    /\\.\\s*then\\s*\\(\\s*(?:function\\s*\\([^)]*\\)|[^=>(]*=>\\s*[^)]*)\\s*\\)(?:\\s*\\.(?:then|catch|finally)\\s*\\([^)]*\\))+/g;\n  let match;\n\n  while ((match = promiseChainRegex.exec(text)) !== null) {\n    idioms.push({\n      idiom: match[0],\n      type: \"js_promise_chain\",\n      location: {\n        start: match.index,\n        end: match.index + match[0].length,\n      },\n    });\n  }\n\n  // 2. Detect async/await usage\n  const asyncAwaitRegex =\n    /\\basync\\s+(?:function\\s*[a-zA-Z0-9_$]*\\s*\\([^)]*\\)|(?:[a-zA-Z0-9_$]+\\s*=>)|(?:\\([^)]*\\)\\s*=>))(?:(?:.|\\n)*?\\bawait\\b(?:.|\\n)*?)/g;\n\n  while ((match = asyncAwaitRegex.exec(text)) !== null) {\n    idioms.push({\n      idiom: match[0],\n      type: \"js_async_await\",\n      location: {\n        start: match.index,\n        end: match.index + match[0].length,\n      },\n    });\n  }\n\n  // 3. Detect arrow functions as callbacks\n  const arrowCallbackRegex =\n    /(?:\\.|\\()(?:[a-zA-Z0-9_$]+)?\\s*\\(\\s*(?:\\([^)]*\\)|[a-zA-Z0-9_$]+)\\s*=>\\s*(?:{[^}]*}|[^);,]*)/g;\n\n  while ((match = arrowCallbackRegex.exec(text)) !== null) {\n    // Avoid duplicate detection with Promise chains\n    const isDuplicate = idioms.some(\n      (idiom) =>\n        idiom.type === \"js_promise_chain\" &&\n        match.index >= idiom.location.start &&\n        match.index + match[0].length <= idiom.location.end\n    );\n\n    if (!isDuplicate) {\n      idioms.push({\n        idiom: match[0],\n        type: \"js_arrow_callback\",\n        location: {\n          start: match.index,\n          end: match.index + match[0].length,\n        },\n      });\n    }\n  }\n}\n\n/**\n * Identifies Python-specific idioms\n *\n * @param {string} text - Python code text\n * @param {Array} idioms - Array to add identified idioms to\n * @private\n */\nfunction identifyPythonIdioms(text, idioms) {\n  // 1. Detect list comprehensions\n  const listComprehensionRegex =\n    /\\[\\s*[^\\[\\]]*\\s+for\\s+[^\\[\\]]+\\s+in\\s+[^\\[\\]]+(?:\\s+if\\s+[^\\[\\]]+)?\\s*\\]/g;\n  let match;\n\n  while ((match = listComprehensionRegex.exec(text)) !== null) {\n    idioms.push({\n      idiom: match[0],\n      type: \"python_list_comprehension\",\n      location: {\n        start: match.index,\n        end: match.index + match[0].length,\n      },\n    });\n  }\n\n  // 2. Detect dictionary comprehensions\n  const dictComprehensionRegex =\n    /\\{\\s*[^{}]*\\s*:\\s*[^{}]*\\s+for\\s+[^{}]+\\s+in\\s+[^{}]+(?:\\s+if\\s+[^{}]+)?\\s*\\}/g;\n\n  while ((match = dictComprehensionRegex.exec(text)) !== null) {\n    idioms.push({\n      idiom: match[0],\n      type: \"python_dict_comprehension\",\n      location: {\n        start: match.index,\n        end: match.index + match[0].length,\n      },\n    });\n  }\n\n  // 3. Detect lambda functions\n  const lambdaRegex = /lambda\\s+[^:]+:[^,\\n)]+/g;\n\n  while ((match = lambdaRegex.exec(text)) !== null) {\n    idioms.push({\n      idiom: match[0],\n      type: \"python_lambda\",\n      location: {\n        start: match.index,\n        end: match.index + match[0].length,\n      },\n    });\n  }\n\n  // 4. Detect generator expressions\n  const generatorRegex =\n    /\\(\\s*[^()]*\\s+for\\s+[^()]+\\s+in\\s+[^()]+(?:\\s+if\\s+[^()]+)?\\s*\\)/g;\n\n  while ((match = generatorRegex.exec(text)) !== null) {\n    idioms.push({\n      idiom: match[0],\n      type: \"python_generator_expression\",\n      location: {\n        start: match.index,\n        end: match.index + match[0].length,\n      },\n    });\n  }\n}\n\n/**\n * Identifies C#-specific idioms\n *\n * @param {string} text - C# code text\n * @param {Array} idioms - Array to add identified idioms to\n * @private\n */\nfunction identifyCSharpIdioms(text, idioms) {\n  // 1. Detect LINQ queries with method syntax\n  const linqMethodRegex =\n    /\\.\\s*(?:Where|Select|OrderBy|OrderByDescending|GroupBy|Join|Skip|Take|First|FirstOrDefault|Any|All|Count)\\s*\\(\\s*[^)]*\\)(?:\\s*\\.\\s*(?:Where|Select|OrderBy|OrderByDescending|GroupBy|Join|Skip|Take|First|FirstOrDefault|Any|All|Count)\\s*\\(\\s*[^)]*\\))*/g;\n  let match;\n\n  while ((match = linqMethodRegex.exec(text)) !== null) {\n    idioms.push({\n      idiom: match[0],\n      type: \"csharp_linq_method\",\n      location: {\n        start: match.index,\n        end: match.index + match[0].length,\n      },\n    });\n  }\n\n  // 2. Detect LINQ queries with query syntax\n  const linqQueryRegex =\n    /from\\s+\\w+\\s+in\\s+[^{]+(?:where\\s+[^{]+)?(?:orderby\\s+[^{]+)?(?:select\\s+[^{;]+)?(?:group\\s+[^{;]+by\\s+[^{;]+)?/g;\n\n  while ((match = linqQueryRegex.exec(text)) !== null) {\n    idioms.push({\n      idiom: match[0],\n      type: \"csharp_linq_query\",\n      location: {\n        start: match.index,\n        end: match.index + match[0].length,\n      },\n    });\n  }\n\n  // 3. Detect async/await patterns\n  const asyncAwaitRegex =\n    /\\basync\\s+[^(]*\\([^)]*\\)(?:\\s*<[^>]*>)?\\s*(?:=>)?\\s*{(?:(?:.|\\n)*?\\bawait\\b(?:.|\\n)*?)}/g;\n\n  while ((match = asyncAwaitRegex.exec(text)) !== null) {\n    idioms.push({\n      idiom: match[0],\n      type: \"csharp_async_await\",\n      location: {\n        start: match.index,\n        end: match.index + match[0].length,\n      },\n    });\n  }\n\n  // 4. Detect lambda expressions\n  const lambdaRegex = /(?:\\([^)]*\\)|\\w+)\\s*=>\\s*(?:{[^}]*}|[^;]+)/g;\n\n  while ((match = lambdaRegex.exec(text)) !== null) {\n    // Avoid duplicate detection with LINQ methods\n    const isDuplicate = idioms.some(\n      (idiom) =>\n        (idiom.type === \"csharp_linq_method\" ||\n          idiom.type === \"csharp_linq_query\") &&\n        match.index >= idiom.location.start &&\n        match.index + match[0].length <= idiom.location.end\n    );\n\n    if (!isDuplicate) {\n      idioms.push({\n        idiom: match[0],\n        type: \"csharp_lambda\",\n        location: {\n          start: match.index,\n          end: match.index + match[0].length,\n        },\n      });\n    }\n  }\n}\n\n/**\n * Extracts keywords from an array of tokens with language-specific enhancements\n *\n * @param {string[]} tokens - Array of tokens (from tokenize function)\n * @param {number} topN - Number of top keywords to return (default: 10)\n * @param {string} language - Programming language hint (default: 'plaintext')\n * @returns {{keyword: string, score: number}[]} Array of keywords with scores\n */\nexport function extractKeywords(tokens, topN = 10, language = \"plaintext\") {\n  // Get language-specific stop words\n  const stopWords = getStopWords(language);\n\n  // Calculate term frequencies\n  const termFrequencies = {};\n  for (const token of tokens) {\n    if (!termFrequencies[token]) {\n      termFrequencies[token] = 0;\n    }\n    termFrequencies[token]++;\n  }\n\n  // Apply scoring heuristics\n  const scoredKeywords = [];\n\n  for (const [token, frequency] of Object.entries(termFrequencies)) {\n    // Skip stop words unless they're part of something significant\n    // (e.g., longer than typical stop words or contain special characters)\n    if (stopWords.has(token) && token.length < 6 && !/[_\\-$#@]/.test(token)) {\n      continue;\n    }\n\n    // Base score is the term frequency\n    let score = frequency;\n\n    // Boost domain-specific tokens (identifiers)\n    if (isDomainSpecificToken(token, language)) {\n      score *= 2.0;\n    }\n\n    // Boost longer words (they tend to be more meaningful)\n    if (token.length > 6) {\n      score *= 1.5;\n    }\n\n    // Boost tokens with special characters that are likely important in code\n    if (/[_$]/.test(token)) {\n      score *= 1.2;\n    }\n\n    // Penalize very short tokens that aren't likely to be meaningful\n    if (token.length < 3 && !/[_\\-$#@]/.test(token)) {\n      score *= 0.5;\n    }\n\n    // Additional boosts for language-specific patterns\n    score = applyLanguageSpecificBoosts(token, score, language);\n\n    scoredKeywords.push({\n      keyword: token,\n      score: score,\n    });\n  }\n\n  // Sort by score (descending) and return top N\n  return scoredKeywords.sort((a, b) => b.score - a.score).slice(0, topN);\n}\n\n/**\n * Determines if a token is likely a domain-specific identifier\n *\n * @param {string} token - The token to check\n * @param {string} language - The programming language\n * @returns {boolean} True if the token appears to be domain-specific\n */\nfunction isDomainSpecificToken(token, language) {\n  // Check for common patterns that indicate domain-specific tokens\n\n  // CamelCase or PascalCase (common in most languages)\n  if (/[a-z][A-Z]/.test(token) || /^[A-Z][a-z]/.test(token)) {\n    return true;\n  }\n\n  // snake_case (common in Python, Ruby)\n  if (token.includes(\"_\") && token.length > 4) {\n    return true;\n  }\n\n  // Special prefixes/patterns common in various languages\n  if (/^(on|handle|process|get|set|is|has|should|with)/i.test(token)) {\n    return true;\n  }\n\n  // Tokens with numbers are often domain-specific\n  if (/[a-z][0-9]/.test(token)) {\n    return true;\n  }\n\n  // JavaScript/TypeScript specific\n  if (\n    (language === \"javascript\" || language === \"typescript\") &&\n    (/\\$/.test(token) || // Angular, jQuery\n      /^use[A-Z]/.test(token))\n  ) {\n    // React hooks\n    return true;\n  }\n\n  // Python specific\n  if (\n    language === \"python\" &&\n    (/^__.*__$/.test(token) || // dunder methods\n      /^self\\./.test(token))\n  ) {\n    // instance attributes\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Apply language-specific score boosts to tokens\n *\n * @param {string} token - The token to apply boosts to\n * @param {number} score - The current score\n * @param {string} language - The programming language\n * @returns {number} The updated score\n */\nfunction applyLanguageSpecificBoosts(token, score, language) {\n  switch (language) {\n    case \"javascript\":\n    case \"typescript\":\n    case \"jsx\":\n    case \"tsx\":\n      // Boost React/component related terms\n      if (\n        /^(use|component|props|state|render|effect|memo|callback)/.test(token)\n      ) {\n        score *= 1.5;\n      }\n      // Boost event handler patterns\n      if (/^(on[A-Z]|handle[A-Z])/.test(token)) {\n        score *= 1.3;\n      }\n      break;\n\n    case \"python\":\n      // Boost important Python patterns\n      if (/^(def|class|self|super|__init__|__main__)/.test(token)) {\n        score *= 1.3;\n      }\n      // Boost decorators\n      if (/^@/.test(token)) {\n        score *= 1.4;\n      }\n      break;\n\n    case \"java\":\n    case \"csharp\":\n    case \"c#\":\n      // Boost important Java/C# patterns\n      if (\n        /^(public|private|protected|static|final|override|virtual|abstract)/.test(\n          token\n        )\n      ) {\n        score *= 1.2;\n      }\n      // Boost class/interface/enum declarations\n      if (/^(class|interface|enum|record|struct)/.test(token)) {\n        score *= 1.3;\n      }\n      break;\n\n    case \"ruby\":\n      // Boost Ruby-specific patterns\n      if (/^(attr_|def|class|module|require|include|extend)/.test(token)) {\n        score *= 1.3;\n      }\n      // Boost symbols\n      if (/^:/.test(token)) {\n        score *= 1.2;\n      }\n      break;\n\n    case \"go\":\n      // Boost Go-specific patterns\n      if (/^(func|struct|interface|type|go|chan|defer|goroutine)/.test(token)) {\n        score *= 1.3;\n      }\n      break;\n  }\n\n  return score;\n}\n\n/**\n * Get stop words for the specified language\n *\n * @param {string} language - The programming language\n * @returns {Set<string>} Set of stop words\n */\nfunction getStopWords(language) {\n  // Common English stop words\n  const commonStopWords = new Set([\n    \"a\",\n    \"an\",\n    \"the\",\n    \"and\",\n    \"or\",\n    \"but\",\n    \"if\",\n    \"then\",\n    \"else\",\n    \"when\",\n    \"at\",\n    \"from\",\n    \"by\",\n    \"for\",\n    \"with\",\n    \"about\",\n    \"against\",\n    \"between\",\n    \"into\",\n    \"through\",\n    \"during\",\n    \"before\",\n    \"after\",\n    \"above\",\n    \"below\",\n    \"to\",\n    \"is\",\n    \"am\",\n    \"are\",\n    \"was\",\n    \"were\",\n    \"be\",\n    \"been\",\n    \"being\",\n    \"have\",\n    \"has\",\n    \"had\",\n    \"having\",\n    \"do\",\n    \"does\",\n    \"did\",\n    \"doing\",\n    \"would\",\n    \"should\",\n    \"could\",\n    \"ought\",\n    \"i\",\n    \"you\",\n    \"he\",\n    \"she\",\n    \"it\",\n    \"we\",\n    \"they\",\n    \"their\",\n    \"this\",\n    \"that\",\n    \"these\",\n    \"those\",\n    \"of\",\n    \"in\",\n    \"as\",\n    \"on\",\n    \"not\",\n    \"no\",\n    \"its\",\n    \"his\",\n    \"her\",\n  ]);\n\n  // Common programming language keywords\n  const commonProgrammingStopWords = new Set([\n    \"function\",\n    \"class\",\n    \"if\",\n    \"else\",\n    \"for\",\n    \"while\",\n    \"do\",\n    \"switch\",\n    \"case\",\n    \"break\",\n    \"continue\",\n    \"return\",\n    \"try\",\n    \"catch\",\n    \"finally\",\n    \"throw\",\n    \"throws\",\n    \"public\",\n    \"private\",\n    \"protected\",\n    \"static\",\n    \"final\",\n    \"abstract\",\n    \"interface\",\n    \"extends\",\n    \"implements\",\n    \"import\",\n    \"export\",\n    \"package\",\n    \"namespace\",\n    \"var\",\n    \"let\",\n    \"const\",\n    \"new\",\n    \"this\",\n    \"super\",\n    \"null\",\n    \"undefined\",\n    \"true\",\n    \"false\",\n  ]);\n\n  // Start with common stop words for all languages\n  const stopWords = new Set([\n    ...commonStopWords,\n    ...commonProgrammingStopWords,\n  ]);\n\n  // Add language-specific stop words\n  switch (language) {\n    case \"javascript\":\n    case \"typescript\":\n    case \"jsx\":\n    case \"tsx\":\n      // JavaScript/TypeScript specific\n      [\n        \"typeof\",\n        \"instanceof\",\n        \"async\",\n        \"await\",\n        \"yield\",\n        \"void\",\n        \"delete\",\n        \"module\",\n        \"require\",\n        \"console\",\n        \"log\",\n        \"window\",\n        \"document\",\n        \"event\",\n        \"prototype\",\n        \"constructor\",\n        \"string\",\n        \"number\",\n        \"boolean\",\n        \"object\",\n        \"array\",\n      ].forEach((word) => stopWords.add(word));\n      break;\n\n    case \"python\":\n      // Python specific\n      [\n        \"def\",\n        \"lambda\",\n        \"from\",\n        \"as\",\n        \"import\",\n        \"with\",\n        \"is\",\n        \"in\",\n        \"not\",\n        \"and\",\n        \"or\",\n        \"global\",\n        \"nonlocal\",\n        \"pass\",\n        \"yield\",\n        \"assert\",\n        \"del\",\n        \"raise\",\n        \"except\",\n        \"print\",\n        \"exec\",\n        \"eval\",\n        \"None\",\n        \"True\",\n        \"False\",\n        \"range\",\n        \"len\",\n        \"self\",\n      ].forEach((word) => stopWords.add(word));\n      break;\n\n    case \"java\":\n      // Java specific\n      [\n        \"void\",\n        \"boolean\",\n        \"byte\",\n        \"char\",\n        \"short\",\n        \"int\",\n        \"long\",\n        \"float\",\n        \"double\",\n        \"instanceof\",\n        \"strictfp\",\n        \"synchronized\",\n        \"transient\",\n        \"volatile\",\n        \"native\",\n        \"package\",\n        \"throws\",\n        \"throw\",\n        \"exception\",\n        \"assert\",\n        \"enum\",\n      ].forEach((word) => stopWords.add(word));\n      break;\n\n    case \"csharp\":\n    case \"c#\":\n      // C# specific\n      [\n        \"using\",\n        \"namespace\",\n        \"where\",\n        \"select\",\n        \"from\",\n        \"group\",\n        \"into\",\n        \"orderby\",\n        \"join\",\n        \"equals\",\n        \"out\",\n        \"ref\",\n        \"in\",\n        \"value\",\n        \"is\",\n        \"as\",\n        \"void\",\n        \"int\",\n        \"string\",\n        \"bool\",\n        \"decimal\",\n        \"object\",\n        \"char\",\n        \"byte\",\n        \"sbyte\",\n        \"uint\",\n        \"long\",\n        \"ulong\",\n        \"short\",\n        \"ushort\",\n        \"double\",\n        \"float\",\n        \"dynamic\",\n        \"delegate\",\n        \"event\",\n        \"async\",\n        \"await\",\n        \"partial\",\n        \"virtual\",\n        \"override\",\n        \"sealed\",\n        \"base\",\n      ].forEach((word) => stopWords.add(word));\n      break;\n\n    case \"ruby\":\n      // Ruby specific\n      [\n        \"def\",\n        \"end\",\n        \"module\",\n        \"require\",\n        \"include\",\n        \"extend\",\n        \"attr\",\n        \"attr_reader\",\n        \"attr_writer\",\n        \"attr_accessor\",\n        \"lambda\",\n        \"proc\",\n        \"yield\",\n        \"self\",\n        \"nil\",\n        \"true\",\n        \"false\",\n        \"unless\",\n        \"until\",\n        \"begin\",\n        \"rescue\",\n        \"ensure\",\n        \"alias\",\n      ].forEach((word) => stopWords.add(word));\n      break;\n\n    case \"go\":\n      // Go specific\n      [\n        \"func\",\n        \"type\",\n        \"struct\",\n        \"interface\",\n        \"map\",\n        \"chan\",\n        \"go\",\n        \"select\",\n        \"package\",\n        \"import\",\n        \"const\",\n        \"var\",\n        \"iota\",\n        \"make\",\n        \"new\",\n        \"append\",\n        \"len\",\n        \"cap\",\n        \"nil\",\n        \"true\",\n        \"false\",\n        \"int\",\n        \"int8\",\n        \"int16\",\n        \"int32\",\n        \"int64\",\n        \"uint\",\n        \"uint8\",\n        \"uint16\",\n        \"uint32\",\n        \"uint64\",\n        \"float32\",\n        \"float64\",\n        \"string\",\n        \"byte\",\n        \"rune\",\n        \"defer\",\n        \"panic\",\n        \"recover\",\n      ].forEach((word) => stopWords.add(word));\n      break;\n  }\n\n  return stopWords;\n}\n\n/**\n * Generic tokenization for unknown languages or plaintext\n *\n * @param {string} text - The text to tokenize\n * @returns {string[]} An array of tokens\n */\nfunction tokenizeGeneric(text) {\n  // Replace common punctuation with spaces before splitting\n  // But preserve meaningful symbols like _, -, #, @ if part of identifiers\n  const withSpaces = text\n    // Preserve common identifier patterns\n    .replace(/([a-z0-9])[-_]([a-z0-9])/g, \"$1\\u0001$2\") // Replace with placeholder\n    // Add space around punctuation\n    .replace(/[.,;:(){}[\\]<>?!]/g, \" $& \")\n    // Restore preserved symbols\n    .replace(/\\u0001/g, \"_\");\n\n  // Split by whitespace and filter out empty tokens\n  let tokens = withSpaces.split(/\\s+/).filter((token) => token.length > 0);\n\n  return tokens;\n}\n\n/**\n * JavaScript/TypeScript-specific tokenization\n * Handles camelCase, PascalCase, module imports, JSX tags, template literals, decorators\n *\n * @param {string} text - The JavaScript/TypeScript text to tokenize\n * @returns {string[]} An array of tokens\n */\nfunction tokenizeJavaScript(text) {\n  let tokens = [];\n\n  // Preserve comments for content analysis but mark them specially\n  const commentPlaceholders = {};\n  let commentCounter = 0;\n\n  // Remove block comments first\n  const withoutBlockComments = text.replace(/\\/\\*[\\s\\S]*?\\*\\//g, (match) => {\n    const placeholder = `__COMMENT_BLOCK_${commentCounter++}__`;\n    commentPlaceholders[placeholder] = match;\n    return placeholder;\n  });\n\n  // Remove line comments\n  const withoutComments = withoutBlockComments.replace(\n    /\\/\\/[^\\n]*/g,\n    (match) => {\n      const placeholder = `__COMMENT_LINE_${commentCounter++}__`;\n      commentPlaceholders[placeholder] = match;\n      return placeholder;\n    }\n  );\n\n  // Track string literals and code blocks to avoid tokenizing their contents incorrectly\n  const stringPlaceholders = {};\n  let stringCounter = 0;\n\n  // Handle regex literals - important to do this before handling division operator\n  // Look for patterns like /.../ not preceded by identifiers or closing brackets/parentheses\n  const withoutRegex = withoutComments.replace(\n    /(?<![a-zA-Z0-9_\\)\\]\\}])\\/(?:\\\\\\/|[^\\/\\n])+\\/[gimuy]*/g,\n    (match) => {\n      const placeholder = `__REGEX_${stringCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n      return placeholder;\n    }\n  );\n\n  // Handle template literals with interpolation\n  // Capture the whole template including expressions inside ${}\n  const withoutTemplateLiterals = withoutRegex.replace(\n    /`(?:\\\\`|\\\\\\\\|[^`])*`/g,\n    (match) => {\n      const placeholder = `__TEMPLATE_${stringCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n\n      // Extract interpolated expressions from ${...} and tokenize them separately\n      const expressions = [];\n      let expContent = match.match(/\\${([^}]*)}/g);\n      if (expContent) {\n        expContent.forEach((exp) => {\n          expressions.push(exp.slice(2, -1)); // Remove ${ and }\n        });\n\n        // Tokenize each expression content\n        expressions.forEach((exp) => {\n          const expTokens = tokenizeJavaScript(exp); // Recursively tokenize expressions\n          tokens.push(...expTokens);\n        });\n      }\n\n      return placeholder;\n    }\n  );\n\n  // Handle string literals with placeholder\n  const withoutStrings = withoutTemplateLiterals.replace(\n    /'(?:\\\\'|\\\\\\\\|[^'])*'|\"(?:\\\\\"|\\\\\\\\|[^\"])*\"/g,\n    (match) => {\n      const placeholder = `__STRING_${stringCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n      return placeholder;\n    }\n  );\n\n  // Handle JSX tags - more comprehensive approach for nested components\n  // First, capture JSX opening tags, self-closing tags, and closing tags\n  const withoutJSX = withoutStrings.replace(\n    /<([A-Z][a-zA-Z0-9]*|[a-z][a-z0-9]*)((?:\\s+[a-zA-Z0-9_]+(?:=(?:\"|'|\\{).*?(?:\"|'|\\}))?)*)\\s*(?:\\/)?>/g,\n    (match, tagName, attributes) => {\n      const placeholder = `__JSX_TAG_${stringCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n\n      // Add the tag name as token\n      tokens.push(tagName);\n\n      // Extract and add attribute names\n      if (attributes) {\n        const attrMatches = attributes.match(/[a-zA-Z0-9_]+(?==)/g);\n        if (attrMatches) {\n          tokens.push(...attrMatches);\n        }\n      }\n\n      return placeholder;\n    }\n  );\n\n  // Handle JSX closing tags\n  const withoutJSXClosing = withoutJSX.replace(\n    /<\\/([A-Z][a-zA-Z0-9]*|[a-z][a-z0-9]*)>/g,\n    (match, tagName) => {\n      const placeholder = `__JSX_CLOSING_${stringCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n      tokens.push(tagName);\n      return placeholder;\n    }\n  );\n\n  // Handle decorators with placeholder - more comprehensive for complex decorators\n  const withoutDecorators = withoutJSXClosing.replace(\n    /@([a-zA-Z][a-zA-Z0-9_]*)(?:\\((?:[^)(]*|\\([^)(]*\\))*\\))?/g,\n    (match, decoratorName) => {\n      const placeholder = `__DECORATOR_${stringCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n\n      // Add the decorator name as token\n      tokens.push(decoratorName);\n\n      // If there are parameters to the decorator, tokenize them separately\n      const paramMatch = match.match(/\\((.*)\\)/);\n      if (paramMatch && paramMatch[1]) {\n        const paramTokens = tokenizeGeneric(paramMatch[1]);\n        tokens.push(...paramTokens);\n      }\n\n      return placeholder;\n    }\n  );\n\n  // Handle arrow functions specially\n  const withoutArrows = withoutDecorators.replace(/=>/g, (match) => {\n    tokens.push(\"arrow_function\"); // Use a special token for recognizing arrow functions\n    return \" => \"; // Preserve the token but with spaces for other tokenization\n  });\n\n  // Handle optional chaining and nullish coalescing\n  const withSpecialOps = withoutArrows\n    .replace(/\\?\\./g, (match) => {\n      tokens.push(\"optional_chaining\");\n      return \" ?. \"; // Space-separated for tokenization\n    })\n    .replace(/\\?\\?/g, (match) => {\n      tokens.push(\"nullish_coalescing\");\n      return \" ?? \"; // Space-separated for tokenization\n    });\n\n  // Handle import statements more robustly\n  const withoutImports = withSpecialOps.replace(\n    /import\\s+(?:{[^}]*}|\\*\\s+as\\s+[a-zA-Z][a-zA-Z0-9_]*|[a-zA-Z][a-zA-Z0-9_]*)\\s+from\\s+['\"][^'\"]*['\"]/g,\n    (match) => {\n      // Add import as a token\n      tokens.push(\"import\");\n\n      // Extract module name\n      const moduleMatch = match.match(/from\\s+['\"]([^'\"]*)['\"]/);\n      if (moduleMatch && moduleMatch[1]) {\n        tokens.push(moduleMatch[1]);\n      }\n\n      // Extract imported identifiers\n      const importedMatch = match.match(\n        /import\\s+({[^}]*}|\\*\\s+as\\s+[a-zA-Z][a-zA-Z0-9_]*|[a-zA-Z][a-zA-Z0-9_]*)/\n      );\n      if (importedMatch && importedMatch[1]) {\n        const importSection = importedMatch[1];\n\n        if (importSection.startsWith(\"{\")) {\n          // Named imports\n          const namedImports = importSection\n            .replace(/[{}]/g, \"\")\n            .split(\",\")\n            .map((part) => part.trim())\n            .filter((part) => part.length > 0);\n\n          tokens.push(...namedImports);\n        } else if (importSection.includes(\"* as\")) {\n          // Namespace import\n          const nsMatch = importSection.match(\n            /\\*\\s+as\\s+([a-zA-Z][a-zA-Z0-9_]*)/\n          );\n          if (nsMatch && nsMatch[1]) {\n            tokens.push(nsMatch[1]);\n          }\n        } else {\n          // Default import\n          tokens.push(importSection.trim());\n        }\n      }\n\n      return \" \"; // Replace with a space\n    }\n  );\n\n  // Split remaining text into tokens\n  let mainTokens = tokenizeGeneric(withoutImports);\n\n  // Handle camelCase and PascalCase by splitting them into separate tokens\n  const processedTokens = [];\n  for (const token of mainTokens) {\n    // Skip placeholder tokens (we'll handle them separately)\n    if (token.startsWith(\"__\") && token.endsWith(\"__\")) {\n      processedTokens.push(token);\n      continue;\n    }\n\n    // Skip operators we've already handled\n    if ([\"=>\", \"?.\", \"??\"].includes(token)) {\n      processedTokens.push(token);\n      continue;\n    }\n\n    // Split camelCase into separate tokens\n    const camelTokens = token\n      .replace(/([a-z])([A-Z])/g, \"$1 $2\")\n      .toLowerCase()\n      .split(\" \");\n\n    // Add original token and split tokens\n    processedTokens.push(token);\n    if (camelTokens.length > 1) {\n      processedTokens.push(...camelTokens);\n    }\n  }\n\n  // Replace placeholders with their original values\n  const finalTokens = [];\n  for (const token of processedTokens) {\n    if (stringPlaceholders[token]) {\n      // Add the original placeholder as a token (to preserve context)\n      if (token.startsWith(\"__REGEX_\")) {\n        finalTokens.push(\"regex_literal\");\n      } else if (token.startsWith(\"__JSX_\")) {\n        finalTokens.push(\"jsx_element\");\n      } else if (token.startsWith(\"__DECORATOR_\")) {\n        finalTokens.push(\"decorator\");\n      } else {\n        finalTokens.push(token);\n      }\n\n      // For string literals, also add their content as tokens\n      if (token.startsWith(\"__STRING_\") || token.startsWith(\"__TEMPLATE_\")) {\n        // Extract content and add relevant words\n        const content = stringPlaceholders[token];\n        // Remove quotes/backticks and tokenize content\n        const strContent = content.replace(/^[`'\"](.*)[`'\"]$/s, \"$1\");\n        const contentTokens = tokenizeGeneric(strContent);\n        finalTokens.push(...contentTokens);\n      }\n    } else if (commentPlaceholders[token]) {\n      // For comments, optionally extract keywords if needed\n      // Don't add the full comment as a token to avoid noise\n      finalTokens.push(\"code_comment\");\n\n      // Extract possible important terms from comments\n      const commentContent = commentPlaceholders[token]\n        .replace(/^\\/\\*|\\*\\/$/g, \"\") // Remove /* */\n        .replace(/^\\/\\//g, \"\"); // Remove //\n\n      // Only use alphanumeric words from comments, skip punctuation and symbols\n      const commentTokens = commentContent\n        .split(/\\s+/)\n        .filter((word) => /^[a-z0-9_]{3,}$/i.test(word))\n        .map((word) => word.toLowerCase());\n\n      finalTokens.push(...commentTokens);\n    } else {\n      finalTokens.push(token);\n    }\n  }\n\n  return [...new Set(finalTokens)]; // Remove duplicates\n}\n\n/**\n * Python-specific tokenization\n * Handles snake_case, decorators, f-strings, indentation significance\n *\n * @param {string} text - The Python text to tokenize\n * @returns {string[]} An array of tokens\n */\nfunction tokenizePython(text) {\n  let tokens = [];\n\n  // Preserve comments for content analysis but mark them specially\n  const commentPlaceholders = {};\n  let commentCounter = 0;\n\n  // Remove block comments first (triple-quoted strings when used as comments)\n  const withoutDocstrings = text.replace(\n    /(?:'''[\\s\\S]*?'''|\"\"\"[\\s\\S]*?\"\"\")/g,\n    (match) => {\n      const placeholder = `__PYCOMMENT_BLOCK_${commentCounter++}__`;\n      commentPlaceholders[placeholder] = match;\n      return placeholder;\n    }\n  );\n\n  // Remove line comments\n  const withoutComments = withoutDocstrings.replace(/#[^\\n]*/g, (match) => {\n    const placeholder = `__PYCOMMENT_LINE_${commentCounter++}__`;\n    commentPlaceholders[placeholder] = match;\n    return placeholder;\n  });\n\n  // Handle string literals\n  const stringPlaceholders = {};\n  let placeholderCounter = 0;\n\n  // Enhanced f-string handling - look for f, fr, rf prefixes and capture interpolation\n  const withoutFStrings = withoutComments.replace(\n    /(?:f|fr|rf)(?:'''[\\s\\S]*?'''|\"\"\"[\\s\\S]*?\"\"\"|'(?:\\\\'|\\\\\\\\|[^'])*'|\"(?:\\\\\"|\\\\\\\\|[^\"])*\")/g,\n    (match) => {\n      const placeholder = `__PYFSTRING_${placeholderCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n\n      // Extract interpolated expressions from {...} and tokenize them separately\n      const expressions = [];\n      // Match {expression} but not escaped \\{\n      let expContent = match.match(/(?<!\\\\){([^{}]*)}/g);\n      if (expContent) {\n        expContent.forEach((exp) => {\n          expressions.push(exp.slice(1, -1)); // Remove { and }\n        });\n\n        // Tokenize each expression content\n        expressions.forEach((exp) => {\n          const expTokens = tokenizePython(exp); // Recursively tokenize expressions\n          tokens.push(...expTokens);\n        });\n      }\n\n      return placeholder;\n    }\n  );\n\n  // Handle other string literals (r-strings, normal strings)\n  const withoutSpecialStrings = withoutFStrings.replace(\n    /(?:r|b|rb|br)?(?:'''[\\s\\S]*?'''|\"\"\"[\\s\\S]*?\"\"\"|'(?:\\\\'|\\\\\\\\|[^'])*'|\"(?:\\\\\"|\\\\\\\\|[^\"])*\")/g,\n    (match) => {\n      const placeholder = `__PYSTRING_${placeholderCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n      return placeholder;\n    }\n  );\n\n  // Handle decorators with placeholder - more comprehensive for complex decorators\n  const withoutDecorators = withoutSpecialStrings.replace(\n    /@([a-zA-Z][a-zA-Z0-9_.]*)(?:\\((?:[^)(]*|\\([^)(]*\\))*\\))?/g,\n    (match, decoratorName) => {\n      const placeholder = `__PYDECORATOR_${placeholderCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n\n      // Add decorator name as token\n      tokens.push(decoratorName);\n\n      // If the decorator has parameters, extract and tokenize them\n      const paramMatch = match.match(/\\((.*)\\)/);\n      if (paramMatch && paramMatch[1]) {\n        const paramTokens = tokenizeGeneric(paramMatch[1]);\n        tokens.push(...paramTokens);\n      }\n\n      return placeholder;\n    }\n  );\n\n  // Handle Python-specific operators\n  const withSpecialOps = withoutDecorators\n    // Handle walrus operator :=\n    .replace(/:=/g, (match) => {\n      tokens.push(\"walrus_operator\");\n      return \" := \"; // Space-separated for tokenization\n    })\n    // Handle list splices with :\n    .replace(/\\[.*:.*\\]/g, (match) => {\n      tokens.push(\"slice_operation\");\n      // Process what's inside the brackets\n      const innerContent = match.slice(1, -1);\n      const sliceParts = innerContent.split(\":\");\n      sliceParts.forEach((part) => {\n        if (part.trim()) {\n          const partTokens = tokenizeGeneric(part.trim());\n          tokens.push(...partTokens);\n        }\n      });\n      return match; // Preserve for general tokenization\n    });\n\n  // Process lines with indentation awareness\n  const lines = withSpecialOps.split(\"\\n\");\n\n  // Track indentation levels\n  let previousIndentLevel = 0;\n\n  for (const line of lines) {\n    // Skip empty lines\n    if (line.trim() === \"\") continue;\n\n    // Count leading spaces/tabs to track indentation\n    const indentMatch = line.match(/^(\\s*)/);\n    const leadingSpaces = indentMatch ? indentMatch[1].length : 0;\n\n    if (leadingSpaces !== previousIndentLevel) {\n      if (leadingSpaces > previousIndentLevel) {\n        // Indentation increased - add token for indent\n        tokens.push(\"indent\");\n      } else {\n        // Indentation decreased - add token for dedent\n        // Add one dedent token for each level decreased\n        const dedentLevels = Math.floor(\n          (previousIndentLevel - leadingSpaces) / 4\n        );\n        for (let i = 0; i < dedentLevels; i++) {\n          tokens.push(\"dedent\");\n        }\n      }\n      previousIndentLevel = leadingSpaces;\n    }\n\n    // Tokenize the line content by first removing the leading whitespace\n    const lineContent = line.trim();\n    if (lineContent) {\n      // Check for keyword tokens\n      const pythonKeywords = [\n        \"def\",\n        \"class\",\n        \"lambda\",\n        \"return\",\n        \"yield\",\n        \"from\",\n        \"import\",\n        \"as\",\n        \"with\",\n        \"try\",\n        \"except\",\n        \"finally\",\n        \"raise\",\n        \"assert\",\n        \"if\",\n        \"elif\",\n        \"else\",\n        \"while\",\n        \"for\",\n        \"in\",\n        \"continue\",\n        \"break\",\n        \"pass\",\n        \"global\",\n        \"nonlocal\",\n        \"del\",\n        \"is\",\n        \"not\",\n        \"and\",\n        \"or\",\n        \"async\",\n        \"await\",\n        \"comprehension\",\n        \"self\",\n      ];\n\n      // Add line content keywords\n      for (const keyword of pythonKeywords) {\n        if (lineContent.includes(keyword)) {\n          const keywordRegex = new RegExp(`\\\\b${keyword}\\\\b`, \"g\");\n          if (keywordRegex.test(lineContent)) {\n            tokens.push(keyword);\n          }\n        }\n      }\n\n      // Now tokenize the whole line\n      const lineTokens = tokenizeGeneric(lineContent);\n      tokens.push(...lineTokens);\n    }\n  }\n\n  // Add keyword for Python-specific list operations\n  if (\n    withSpecialOps.includes(\"append(\") ||\n    withSpecialOps.includes(\".extend(\")\n  ) {\n    tokens.push(\"list_operation\");\n  }\n\n  // Add keyword for Python-specific dictionary operations\n  if (\n    withSpecialOps.includes(\".get(\") ||\n    withSpecialOps.includes(\".items()\") ||\n    withSpecialOps.includes(\".keys()\") ||\n    withSpecialOps.includes(\".values()\")\n  ) {\n    tokens.push(\"dict_operation\");\n  }\n\n  // Split snake_case identifiers\n  const snakeCaseTokens = [];\n  for (const token of tokens) {\n    // Skip placeholder tokens\n    if (token.startsWith(\"__\") && token.endsWith(\"__\")) {\n      snakeCaseTokens.push(token);\n      continue;\n    }\n\n    // Split snake_case\n    if (token.includes(\"_\")) {\n      const parts = token.split(\"_\").filter((part) => part.length > 0);\n      snakeCaseTokens.push(token); // Original token\n      snakeCaseTokens.push(...parts); // Parts of the token\n    } else {\n      snakeCaseTokens.push(token);\n    }\n  }\n\n  // Replace placeholders with their original values and process them\n  const finalTokens = [];\n  for (const token of snakeCaseTokens) {\n    if (stringPlaceholders[token]) {\n      if (token.startsWith(\"__PYFSTRING_\")) {\n        finalTokens.push(\"f_string\");\n      } else if (token.startsWith(\"__PYSTRING_\")) {\n        finalTokens.push(\"string_literal\");\n      } else if (token.startsWith(\"__PYDECORATOR_\")) {\n        finalTokens.push(\"decorator\");\n      } else {\n        finalTokens.push(token);\n      }\n\n      // For string placeholders, also tokenize their content\n      if (token.startsWith(\"__PYSTRING_\") || token.startsWith(\"__PYFSTRING_\")) {\n        const content = stringPlaceholders[token];\n        // Extract the content without prefix and quotes\n        let strContent = content;\n\n        // Handle different types of string literals\n        if (\n          strContent.startsWith(\"f\") ||\n          strContent.startsWith(\"r\") ||\n          strContent.startsWith(\"fr\") ||\n          strContent.startsWith(\"rf\") ||\n          strContent.startsWith(\"b\") ||\n          strContent.startsWith(\"rb\") ||\n          strContent.startsWith(\"br\")\n        ) {\n          const prefixLength = /^[a-z]+/.exec(strContent)[0].length;\n          strContent = strContent.substring(prefixLength);\n        }\n\n        // Remove quotes\n        strContent = strContent.replace(/^['\"]|['\"]$/g, \"\");\n        strContent = strContent.replace(/^'''|'''$/g, \"\");\n        strContent = strContent.replace(/^\"\"\"|\"\"\"$/g, \"\");\n\n        // Remove f-string interpolation markers\n        strContent = strContent.replace(/{[^{}]*}/g, \" \");\n\n        // Tokenize content\n        const contentTokens = tokenizeGeneric(strContent);\n        finalTokens.push(...contentTokens);\n      }\n    } else if (commentPlaceholders[token]) {\n      // Extract useful keywords from comments\n      finalTokens.push(\"code_comment\");\n\n      // Extract possible important terms from comments\n      const commentContent = commentPlaceholders[token]\n        .replace(/^#{1}/, \"\") // Remove #\n        .replace(/^'''|'''$/g, \"\") // Remove '''\n        .replace(/^\"\"\"|\"\"\"$/g, \"\"); // Remove \"\"\"\n\n      // Only use alphanumeric words from comments, skip punctuation and symbols\n      const commentTokens = commentContent\n        .split(/\\s+/)\n        .filter((word) => /^[a-z0-9_]{3,}$/i.test(word))\n        .map((word) => word.toLowerCase());\n\n      finalTokens.push(...commentTokens);\n    } else {\n      finalTokens.push(token);\n    }\n  }\n\n  return [...new Set(finalTokens)]; // Remove duplicates\n}\n\n/**\n * Java/C#-like language tokenization\n * Handles annotations, generics, access modifiers, lambda expressions\n *\n * @param {string} text - The Java or C# text to tokenize\n * @returns {string[]} An array of tokens\n */\nfunction tokenizeJavaLike(text) {\n  let tokens = [];\n\n  // Preserve comments for content analysis but mark them specially\n  const commentPlaceholders = {};\n  let commentCounter = 0;\n\n  // Remove block comments first\n  const withoutBlockComments = text.replace(/\\/\\*[\\s\\S]*?\\*\\//g, (match) => {\n    const placeholder = `__JAVA_COMMENT_BLOCK_${commentCounter++}__`;\n    commentPlaceholders[placeholder] = match;\n    return placeholder;\n  });\n\n  // Remove line comments\n  const withoutComments = withoutBlockComments.replace(\n    /\\/\\/[^\\n]*/g,\n    (match) => {\n      const placeholder = `__JAVA_COMMENT_LINE_${commentCounter++}__`;\n      commentPlaceholders[placeholder] = match;\n      return placeholder;\n    }\n  );\n\n  // Handle string literals with placeholders\n  const stringPlaceholders = {};\n  let placeholderCounter = 0;\n\n  // Handle string literals (support escaping)\n  const withoutStrings = withoutComments.replace(\n    /\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'/g,\n    (match) => {\n      const placeholder = `__JAVASTRING_${placeholderCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n      return placeholder;\n    }\n  );\n\n  // Handle annotations with parameters more comprehensively\n  const withoutAnnotations = withoutStrings.replace(\n    /@([a-zA-Z][a-zA-Z0-9_.]*)(?:\\s*\\((?:[^)(]*|\\([^)(]*\\))*\\))?/g,\n    (match, annotationName) => {\n      const placeholder = `__ANNOTATION_${placeholderCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n\n      // Add annotation name as a token\n      tokens.push(\"annotation\");\n      tokens.push(annotationName.toLowerCase());\n\n      // Extract and process annotation parameters\n      const paramMatch = match.match(/\\((.*)\\)/);\n      if (paramMatch && paramMatch[1]) {\n        const params = paramMatch[1];\n\n        // Handle key-value pairs in annotations\n        const keyValuePairs = params.split(\",\");\n        for (const pair of keyValuePairs) {\n          const parts = pair.split(\"=\");\n          if (parts.length === 2) {\n            // Add parameter name as token\n            tokens.push(parts[0].trim());\n          }\n          // Tokenize the values\n          const valueTokens = tokenizeGeneric(pair);\n          tokens.push(...valueTokens);\n        }\n      }\n\n      return placeholder;\n    }\n  );\n\n  // Handle generics with better nesting support\n  // This pattern can handle nested generics like Map<String, List<Integer>>\n  const withoutGenerics = withoutAnnotations.replace(\n    /<([^<>]*(?:<[^<>]*(?:<[^<>]*>)*[^<>]*>)*[^<>]*)>/g,\n    (match) => {\n      const placeholder = `__GENERIC_${placeholderCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n\n      // Add token for generic type usage\n      tokens.push(\"generic_type\");\n\n      // Process the content within the generic\n      // Remove the < and > delimiters\n      const content = match.slice(1, -1);\n\n      // Split by commas to get individual type parameters\n      const typeParams = content.split(/,(?![^<>]*>)/); // Split by commas not within angle brackets\n\n      // Process each type parameter\n      for (const param of typeParams) {\n        const paramTokens = tokenizeGeneric(param.trim());\n        tokens.push(...paramTokens);\n      }\n\n      return placeholder;\n    }\n  );\n\n  // Handle lambda expressions (Java: -> and C#: =>)\n  const withoutLambdas = withoutGenerics.replace(\n    /(?:\\(.*?\\)|[a-zA-Z_][a-zA-Z0-9_]*)\\s*(?:->|=>)\\s*(?:{[\\s\\S]*?}|[^;]*)/g,\n    (match) => {\n      const placeholder = `__LAMBDA_${placeholderCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n\n      // Add token for lambda expression\n      tokens.push(\"lambda_expression\");\n\n      // Tokenize the entire lambda expression to extract parameter and body tokens\n      const lambdaTokens = tokenizeGeneric(match);\n      tokens.push(...lambdaTokens);\n\n      return placeholder;\n    }\n  );\n\n  // Extract and add access modifiers as specific tokens\n  const accessModifiers = [\n    \"public\",\n    \"private\",\n    \"protected\",\n    \"internal\",\n    \"static\",\n    \"final\",\n    \"abstract\",\n    \"override\",\n    \"virtual\",\n    \"readonly\",\n    \"const\",\n    \"sealed\",\n    \"partial\",\n    \"async\",\n    \"volatile\",\n    \"transient\",\n    \"synchronized\",\n    \"unsafe\",\n    \"extern\",\n  ];\n\n  let withAccessModifiers = withoutLambdas;\n  for (const modifier of accessModifiers) {\n    // Use word boundaries to match whole words\n    const regex = new RegExp(`\\\\b${modifier}\\\\b`, \"gi\");\n    withAccessModifiers = withAccessModifiers.replace(regex, (match) => {\n      tokens.push(match.toLowerCase());\n      tokens.push(\"access_modifier\");\n      return match;\n    });\n  }\n\n  // Handle package/namespace declarations\n  withAccessModifiers = withAccessModifiers.replace(\n    /\\b(?:package|namespace)\\s+([a-zA-Z_][a-zA-Z0-9_.]*)/g,\n    (match, packageName) => {\n      tokens.push(\"package_declaration\");\n\n      // Add the package name and its components\n      const packageParts = packageName.split(\".\");\n      tokens.push(packageName);\n      tokens.push(...packageParts);\n\n      return match;\n    }\n  );\n\n  // Handle import/using statements\n  withAccessModifiers = withAccessModifiers.replace(\n    /\\b(?:import|using)\\s+(?:static\\s+)?([a-zA-Z_][a-zA-Z0-9_.]*(?:\\.\\*)?)/g,\n    (match, importName) => {\n      tokens.push(\"import_statement\");\n\n      // Add the import name and its components\n      const importParts = importName.split(\".\");\n      tokens.push(importName);\n      // Remove wildcard * from last part if present\n      if (\n        importParts.length > 0 &&\n        importParts[importParts.length - 1] === \"*\"\n      ) {\n        importParts.pop();\n        tokens.push(\"wildcard_import\");\n      }\n      tokens.push(...importParts);\n\n      return match;\n    }\n  );\n\n  // Handle common C# LINQ expressions\n  if (/\\bfrom\\b.*\\bin\\b.*\\bselect\\b/i.test(withAccessModifiers)) {\n    tokens.push(\"linq_expression\");\n\n    // Extract common LINQ keywords\n    const linqKeywords = [\n      \"from\",\n      \"in\",\n      \"select\",\n      \"where\",\n      \"group\",\n      \"by\",\n      \"into\",\n      \"orderby\",\n      \"join\",\n      \"let\",\n      \"on\",\n      \"equals\",\n    ];\n\n    for (const keyword of linqKeywords) {\n      const regex = new RegExp(`\\\\b${keyword}\\\\b`, \"gi\");\n      if (regex.test(withAccessModifiers)) {\n        tokens.push(`linq_${keyword}`);\n      }\n    }\n  }\n\n  // Add remaining tokens\n  const mainTokens = tokenizeGeneric(withAccessModifiers);\n  tokens.push(...mainTokens);\n\n  // Handle camelCase and PascalCase with more specialized type names\n  const processedTokens = [];\n  for (const token of tokens) {\n    // Skip placeholder tokens\n    if (token.startsWith(\"__\") && token.endsWith(\"__\")) {\n      processedTokens.push(token);\n      continue;\n    }\n\n    // Check if token might be a fully qualified name (contains dots)\n    if (token.includes(\".\")) {\n      const parts = token.split(\".\");\n      processedTokens.push(token); // Add the full token\n      processedTokens.push(...parts); // Add individual parts\n      continue;\n    }\n\n    // Split PascalCase and camelCase\n    // Add original token first\n    processedTokens.push(token);\n\n    // Then add split tokens if there's a case change\n    if (/[a-z][A-Z]/.test(token)) {\n      const parts = token\n        .replace(/([a-z])([A-Z])/g, \"$1 $2\")\n        .toLowerCase()\n        .split(\" \");\n\n      if (parts.length > 1) {\n        processedTokens.push(...parts);\n      }\n    }\n  }\n\n  // Replace placeholders with their original values\n  const finalTokens = [];\n  for (const token of processedTokens) {\n    if (stringPlaceholders[token]) {\n      // Add information about what kind of structure this is\n      if (token.startsWith(\"__JAVASTRING_\")) {\n        finalTokens.push(\"string_literal\");\n      } else if (token.startsWith(\"__ANNOTATION_\")) {\n        finalTokens.push(\"annotation\");\n      } else if (token.startsWith(\"__GENERIC_\")) {\n        finalTokens.push(\"generic\");\n      } else if (token.startsWith(\"__LAMBDA_\")) {\n        finalTokens.push(\"lambda\");\n      } else {\n        finalTokens.push(token);\n      }\n\n      // For string literals, add their content as tokens\n      if (token.startsWith(\"__JAVASTRING_\")) {\n        const content = stringPlaceholders[token];\n        // Extract the content without the quotes\n        const strContent = content.replace(/^\"|\"$/g, \"\").replace(/^'|'$/g, \"\");\n\n        // Only tokenize non-empty content\n        if (strContent.trim().length > 0) {\n          const contentTokens = tokenizeGeneric(strContent);\n          finalTokens.push(...contentTokens);\n        }\n      }\n    } else if (commentPlaceholders[token]) {\n      // Extract useful keywords from comments\n      finalTokens.push(\"code_comment\");\n\n      // Extract possible important terms from comments\n      const commentContent = commentPlaceholders[token]\n        .replace(/^\\/\\*|\\*\\/$/g, \"\") // Remove /* */\n        .replace(/^\\/\\//g, \"\"); // Remove //\n\n      // Only use alphanumeric words from comments, skip punctuation and symbols\n      const commentTokens = commentContent\n        .split(/\\s+/)\n        .filter((word) => /^[a-z0-9_]{3,}$/i.test(word))\n        .map((word) => word.toLowerCase());\n\n      finalTokens.push(...commentTokens);\n    } else {\n      finalTokens.push(token);\n    }\n  }\n\n  return [...new Set(finalTokens)]; // Remove duplicates\n}\n\n/**\n * Ruby-specific tokenization\n * Handles symbols, blocks, string interpolation, and range operators\n *\n * @param {string} text - The Ruby text to tokenize\n * @returns {string[]} An array of tokens\n */\nfunction tokenizeRuby(text) {\n  let tokens = [];\n\n  // Preserve comments for content analysis but mark them specially\n  const commentPlaceholders = {};\n  let commentCounter = 0;\n\n  // Remove block comments (=begin...=end)\n  const withoutBlockComments = text.replace(/=begin[\\s\\S]*?=end/g, (match) => {\n    const placeholder = `__RUBY_COMMENT_BLOCK_${commentCounter++}__`;\n    commentPlaceholders[placeholder] = match;\n    return placeholder;\n  });\n\n  // Remove line comments\n  const withoutComments = withoutBlockComments.replace(/#[^\\n]*/g, (match) => {\n    const placeholder = `__RUBY_COMMENT_LINE_${commentCounter++}__`;\n    commentPlaceholders[placeholder] = match;\n    return placeholder;\n  });\n\n  // Handle string literals and placeholders\n  const stringPlaceholders = {};\n  let placeholderCounter = 0;\n\n  // Handle string interpolation (#{...}) in double-quoted strings\n  // This is similar to f-strings in Python\n  const withoutInterpolation = withoutComments.replace(\n    /\"(?:[^\"\\\\]|\\\\.|#\\{[^}]*\\})*\"/g,\n    (match) => {\n      const placeholder = `__RUBY_INTERPOLATED_STRING_${placeholderCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n\n      // Extract interpolated expressions from #{...} and tokenize them separately\n      const expressions = [];\n      let expContent = match.match(/#\\{([^}]*)\\}/g);\n      if (expContent) {\n        expContent.forEach((exp) => {\n          expressions.push(exp.slice(2, -1)); // Remove #{ and }\n        });\n\n        // Tokenize each expression content\n        expressions.forEach((exp) => {\n          const expTokens = tokenizeRuby(exp); // Recursively tokenize expressions\n          tokens.push(...expTokens);\n        });\n      }\n\n      return placeholder;\n    }\n  );\n\n  // Handle other string literals (including %q, %Q, heredocs)\n  const withoutStrings = withoutInterpolation.replace(\n    /('(?:[^'\\\\]|\\\\.)*'|%[qQ]?\\{(?:[^\\\\}]|\\\\.)*\\}|%[qQ]?\\((?:[^\\\\)]|\\\\.)*\\)|%[qQ]?\\[(?:[^\\\\]]|\\\\.)*\\]|%[qQ]?<(?:[^\\\\>]|\\\\.)*>|<<-?(['\"]?)(\\w+)\\1[\\s\\S]*?\\2)/g,\n    (match) => {\n      const placeholder = `__RUBY_STRING_${placeholderCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n      return placeholder;\n    }\n  );\n\n  // Handle regular expressions with placeholder\n  const withoutRegexps = withoutStrings.replace(\n    /\\/(?:[^\\/\\\\]|\\\\.)*\\/[iomxneus]*/g,\n    (match) => {\n      const placeholder = `__RUBY_REGEXP_${placeholderCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n      tokens.push(\"regexp\");\n      return placeholder;\n    }\n  );\n\n  // Handle Ruby symbols with placeholder\n  const withoutSymbols = withoutRegexps.replace(\n    /:(?:@?[a-zA-Z_][a-zA-Z0-9_]*(?:[?!]|=(?!=))?|\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|\\S+)/g,\n    (match) => {\n      const placeholder = `__RUBY_SYMBOL_${placeholderCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n\n      // Extract symbol name without the colon\n      const symbolName = match.substring(1);\n      tokens.push(\"symbol\");\n      tokens.push(`symbol_${symbolName}`);\n\n      // Add the base name without question mark or exclamation mark\n      if (symbolName.endsWith(\"?\") || symbolName.endsWith(\"!\")) {\n        tokens.push(`symbol_${symbolName.slice(0, -1)}`);\n      }\n\n      return placeholder;\n    }\n  );\n\n  // Handle blocks (do...end and {...}) with placeholder\n  let withoutBlocks = withoutSymbols;\n\n  // do...end blocks\n  withoutBlocks = withoutBlocks.replace(\n    /\\bdo\\s*(?:\\|[^|]*\\|)?[\\s\\S]*?\\bend\\b/g,\n    (match) => {\n      const placeholder = `__RUBY_BLOCK_DO_${placeholderCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n\n      tokens.push(\"block_do_end\");\n\n      // Extract block parameters\n      const paramMatch = match.match(/\\|\\s*([^|]*)\\s*\\|/);\n      if (paramMatch && paramMatch[1]) {\n        const params = paramMatch[1].split(\",\");\n        params.forEach((param) => {\n          tokens.push(param.trim());\n        });\n      }\n\n      // Tokenize block content\n      const blockContent = match\n        .replace(/\\bdo\\s*(?:\\|[^|]*\\|)?/, \"\") // Remove 'do' and params\n        .replace(/\\bend\\b$/, \"\"); // Remove 'end'\n\n      const contentTokens = tokenizeGeneric(blockContent);\n      tokens.push(...contentTokens);\n\n      return placeholder;\n    }\n  );\n\n  // {...} blocks\n  withoutBlocks = withoutBlocks.replace(\n    /\\{(?:\\s*\\|[^|]*\\|\\s*)?[^{}]*(?:\\{[^{}]*\\}[^{}]*)*\\}/g,\n    (match) => {\n      // Skip if it looks like a Hash literal rather than a block\n      if (/^\\{\\s*:/.test(match) || /^\\{\\s*['\"]/.test(match)) {\n        return match; // Process as a Hash literal (key-value pairs)\n      }\n\n      const placeholder = `__RUBY_BLOCK_BRACE_${placeholderCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n\n      tokens.push(\"block_brace\");\n\n      // Extract block parameters\n      const paramMatch = match.match(/\\|\\s*([^|]*)\\s*\\|/);\n      if (paramMatch && paramMatch[1]) {\n        const params = paramMatch[1].split(\",\");\n        params.forEach((param) => {\n          tokens.push(param.trim());\n        });\n      }\n\n      // Process the content without parameters\n      let blockContent = match.slice(1, -1); // Remove { and }\n      if (paramMatch) {\n        blockContent = blockContent.replace(/\\|\\s*[^|]*\\s*\\|/, \"\");\n      }\n\n      const contentTokens = tokenizeGeneric(blockContent);\n      tokens.push(...contentTokens);\n\n      return placeholder;\n    }\n  );\n\n  // Handle range operators (.., ...)\n  let withRangeOps = withoutBlocks.replace(/\\.\\.(\\.)?/g, (match) => {\n    tokens.push(\n      match === \"..\" ? \"range_operator_inclusive\" : \"range_operator_exclusive\"\n    );\n    return \" \" + match + \" \"; // Space-padded for tokenization\n  });\n\n  // Handle Ruby method definition with symbols\n  withRangeOps = withRangeOps.replace(\n    /\\bdef\\s+(?:self\\.)?([a-zA-Z_][a-zA-Z0-9_]*[?!=]?)/g,\n    (match, methodName) => {\n      tokens.push(\"method_definition\");\n      tokens.push(methodName);\n\n      // Add method name without special character suffix\n      if (\n        methodName.endsWith(\"?\") ||\n        methodName.endsWith(\"!\") ||\n        methodName.endsWith(\"=\")\n      ) {\n        tokens.push(methodName.slice(0, -1));\n      }\n\n      return match;\n    }\n  );\n\n  // Handle class and module definitions\n  withRangeOps = withRangeOps.replace(\n    /\\b(?:class|module)\\s+([A-Z][a-zA-Z0-9_]*(?:::[A-Z][a-zA-Z0-9_]*)*)/g,\n    (match, className) => {\n      tokens.push(\n        match.startsWith(\"class\") ? \"class_definition\" : \"module_definition\"\n      );\n\n      // Add class/module name\n      tokens.push(className);\n\n      // Add namespace components\n      if (className.includes(\"::\")) {\n        const parts = className.split(\"::\");\n        tokens.push(...parts);\n      }\n\n      return match;\n    }\n  );\n\n  // Tokenize what's left with generic tokenization\n  const genericTokens = tokenizeGeneric(withRangeOps);\n\n  // Add common Ruby keywords if present\n  const rubyKeywords = [\n    \"if\",\n    \"unless\",\n    \"else\",\n    \"elsif\",\n    \"end\",\n    \"begin\",\n    \"rescue\",\n    \"ensure\",\n    \"while\",\n    \"until\",\n    \"for\",\n    \"break\",\n    \"next\",\n    \"redo\",\n    \"retry\",\n    \"return\",\n    \"super\",\n    \"self\",\n    \"nil\",\n    \"true\",\n    \"false\",\n    \"and\",\n    \"or\",\n    \"not\",\n    \"yield\",\n  ];\n\n  for (const keyword of rubyKeywords) {\n    const regex = new RegExp(`\\\\b${keyword}\\\\b`, \"g\");\n    if (regex.test(withRangeOps)) {\n      tokens.push(keyword);\n    }\n  }\n\n  tokens.push(...genericTokens);\n\n  // Process tokens for Ruby method calling convention\n  const processedTokens = [];\n  for (const token of tokens) {\n    // Skip placeholder tokens\n    if (token.startsWith(\"__RUBY_\")) {\n      processedTokens.push(token);\n      continue;\n    }\n\n    processedTokens.push(token);\n\n    // Also add version without trailing ? or !\n    if (token.endsWith(\"?\") || token.endsWith(\"!\")) {\n      processedTokens.push(token.slice(0, -1));\n    }\n\n    // Also add version without = for attribute setters\n    if (\n      token.endsWith(\"=\") &&\n      ![\"==\", \"!=\", \">=\", \"<=\", \"=>\"].includes(token)\n    ) {\n      processedTokens.push(token.slice(0, -1));\n    }\n  }\n\n  // Replace placeholders with their original values and extract content\n  const finalTokens = [];\n  for (const token of processedTokens) {\n    if (stringPlaceholders[token]) {\n      // Categorize by token type\n      if (\n        token.startsWith(\"__RUBY_STRING_\") ||\n        token.startsWith(\"__RUBY_INTERPOLATED_STRING_\")\n      ) {\n        finalTokens.push(\"string_literal\");\n\n        // Extract and tokenize string content\n        const content = stringPlaceholders[token];\n        let strContent = content;\n\n        // Remove quotes\n        if (strContent.startsWith(\"'\") && strContent.endsWith(\"'\")) {\n          strContent = strContent.slice(1, -1);\n        } else if (strContent.startsWith('\"') && strContent.endsWith('\"')) {\n          strContent = strContent.slice(1, -1);\n        } else if (strContent.startsWith(\"%q\") || strContent.startsWith(\"%Q\")) {\n          // Handle %q/%Q strings\n          strContent = strContent.slice(3, -1);\n        }\n\n        // Remove interpolation markers\n        strContent = strContent.replace(/#\\{[^}]*\\}/g, \" \");\n\n        // Tokenize content if not empty\n        if (strContent.trim()) {\n          const contentTokens = tokenizeGeneric(strContent);\n          finalTokens.push(...contentTokens);\n        }\n      } else if (token.startsWith(\"__RUBY_SYMBOL_\")) {\n        finalTokens.push(\"symbol\");\n      } else if (token.startsWith(\"__RUBY_BLOCK_\")) {\n        finalTokens.push(\"block\");\n      } else if (token.startsWith(\"__RUBY_REGEXP_\")) {\n        finalTokens.push(\"regexp\");\n      } else {\n        finalTokens.push(token);\n      }\n    } else if (commentPlaceholders[token]) {\n      // Extract useful keywords from comments\n      finalTokens.push(\"code_comment\");\n\n      // Extract possible important terms from comments\n      const commentContent = commentPlaceholders[token]\n        .replace(/^#/, \"\") // Remove # for line comments\n        .replace(/^=begin\\s*|\\s*=end$/g, \"\"); // Remove =begin/=end for block comments\n\n      // Only use alphanumeric words from comments, skip punctuation and symbols\n      const commentTokens = commentContent\n        .split(/\\s+/)\n        .filter((word) => /^[a-z0-9_]{3,}$/i.test(word))\n        .map((word) => word.toLowerCase());\n\n      finalTokens.push(...commentTokens);\n    } else {\n      finalTokens.push(token);\n    }\n  }\n\n  return [...new Set(finalTokens)]; // Remove duplicates\n}\n\n/**\n * Go-specific tokenization\n * Handles struct tags, goroutines, interfaces, and Go-specific operators\n *\n * @param {string} text - The Go text to tokenize\n * @returns {string[]} An array of tokens\n */\nfunction tokenizeGo(text) {\n  let tokens = [];\n\n  // Preserve comments for content analysis but mark them specially\n  const commentPlaceholders = {};\n  let commentCounter = 0;\n\n  // Remove block comments first\n  const withoutBlockComments = text.replace(/\\/\\*[\\s\\S]*?\\*\\//g, (match) => {\n    const placeholder = `__GO_COMMENT_BLOCK_${commentCounter++}__`;\n    commentPlaceholders[placeholder] = match;\n    return placeholder;\n  });\n\n  // Remove line comments\n  const withoutComments = withoutBlockComments.replace(\n    /\\/\\/[^\\n]*/g,\n    (match) => {\n      const placeholder = `__GO_COMMENT_LINE_${commentCounter++}__`;\n      commentPlaceholders[placeholder] = match;\n      return placeholder;\n    }\n  );\n\n  // Handle string literals and placeholders\n  const stringPlaceholders = {};\n  let placeholderCounter = 0;\n\n  // Handle raw string literals with backticks\n  const withoutRawStrings = withoutComments.replace(/`[^`]*`/g, (match) => {\n    const placeholder = `__GO_RAW_STRING_${placeholderCounter++}__`;\n    stringPlaceholders[placeholder] = match;\n    return placeholder;\n  });\n\n  // Handle regular string literals\n  const withoutStrings = withoutRawStrings.replace(\n    /\"(?:[^\"\\\\]|\\\\.)*\"/g,\n    (match) => {\n      const placeholder = `__GO_STRING_${placeholderCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n      return placeholder;\n    }\n  );\n\n  // Handle rune literals\n  const withoutRunes = withoutStrings.replace(/'(?:[^'\\\\]|\\\\.)*'/g, (match) => {\n    const placeholder = `__GO_RUNE_${placeholderCounter++}__`;\n    stringPlaceholders[placeholder] = match;\n    return placeholder;\n  });\n\n  // Handle struct tags in field definitions\n  // These are special string literals used for annotations in struct fields\n  const withoutStructTags = withoutRunes.replace(\n    /`(?:[a-zA-Z0-9_]+:\"[^\"]*\")+`/g,\n    (match) => {\n      const placeholder = `__GO_STRUCT_TAG_${placeholderCounter++}__`;\n      stringPlaceholders[placeholder] = match;\n\n      // Process struct tag content to extract key information\n      tokens.push(\"struct_tag\");\n\n      // Extract tag keys and values\n      const tagPairs = match.slice(1, -1).split(\" \"); // Remove backticks and split by space\n      for (const pair of tagPairs) {\n        if (!pair.trim()) continue;\n\n        // Split by colon and extract key/value\n        const [key, quotedValue] = pair.split(\":\");\n        if (key && quotedValue) {\n          tokens.push(`tag_${key}`);\n\n          // Extract value without quotes\n          const value = quotedValue.replace(/^\"|\"$/g, \"\");\n          if (value) {\n            // If it's a comma-separated list, add each part\n            if (value.includes(\",\")) {\n              const valueParts = value.split(\",\");\n              tokens.push(...valueParts);\n            } else {\n              tokens.push(value);\n            }\n          }\n        }\n      }\n\n      return placeholder;\n    }\n  );\n\n  // Handle Go channel operations (<-, ->)\n  const withoutChannelOps = withoutStructTags.replace(/<-/g, (match) => {\n    tokens.push(\"channel_operation\");\n    return \" <- \"; // Space-separated for tokenization\n  });\n\n  // Handle goroutines (go keyword followed by function call or func literal)\n  const withoutGoroutines = withoutChannelOps.replace(\n    /\\bgo\\s+(?:func\\b|[a-zA-Z_][a-zA-Z0-9_]*\\s*\\()/g,\n    (match) => {\n      tokens.push(\"goroutine\");\n\n      // Extract function name if it's a function call\n      const funcCallMatch = match.match(/go\\s+([a-zA-Z_][a-zA-Z0-9_]*)/);\n      if (funcCallMatch && funcCallMatch[1]) {\n        tokens.push(funcCallMatch[1]);\n      }\n\n      return match;\n    }\n  );\n\n  // Handle select statement with cases\n  const withoutSelect = withoutGoroutines.replace(\n    /\\bselect\\s*{[\\s\\S]*?}/g,\n    (match) => {\n      tokens.push(\"select_statement\");\n\n      // Extract cases\n      const cases = match.match(/case\\s+[^:]+:/g);\n      if (cases) {\n        for (const caseStr of cases) {\n          // Tokenize case content\n          const caseContent = caseStr.slice(4, -1).trim(); // Remove \"case\" and \":\"\n          const caseTokens = tokenizeGeneric(caseContent);\n          tokens.push(...caseTokens);\n        }\n      }\n\n      return match;\n    }\n  );\n\n  // Handle defer statements\n  const withoutDefer = withoutSelect.replace(\n    /\\bdefer\\s+[a-zA-Z_][a-zA-Z0-9_]*\\s*\\(/g,\n    (match) => {\n      tokens.push(\"defer\");\n\n      // Extract function name\n      const funcMatch = match.match(/defer\\s+([a-zA-Z_][a-zA-Z0-9_]*)/);\n      if (funcMatch && funcMatch[1]) {\n        tokens.push(funcMatch[1]);\n      }\n\n      return match;\n    }\n  );\n\n  // Handle type declarations with interfaces and structs\n  const withoutTypeDecls = withoutDefer.replace(\n    /\\btype\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s+(?:struct|interface)\\s*{[\\s\\S]*?}/g,\n    (match, typeName) => {\n      tokens.push(\"type_declaration\");\n      tokens.push(typeName);\n\n      // Check if it's a struct or interface\n      if (match.includes(\"struct\")) {\n        tokens.push(\"struct_type\");\n\n        // Extract field names and types\n        const fieldMatches = match.match(\n          /([a-zA-Z_][a-zA-Z0-9_]*)\\s+([a-zA-Z_][a-zA-Z0-9_.*[\\]]*)/g\n        );\n        if (fieldMatches) {\n          for (const fieldMatch of fieldMatches) {\n            const parts = fieldMatch.trim().split(/\\s+/);\n            if (parts.length >= 2) {\n              tokens.push(parts[0]); // Field name\n              tokens.push(parts[1]); // Field type\n            }\n          }\n        }\n      } else if (match.includes(\"interface\")) {\n        tokens.push(\"interface_type\");\n\n        // Extract method signatures\n        const methodMatches = match.match(\n          /([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\([\\s\\S]*?\\)(?:\\s*\\([\\s\\S]*?\\))?\\s*[,{]/g\n        );\n        if (methodMatches) {\n          for (const methodMatch of methodMatches) {\n            const methodName = methodMatch.match(/([a-zA-Z_][a-zA-Z0-9_]*)/);\n            if (methodName && methodName[1]) {\n              tokens.push(methodName[1]);\n            }\n          }\n        }\n      }\n\n      return match;\n    }\n  );\n\n  // Handle Go-specific builtins\n  let withBuiltins = withoutTypeDecls;\n  const goBuiltins = [\n    \"make\",\n    \"new\",\n    \"len\",\n    \"cap\",\n    \"append\",\n    \"copy\",\n    \"delete\",\n    \"close\",\n    \"complex\",\n    \"real\",\n    \"imag\",\n    \"panic\",\n    \"recover\",\n  ];\n\n  for (const builtin of goBuiltins) {\n    const regex = new RegExp(`\\\\b${builtin}\\\\s*\\\\(`, \"g\");\n    withBuiltins = withBuiltins.replace(regex, (match) => {\n      tokens.push(`builtin_${builtin}`);\n      return match;\n    });\n  }\n\n  // Add Go keywords and common patterns\n  const goKeywords = [\n    \"package\",\n    \"import\",\n    \"func\",\n    \"return\",\n    \"var\",\n    \"const\",\n    \"type\",\n    \"struct\",\n    \"interface\",\n    \"map\",\n    \"chan\",\n    \"go\",\n    \"select\",\n    \"case\",\n    \"default\",\n    \"defer\",\n    \"if\",\n    \"else\",\n    \"switch\",\n    \"for\",\n    \"range\",\n    \"continue\",\n    \"break\",\n    \"fallthrough\",\n    \"goto\",\n    \"nil\",\n    \"iota\",\n    \"true\",\n    \"false\",\n  ];\n\n  for (const keyword of goKeywords) {\n    const regex = new RegExp(`\\\\b${keyword}\\\\b`, \"g\");\n    if (regex.test(withBuiltins)) {\n      tokens.push(keyword);\n    }\n  }\n\n  // Process the remaining text with generic tokenization\n  const genericTokens = tokenizeGeneric(withBuiltins);\n  tokens.push(...genericTokens);\n\n  // Handle camelCase for method names which is common in Go\n  const processedTokens = [];\n  for (const token of tokens) {\n    // Skip placeholders\n    if (token.startsWith(\"__GO_\")) {\n      processedTokens.push(token);\n      continue;\n    }\n\n    processedTokens.push(token);\n\n    // Split camelCase\n    if (/[a-z][A-Z]/.test(token)) {\n      const parts = token\n        .replace(/([a-z])([A-Z])/g, \"$1 $2\")\n        .toLowerCase()\n        .split(\" \");\n      if (parts.length > 1) {\n        processedTokens.push(...parts);\n      }\n    }\n  }\n\n  // Replace placeholders with their original values and process content\n  const finalTokens = [];\n  for (const token of processedTokens) {\n    if (stringPlaceholders[token]) {\n      if (token.startsWith(\"__GO_STRING_\")) {\n        finalTokens.push(\"string_literal\");\n\n        // Extract and tokenize string content\n        const content = stringPlaceholders[token];\n        // Remove quotes and tokenize content\n        const strContent = content.slice(1, -1);\n\n        // Only tokenize non-empty content\n        if (strContent.trim().length > 0) {\n          const contentTokens = tokenizeGeneric(strContent);\n          finalTokens.push(...contentTokens);\n        }\n      } else if (token.startsWith(\"__GO_RAW_STRING_\")) {\n        finalTokens.push(\"raw_string_literal\");\n\n        // Extract content from raw string\n        const content = stringPlaceholders[token];\n        // Remove backticks\n        const rawContent = content.slice(1, -1);\n\n        // Handle multiline raw strings specially\n        if (rawContent.includes(\"\\n\")) {\n          // Process each line separately\n          const lines = rawContent.split(\"\\n\");\n          for (const line of lines) {\n            if (line.trim()) {\n              const lineTokens = tokenizeGeneric(line.trim());\n              finalTokens.push(...lineTokens);\n            }\n          }\n        } else if (rawContent.trim()) {\n          const contentTokens = tokenizeGeneric(rawContent);\n          finalTokens.push(...contentTokens);\n        }\n      } else if (token.startsWith(\"__GO_STRUCT_TAG_\")) {\n        finalTokens.push(\"struct_tag\");\n      } else if (token.startsWith(\"__GO_RUNE_\")) {\n        finalTokens.push(\"rune_literal\");\n      } else {\n        finalTokens.push(token);\n      }\n    } else if (commentPlaceholders[token]) {\n      // Extract useful keywords from comments\n      finalTokens.push(\"code_comment\");\n\n      // Extract possible important terms from comments\n      const commentContent = commentPlaceholders[token]\n        .replace(/^\\/\\*|\\*\\/$/g, \"\") // Remove /* */\n        .replace(/^\\/\\//g, \"\"); // Remove //\n\n      // Only use alphanumeric words from comments, skip punctuation and symbols\n      const commentTokens = commentContent\n        .split(/\\s+/)\n        .filter((word) => /^[a-z0-9_]{3,}$/i.test(word))\n        .map((word) => word.toLowerCase());\n\n      finalTokens.push(...commentTokens);\n    } else {\n      finalTokens.push(token);\n    }\n  }\n\n  return [...new Set(finalTokens)]; // Remove duplicates\n}\n\n/**\n * Simple word stemming function that handles common suffixes\n *\n * @param {string} word - The word to stem\n * @returns {string} The stemmed word\n */\nexport function stem(word) {\n  // Make sure input is a string and lowercase\n  if (typeof word !== \"string\") return \"\";\n  const lowerWord = word.toLowerCase();\n\n  // Handle empty strings\n  if (lowerWord.length <= 2) return lowerWord;\n\n  // Simple suffix removal rules\n  if (lowerWord.endsWith(\"ing\")) {\n    // ending -> end, running -> run\n    const stemmed = lowerWord.slice(0, -3);\n    if (stemmed.length > 2) return stemmed;\n    return lowerWord;\n  }\n\n  if (lowerWord.endsWith(\"ed\")) {\n    // ended -> end, created -> creat\n    const stemmed = lowerWord.slice(0, -2);\n    if (stemmed.length > 2) return stemmed;\n    return lowerWord;\n  }\n\n  if (lowerWord.endsWith(\"s\") && !lowerWord.endsWith(\"ss\")) {\n    // files -> file, classes -> class\n    return lowerWord.slice(0, -1);\n  }\n\n  if (lowerWord.endsWith(\"es\")) {\n    // classes -> class, boxes -> box\n    return lowerWord.slice(0, -2);\n  }\n\n  if (lowerWord.endsWith(\"ly\")) {\n    // quickly -> quick\n    return lowerWord.slice(0, -2);\n  }\n\n  if (lowerWord.endsWith(\"er\")) {\n    // faster -> fast\n    return lowerWord.slice(0, -2);\n  }\n\n  // Default: return word as is\n  return lowerWord;\n}\n", "/**\n * RelationshipContextManagerLogic.js\n *\n * Provides functions for managing relationships between code entities.\n */\n\nimport { v4 as uuidv4 } from \"uuid\";\nimport { executeQuery } from \"../db.js\";\n\n/**\n * Adds a relationship between two code entities\n *\n * @param {string} sourceEntityId - ID of the source entity\n * @param {string} targetEntityId - ID of the target entity\n * @param {string} relationshipType - Type of relationship (e.g., 'calls', 'imports', 'extends')\n * @param {number} weight - Weight of the relationship (default: 1.0)\n * @param {object} metadata - Additional metadata about the relationship\n * @returns {Promise<void>}\n */\nexport async function addRelationship(\n  sourceEntityId,\n  targetEntityId,\n  relationshipType,\n  weight = 1.0,\n  metadata = {}\n) {\n  // Validate required parameters\n  if (!sourceEntityId || !targetEntityId || !relationshipType) {\n    throw new Error(\n      \"Source entity ID, target entity ID, and relationship type are required\"\n    );\n  }\n\n  // Generate a new UUID for the relationship\n  const relationshipId = uuidv4();\n\n  // Convert metadata object to JSON string\n  const metadataJson = JSON.stringify(metadata);\n\n  try {\n    // Insert the relationship into the database\n    const query = `\n      INSERT INTO code_relationships (\n        relationship_id, source_entity_id, target_entity_id, relationship_type, weight, metadata\n      ) VALUES (?, ?, ?, ?, ?, ?)\n    `;\n\n    await executeQuery(query, [\n      relationshipId,\n      sourceEntityId,\n      targetEntityId,\n      relationshipType,\n      weight,\n      metadataJson,\n    ]);\n  } catch (error) {\n    // Check if error is due to unique constraint violation\n    if (error.message && error.message.includes(\"UNIQUE constraint failed\")) {\n      // If duplicate, we'll update the existing relationship\n      const updateQuery = `\n        UPDATE code_relationships \n        SET weight = ?, metadata = ? \n        WHERE source_entity_id = ? AND target_entity_id = ? AND relationship_type = ?\n      `;\n\n      await executeQuery(updateQuery, [\n        weight,\n        metadataJson,\n        sourceEntityId,\n        targetEntityId,\n        relationshipType,\n      ]);\n    } else {\n      // For other errors, rethrow\n      console.error(\n        `Error adding relationship between ${sourceEntityId} and ${targetEntityId}:`,\n        error\n      );\n      throw error;\n    }\n  }\n}\n\n/**\n * Relationship type definition matching code_relationships table structure\n * @typedef {Object} Relationship\n * @property {string} relationship_id - Unique identifier for the relationship\n * @property {string} source_entity_id - ID of the source entity\n * @property {string} target_entity_id - ID of the target entity\n * @property {string} relationship_type - Type of relationship\n * @property {number} weight - Weight of the relationship\n * @property {Object} metadata - Additional metadata about the relationship\n */\n\n/**\n * Gets relationships for a specific entity\n *\n * @param {string} entityId - ID of the entity to get relationships for\n * @param {string} direction - Direction of relationships to get ('outgoing', 'incoming', or 'both')\n * @param {string[]} types - Types of relationships to filter by (empty array for all types)\n * @returns {Promise<Relationship[]>} Array of relationship objects\n */\nexport async function getRelationships(\n  entityId,\n  direction = \"outgoing\",\n  types = []\n) {\n  // Validate required parameters\n  if (!entityId) {\n    throw new Error(\"Entity ID is required\");\n  }\n\n  // Validate direction parameter\n  if (![\"outgoing\", \"incoming\", \"both\"].includes(direction)) {\n    throw new Error(\"Direction must be 'outgoing', 'incoming', or 'both'\");\n  }\n\n  // Build the base query\n  let query = `\n    SELECT \n      relationship_id, \n      source_entity_id, \n      target_entity_id, \n      relationship_type, \n      weight, \n      metadata\n    FROM code_relationships\n    WHERE \n  `;\n\n  const queryParams = [];\n\n  // Add direction-specific conditions\n  if (direction === \"outgoing\") {\n    query += \"source_entity_id = ?\";\n    queryParams.push(entityId);\n  } else if (direction === \"incoming\") {\n    query += \"target_entity_id = ?\";\n    queryParams.push(entityId);\n  } else {\n    // direction === \"both\"\n    query += \"(source_entity_id = ? OR target_entity_id = ?)\";\n    queryParams.push(entityId, entityId);\n  }\n\n  // Add relationship type filter if provided\n  if (types.length > 0) {\n    // Create placeholders for the IN clause\n    const typePlaceholders = types.map(() => \"?\").join(\", \");\n    query += ` AND relationship_type IN (${typePlaceholders})`;\n    queryParams.push(...types);\n  }\n\n  try {\n    // Execute the query\n    const relationships = await executeQuery(query, queryParams);\n\n    // Process metadata for each relationship\n    return relationships.map((relationship) => ({\n      ...relationship,\n      // Parse metadata JSON string to object, default to empty object if null or invalid\n      metadata: relationship.metadata ? JSON.parse(relationship.metadata) : {},\n    }));\n  } catch (error) {\n    console.error(`Error getting relationships for entity ${entityId}:`, error);\n    throw error;\n  }\n}\n\n/**\n * GraphSnippet type definition for call graph data\n * @typedef {Object} GraphSnippet\n * @property {Array<{id: string, name: string, type: string}>} nodes - Entities in the graph\n * @property {Array<{source: string, target: string, type: string}>} edges - Relationships between entities\n */\n\n/**\n * Builds a call graph snippet starting from a function entity\n *\n * @param {string} functionEntityId - ID of the function entity to start from\n * @param {number} depth - Maximum depth of the call graph (default: 2)\n * @returns {Promise<GraphSnippet>} Call graph snippet with nodes and edges\n */\nexport async function buildCallGraphSnippet(functionEntityId, depth = 2) {\n  // Validate required parameters\n  if (!functionEntityId) {\n    throw new Error(\"Function entity ID is required\");\n  }\n\n  // Validate depth\n  if (depth < 1) {\n    throw new Error(\"Depth must be at least 1\");\n  }\n\n  try {\n    // Use a recursive Common Table Expression (CTE) to get function calls up to specified depth\n    const outgoingCallsQuery = `\n      WITH RECURSIVE call_graph AS (\n        -- Base case: start with the source function\n        SELECT \n          cr.source_entity_id, \n          cr.target_entity_id, \n          cr.relationship_type,\n          0 AS depth\n        FROM code_relationships cr\n        WHERE cr.source_entity_id = ? \n          AND cr.relationship_type = 'calls'\n        \n        UNION ALL\n        \n        -- Recursive case: find further calls up to max depth\n        SELECT \n          cr.source_entity_id, \n          cr.target_entity_id, \n          cr.relationship_type,\n          cg.depth + 1 AS depth\n        FROM code_relationships cr\n        JOIN call_graph cg ON cr.source_entity_id = cg.target_entity_id\n        WHERE cr.relationship_type = 'calls'\n          AND cg.depth < ?\n      )\n      SELECT DISTINCT source_entity_id, target_entity_id, relationship_type, depth\n      FROM call_graph\n      ORDER BY depth\n    `;\n\n    const outgoingCalls = await executeQuery(outgoingCallsQuery, [\n      functionEntityId,\n      depth - 1,\n    ]);\n\n    // Get incoming calls (functions that call our target function)\n    const incomingCallsQuery = `\n      SELECT \n        cr.source_entity_id, \n        cr.target_entity_id, \n        cr.relationship_type,\n        0 AS depth\n      FROM code_relationships cr\n      WHERE cr.target_entity_id = ? \n        AND cr.relationship_type = 'calls'\n    `;\n\n    const incomingCalls = await executeQuery(incomingCallsQuery, [\n      functionEntityId,\n    ]);\n\n    // Combine outgoing and incoming calls\n    const allCalls = [...outgoingCalls, ...incomingCalls];\n\n    // Extract all unique entity IDs involved\n    const entityIds = new Set();\n    entityIds.add(functionEntityId); // Add the root function\n\n    allCalls.forEach((call) => {\n      entityIds.add(call.source_entity_id);\n      entityIds.add(call.target_entity_id);\n    });\n\n    // Get entity details for all involved entities\n    const entityIdsArray = Array.from(entityIds);\n    const placeholders = entityIdsArray.map(() => \"?\").join(\",\");\n\n    const entitiesQuery = `\n      SELECT \n        id, \n        name, \n        type\n      FROM code_entities\n      WHERE id IN (${placeholders})\n    `;\n\n    const entities = await executeQuery(entitiesQuery, entityIdsArray);\n\n    // Build the graph nodes\n    const nodes = entities.map((entity) => ({\n      id: entity.id,\n      name: entity.name,\n      type: entity.type,\n    }));\n\n    // Build the graph edges\n    const edges = allCalls.map((call) => ({\n      source: call.source_entity_id,\n      target: call.target_entity_id,\n      type: call.relationship_type,\n    }));\n\n    // Return the call graph snippet\n    return {\n      nodes,\n      edges,\n    };\n  } catch (error) {\n    console.error(\n      `Error building call graph for function ${functionEntityId}:`,\n      error\n    );\n    throw error;\n  }\n}\n\n/**\n * Path type definition for code paths\n * @typedef {string[]} Path - An array of entity IDs representing a path\n */\n\n/**\n * Finds all paths between two entities with a specific relationship type\n *\n * @param {string} startEntityId - ID of the starting entity\n * @param {string} endEntityId - ID of the ending entity\n * @param {string} relationshipType - Type of relationship to follow\n * @returns {Promise<Path[]>} Array of paths (each path is an array of entity IDs)\n */\nexport async function findCodePaths(\n  startEntityId,\n  endEntityId,\n  relationshipType\n) {\n  // Validate required parameters\n  if (!startEntityId || !endEntityId || !relationshipType) {\n    throw new Error(\n      \"Start entity ID, end entity ID, and relationship type are required\"\n    );\n  }\n\n  try {\n    // Use a recursive CTE to find all paths\n    const query = `\n      WITH RECURSIVE paths(path, current_id, visited) AS (\n        -- Base case: start with the starting entity\n        SELECT \n          startEntityId || '', -- Initialize path with just the start entity\n          startEntityId,\n          startEntityId -- Initialize visited set with start entity\n        FROM (SELECT ? AS startEntityId)\n        \n        UNION ALL\n        \n        -- Recursive case: extend paths that haven't reached the end entity\n        SELECT\n          paths.path || ',' || cr.target_entity_id, -- Append target to path\n          cr.target_entity_id, -- New current entity is the target\n          paths.visited || ',' || cr.target_entity_id -- Update visited set\n        FROM\n          code_relationships cr\n        JOIN\n          paths ON cr.source_entity_id = paths.current_id\n        WHERE\n          cr.relationship_type = ?\n          AND cr.target_entity_id != paths.startEntityId -- Avoid immediate cycles back to start\n          AND paths.visited NOT LIKE '%,' || cr.target_entity_id || ',%' -- Check for cycles\n          AND paths.visited NOT LIKE cr.target_entity_id || ',%' -- Check for cycles at start\n          AND paths.visited NOT LIKE '%,' || cr.target_entity_id -- Check for cycles at end\n      )\n      -- Select paths that end at the target entity\n      SELECT path\n      FROM paths\n      WHERE current_id = ?\n    `;\n\n    const results = await executeQuery(query, [\n      startEntityId,\n      relationshipType,\n      endEntityId,\n    ]);\n\n    // Process the results into an array of paths\n    return results.map((row) => {\n      // Split the path string into an array of entity IDs\n      return row.path.split(\",\");\n    });\n  } catch (error) {\n    console.error(\n      `Error finding paths between ${startEntityId} and ${endEntityId}:`,\n      error\n    );\n\n    // SQLite might not fully support the recursive CTE with the cycle detection as written\n    // If we get an error, let's use a more basic approach that has limited depth\n\n    try {\n      // Fallback to a simpler implementation with finite depth\n      const maxDepth = 10; // Reasonable limit to prevent excessive path lengths\n\n      const fallbackQuery = `\n        WITH RECURSIVE paths(path, current_id, depth) AS (\n          -- Base case: start with the starting entity\n          SELECT \n            ? AS path,\n            ? AS current_id,\n            0 AS depth\n          \n          UNION ALL\n          \n          -- Recursive case: extend paths that haven't reached the end entity\n          SELECT\n            paths.path || ',' || cr.target_entity_id,\n            cr.target_entity_id,\n            paths.depth + 1\n          FROM\n            code_relationships cr\n          JOIN\n            paths ON cr.source_entity_id = paths.current_id\n          WHERE\n            cr.relationship_type = ?\n            AND paths.depth < ?\n            AND paths.path NOT LIKE '%' || cr.target_entity_id || '%' -- Simple cycle check\n        )\n        -- Select paths that end at the target entity\n        SELECT path\n        FROM paths\n        WHERE current_id = ?\n      `;\n\n      const fallbackResults = await executeQuery(fallbackQuery, [\n        startEntityId,\n        startEntityId,\n        relationshipType,\n        maxDepth,\n        endEntityId,\n      ]);\n\n      // Process the fallback results\n      return fallbackResults.map((row) => {\n        return row.path.split(\",\");\n      });\n    } catch (fallbackError) {\n      console.error(\n        \"Fallback path finding approach also failed:\",\n        fallbackError\n      );\n\n      // If all else fails, return an empty array\n      return [];\n    }\n  }\n}\n\n/**\n * Gets entities related to a given entity\n *\n * @param {string} entityId - ID of the entity to get related entities for\n * @param {string[]} [relationshipTypes=[]] - Types of relationships to filter by (empty array for all types)\n * @param {number} [maxResults=20] - Maximum number of results to return\n * @returns {Promise<string[]>} Array of related entity IDs\n */\nexport async function getRelatedEntities(\n  entityId,\n  relationshipTypes = [],\n  maxResults = 20\n) {\n  // Validate required parameters\n  if (!entityId) {\n    throw new Error(\"Entity ID is required\");\n  }\n\n  try {\n    // Get both incoming and outgoing relationships\n    const relationships = await getRelationships(\n      entityId,\n      \"both\",\n      relationshipTypes\n    );\n\n    // Extract unique entity IDs from relationships\n    const relatedEntityIds = new Set();\n\n    for (const relationship of relationships) {\n      if (relationship.source_entity_id === entityId) {\n        relatedEntityIds.add(relationship.target_entity_id);\n      } else {\n        relatedEntityIds.add(relationship.source_entity_id);\n      }\n\n      // Stop if we've reached the maximum number of results\n      if (relatedEntityIds.size >= maxResults) {\n        break;\n      }\n    }\n\n    return Array.from(relatedEntityIds);\n  } catch (error) {\n    console.error(`Error getting related entities for ${entityId}:`, error);\n    return [];\n  }\n}\n", "/**\n * ContextCompressorLogic.js\n *\n * Logic for compressing and summarizing text content to fit within\n * specific size constraints while preserving important information.\n */\n\nimport { tokenize } from \"./TextTokenizerLogic.js\";\n\n/**\n * @typedef {Object} ScoredSnippet\n * @property {Object} entity - The code entity object\n * @property {number} score - Relevance score\n * @property {string} [content] - Optional pre-provided content\n */\n\n/**\n * @typedef {Object} ProcessedSnippet\n * @property {string} entity_id - ID of the entity\n * @property {string} summarizedContent - Final summarized content\n * @property {number} originalScore - Original relevance score\n */\n\n/**\n * Manage token budget distribution across context snippets\n *\n * @param {ScoredSnippet[]} contextSnippets - Array of scored context snippets\n * @param {number} budget - Total character budget to distribute\n * @param {string[]} [queryKeywords] - Optional query keywords for targeted summarization\n * @returns {ProcessedSnippet[]} Array of processed snippets with summarized content\n */\nexport function manageTokenBudget(contextSnippets, budget, queryKeywords = []) {\n  if (!contextSnippets || contextSnippets.length === 0) {\n    return [];\n  }\n\n  // Initialize result array\n  const processedSnippets = [];\n\n  // Track remaining budget\n  let remainingBudget = budget;\n\n  // Calculate initial budget allocation based on scores\n  const totalScore = contextSnippets.reduce(\n    (sum, snippet) => sum + snippet.score,\n    0\n  );\n  const budgetAllocations = contextSnippets.map((snippet) => {\n    // Allocate budget proportionally to score, with a minimum of 100 chars\n    return Math.max(100, Math.floor((snippet.score / totalScore) * budget));\n  });\n\n  // Process snippets in order of score/relevance (assume they're already sorted)\n  for (let i = 0; i < contextSnippets.length; i++) {\n    const snippet = contextSnippets[i];\n\n    // Get content from snippet, preferring pre-provided content\n    const content = snippet.content || snippet.entity.raw_content || \"\";\n\n    // Skip if no content\n    if (!content) {\n      continue;\n    }\n\n    // Get allocated budget for this snippet\n    let snippetBudget = Math.min(budgetAllocations[i], remainingBudget);\n\n    // If remaining budget is too small, skip this snippet\n    if (snippetBudget < 50) {\n      continue;\n    }\n\n    // Check if content fits within allocated budget\n    if (content.length <= snippetBudget) {\n      // Content fits as-is\n      processedSnippets.push({\n        entity_id: snippet.entity.entity_id,\n        summarizedContent: content,\n        originalScore: snippet.score,\n      });\n\n      remainingBudget -= content.length;\n    } else {\n      // Need to summarize content\n      let summarizedContent;\n\n      // Summarize based on entity type\n      if (snippet.entity.entity_type) {\n        summarizedContent = summarizeCodeEntity(\n          snippet.entity,\n          snippetBudget,\n          queryKeywords\n        );\n      } else {\n        summarizedContent = summarizeText(content, snippetBudget);\n      }\n\n      // Add to processed snippets if summarization succeeded\n      if (summarizedContent) {\n        processedSnippets.push({\n          entity_id: snippet.entity.entity_id,\n          summarizedContent,\n          originalScore: snippet.score,\n        });\n\n        remainingBudget -= summarizedContent.length;\n      }\n    }\n\n    // Stop if budget is exhausted\n    if (remainingBudget <= 50) {\n      break;\n    }\n\n    // Redistribute remaining budget to future snippets\n    if (i < contextSnippets.length - 1) {\n      const remainingSnippets = contextSnippets.length - i - 1;\n      const remainingScores = contextSnippets\n        .slice(i + 1)\n        .reduce((sum, s) => sum + s.score, 0);\n\n      // Recalculate budget allocations for remaining snippets\n      for (let j = i + 1; j < contextSnippets.length; j++) {\n        budgetAllocations[j] = Math.max(\n          100,\n          Math.floor(\n            (contextSnippets[j].score / remainingScores) * remainingBudget\n          )\n        );\n      }\n    }\n  }\n\n  // If we have significant remaining budget and processed snippets,\n  // try to use it to expand summaries\n  if (remainingBudget > 200 && processedSnippets.length > 0) {\n    redistributeRemainingBudget(\n      processedSnippets,\n      contextSnippets,\n      remainingBudget,\n      queryKeywords\n    );\n  }\n\n  return processedSnippets;\n}\n\n/**\n * Redistribute remaining budget to expand summaries\n *\n * @param {ProcessedSnippet[]} processedSnippets - Already processed snippets\n * @param {ScoredSnippet[]} originalSnippets - Original scored snippets\n * @param {number} remainingBudget - Remaining character budget\n * @param {string[]} queryKeywords - Query keywords for summarization\n */\nfunction redistributeRemainingBudget(\n  processedSnippets,\n  originalSnippets,\n  remainingBudget,\n  queryKeywords\n) {\n  // Create a map of processed snippets for quick lookup\n  const processedMap = new Map();\n  processedSnippets.forEach((ps) => {\n    processedMap.set(ps.entity_id, ps);\n  });\n\n  // Filter original snippets to only include those that were processed\n  // and sort by score (highest first)\n  const snippetsToExpand = originalSnippets\n    .filter((s) => processedMap.has(s.entity.entity_id))\n    .sort((a, b) => b.score - a.score);\n\n  // Calculate additional budget per snippet\n  const additionalBudgetPerSnippet = Math.floor(\n    remainingBudget / snippetsToExpand.length\n  );\n\n  // Expand each snippet with additional budget\n  for (const snippet of snippetsToExpand) {\n    const processedSnippet = processedMap.get(snippet.entity.entity_id);\n    const currentLength = processedSnippet.summarizedContent.length;\n    const newBudget = currentLength + additionalBudgetPerSnippet;\n\n    // Get content from snippet\n    const content = snippet.content || snippet.entity.raw_content || \"\";\n\n    // If original content fits in new budget, use it\n    if (content.length <= newBudget) {\n      processedSnippet.summarizedContent = content;\n      remainingBudget -= content.length - currentLength;\n    } else {\n      // Otherwise, re-summarize with expanded budget\n      let expandedContent;\n\n      if (snippet.entity.entity_type) {\n        expandedContent = summarizeCodeEntity(\n          snippet.entity,\n          newBudget,\n          queryKeywords\n        );\n      } else {\n        expandedContent = summarizeText(content, newBudget);\n      }\n\n      if (expandedContent && expandedContent.length > currentLength) {\n        remainingBudget -= expandedContent.length - currentLength;\n        processedSnippet.summarizedContent = expandedContent;\n      }\n    }\n\n    // Stop if remaining budget gets too small\n    if (remainingBudget < 100) {\n      break;\n    }\n  }\n}\n\n/**\n * Summarize text to fit within a maximum length\n *\n * @param {string} text - The text to summarize\n * @param {number} maxLength - Maximum character length for the summary\n * @param {'rule-based' | 'ml-light'} [method='rule-based'] - Summarization method to use\n * @returns {string} Summarized text\n */\nexport function summarizeText(text, maxLength, method = \"rule-based\") {\n  // Validate inputs\n  if (!text) return \"\";\n  if (text.length <= maxLength) return text;\n\n  // Check method and apply fallback if necessary\n  if (method === \"ml-light\") {\n    console.log(\n      \"ML-light summarization not fully implemented, falling back to rule-based method\"\n    );\n    method = \"rule-based\";\n  }\n\n  // Apply rule-based summarization\n  return ruleBased(text, maxLength);\n}\n\n/**\n * Summarize a code entity based on its type and content\n *\n * @param {Object} entity - Code entity object from code_entities table\n * @param {number} budget - Maximum characters for the summary\n * @param {string[]} [queryKeywords] - Optional keywords to highlight in the summary\n * @returns {string} Summarized entity content\n */\nexport function summarizeCodeEntity(entity, budget, queryKeywords = []) {\n  // Check if entity is valid\n  if (!entity) return \"\";\n\n  // Use existing summary if available and within budget\n  if (entity.summary && entity.summary.length <= budget) {\n    return entity.summary;\n  }\n\n  // If raw content is empty, return entity name\n  if (!entity.raw_content) {\n    return `${entity.name} (${entity.entity_type})`;\n  }\n\n  // If raw content fits within budget, return it directly\n  if (entity.raw_content.length <= budget) {\n    return entity.raw_content;\n  }\n\n  // Generate summary based on entity type\n  const entityType = (entity.entity_type || \"\").toLowerCase();\n\n  switch (entityType) {\n    case \"function\":\n    case \"method\":\n      return summarizeFunction(entity, budget, queryKeywords);\n\n    case \"class\":\n      return summarizeClass(entity, budget, queryKeywords);\n\n    case \"file\":\n      return summarizeFile(entity, budget, queryKeywords);\n\n    default:\n      // For other entity types, use generic text summarization\n      return summarizeText(entity.raw_content, budget);\n  }\n}\n\n/**\n * Summarize a function or method\n *\n * @param {Object} entity - Function entity\n * @param {number} budget - Character budget\n * @param {string[]} queryKeywords - Keywords to prioritize\n * @returns {string} Function summary\n */\nfunction summarizeFunction(entity, budget, queryKeywords) {\n  const content = entity.raw_content;\n  const lines = content.split(\"\\n\");\n\n  // Extract function signature\n  const signatureLine = extractFunctionSignature(lines);\n\n  // If we can only fit the signature, return just that\n  if (signatureLine.length >= budget - 10) {\n    return truncateToMaxLength(signatureLine, budget);\n  }\n\n  // Score lines by importance\n  const scoredLines = scoreCodeLines(lines, queryKeywords, \"function\");\n\n  // Begin with the signature\n  let summary = signatureLine;\n  let remainingBudget = budget - signatureLine.length;\n\n  // Add comment block if it exists\n  const commentBlock = extractCommentBlock(lines);\n  if (commentBlock && commentBlock.length < remainingBudget * 0.4) {\n    summary += \"\\n\" + commentBlock;\n    remainingBudget -= commentBlock.length;\n  }\n\n  // Add important lines\n  summary += \"\\n\" + selectImportantLines(scoredLines, remainingBudget);\n\n  // Ensure we're within budget\n  return truncateToMaxLength(summary, budget);\n}\n\n/**\n * Summarize a class\n *\n * @param {Object} entity - Class entity\n * @param {number} budget - Character budget\n * @param {string[]} queryKeywords - Keywords to prioritize\n * @returns {string} Class summary\n */\nfunction summarizeClass(entity, budget, queryKeywords) {\n  const content = entity.raw_content;\n  const lines = content.split(\"\\n\");\n\n  // Extract class signature and method list\n  const classSignature = extractClassSignature(lines);\n  const methodList = extractMethodList(lines);\n\n  // Start with class signature\n  let summary = classSignature;\n  let remainingBudget = budget - classSignature.length;\n\n  // Add method list if it fits\n  if (methodList && methodList.length < remainingBudget) {\n    summary += \"\\n\" + methodList;\n    remainingBudget -= methodList.length;\n  }\n\n  // If we still have budget, add important lines\n  if (remainingBudget > 50) {\n    const scoredLines = scoreCodeLines(lines, queryKeywords, \"class\");\n    summary += \"\\n\" + selectImportantLines(scoredLines, remainingBudget);\n  }\n\n  return truncateToMaxLength(summary, budget);\n}\n\n/**\n * Summarize a file\n *\n * @param {Object} entity - File entity\n * @param {number} budget - Character budget\n * @param {string[]} queryKeywords - Keywords to prioritize\n * @returns {string} File summary\n */\nfunction summarizeFile(entity, budget, queryKeywords) {\n  const content = entity.raw_content;\n  const lines = content.split(\"\\n\");\n\n  // Check if it's a README or documentation file\n  const isDocFile =\n    (entity.name || \"\").toLowerCase().includes(\"readme\") ||\n    (entity.name || \"\").toLowerCase().includes(\"doc\");\n\n  if (isDocFile) {\n    // For documentation files, use text summarization\n    return summarizeText(content, budget);\n  }\n\n  // Extract import/require statements\n  const importStatements = lines\n    .filter(\n      (line) =>\n        line.trim().startsWith(\"import \") ||\n        line.trim().startsWith(\"require(\") ||\n        line.trim().startsWith(\"from \") ||\n        line.trim().includes(\" from \")\n    )\n    .join(\"\\n\");\n\n  // Extract export statements\n  const exportStatements = lines\n    .filter(\n      (line) =>\n        line.trim().startsWith(\"export \") ||\n        line.trim().startsWith(\"module.exports\")\n    )\n    .join(\"\\n\");\n\n  // Start building summary\n  let summary = `// File: ${entity.name || \"Unnamed\"}\\n`;\n\n  // Add imports if they fit\n  if (importStatements && importStatements.length < budget * 0.3) {\n    summary += `// Imports:\\n${importStatements}\\n`;\n  }\n\n  // Add exports if they fit\n  const remainingAfterImports = budget - summary.length;\n  if (\n    exportStatements &&\n    exportStatements.length < remainingAfterImports * 0.3\n  ) {\n    summary += `// Exports:\\n${exportStatements}\\n`;\n  }\n\n  // Score and add other important lines\n  const remainingBudget = budget - summary.length;\n  if (remainingBudget > 100) {\n    const scoredLines = scoreCodeLines(lines, queryKeywords, \"file\");\n    summary += `// Key sections:\\n${selectImportantLines(\n      scoredLines,\n      remainingBudget\n    )}`;\n  }\n\n  return truncateToMaxLength(summary, budget);\n}\n\n/**\n * Extract function signature from code lines\n *\n * @param {string[]} lines - Code lines\n * @returns {string} Function signature\n */\nfunction extractFunctionSignature(lines) {\n  // Look for function declarations\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (\n      line.match(\n        /^(async\\s+)?(function\\s+\\w+|\\w+\\s*=\\s*(async\\s+)?function|\\w+\\s*:\\s*(async\\s+)?function|const\\s+\\w+\\s*=\\s*(async\\s+)?(\\([^)]*\\)|[^=]*)\\s*=>)/\n      )\n    ) {\n      // Function found, get signature and opening bracket\n      let signature = line;\n\n      // If the line doesn't contain an opening brace, look for it\n      if (!line.includes(\"{\") && !line.includes(\"=>\")) {\n        let j = i + 1;\n        while (j < lines.length && !lines[j].includes(\"{\")) {\n          signature += \" \" + lines[j].trim();\n          j++;\n        }\n        if (j < lines.length) {\n          signature += \" \" + lines[j].trim().split(\"{\")[0] + \"{ ... }\";\n        }\n      } else if (line.includes(\"{\")) {\n        signature = signature.split(\"{\")[0] + \"{ ... }\";\n      } else if (line.includes(\"=>\")) {\n        const arrowParts = signature.split(\"=>\");\n        signature = arrowParts[0] + \"=> { ... }\";\n      }\n\n      return signature;\n    }\n  }\n\n  // If no function signature found, return a placeholder\n  return \"function() { ... }\";\n}\n\n/**\n * Extract class signature from code lines\n *\n * @param {string[]} lines - Code lines\n * @returns {string} Class signature\n */\nfunction extractClassSignature(lines) {\n  // Look for class declarations\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (line.startsWith(\"class \")) {\n      // Class found, get signature and opening bracket\n      let signature = line;\n\n      // If the line doesn't contain an opening brace, look for it\n      if (!line.includes(\"{\")) {\n        let j = i + 1;\n        while (j < lines.length && !lines[j].includes(\"{\")) {\n          signature += \" \" + lines[j].trim();\n          j++;\n        }\n        if (j < lines.length) {\n          signature += \" \" + lines[j].trim().split(\"{\")[0] + \"{ ... }\";\n        }\n      } else {\n        signature = signature.split(\"{\")[0] + \"{ ... }\";\n      }\n\n      return signature;\n    }\n  }\n\n  // If no class signature found, return a placeholder\n  return \"class { ... }\";\n}\n\n/**\n * Extract a list of methods from a class\n *\n * @param {string[]} lines - Code lines\n * @returns {string} Formatted method list\n */\nfunction extractMethodList(lines) {\n  const methods = [];\n\n  // Regex to match method declarations\n  const methodRegex = /^\\s*(async\\s+)?(\\w+)\\s*\\([^)]*\\)/;\n\n  // Skip the first few lines to avoid matching the class declaration\n  const startFromLine = Math.min(5, lines.length);\n\n  for (let i = startFromLine; i < lines.length; i++) {\n    const match = lines[i].match(methodRegex);\n    if (match && !lines[i].trim().startsWith(\"//\")) {\n      methods.push(match[2]); // Push the method name\n    }\n  }\n\n  if (methods.length === 0) {\n    return \"\";\n  }\n\n  return `// Methods: ${methods.join(\", \")}`;\n}\n\n/**\n * Extract comment block from the beginning of code\n *\n * @param {string[]} lines - Code lines\n * @returns {string} Comment block or empty string\n */\nfunction extractCommentBlock(lines) {\n  let inComment = false;\n  let commentLines = [];\n\n  for (let i = 0; i < Math.min(20, lines.length); i++) {\n    const line = lines[i].trim();\n\n    // Check for JSDoc style comment start\n    if (line.startsWith(\"/**\")) {\n      inComment = true;\n      commentLines.push(line);\n      continue;\n    }\n\n    // Continue collecting comment lines\n    if (inComment) {\n      commentLines.push(line);\n      if (line.endsWith(\"*/\")) {\n        break;\n      }\n    }\n\n    // Check for single-line comments at the beginning\n    if (!inComment && commentLines.length === 0 && line.startsWith(\"//\")) {\n      commentLines.push(line);\n    } else if (!inComment && commentLines.length > 0 && line.startsWith(\"//\")) {\n      commentLines.push(line);\n    } else if (!inComment && commentLines.length > 0) {\n      // Stop if we've collected some comments and hit a non-comment line\n      break;\n    }\n  }\n\n  return commentLines.join(\"\\n\");\n}\n\n/**\n * Score code lines based on importance for summarization\n *\n * @param {string[]} lines - Code lines\n * @param {string[]} queryKeywords - Keywords to prioritize\n * @param {string} entityType - Type of entity\n * @returns {Array<{line: string, score: number, index: number}>} Scored lines\n */\nfunction scoreCodeLines(lines, queryKeywords, entityType) {\n  const scoredLines = [];\n\n  // Important patterns to look for in code\n  const importantPatterns = {\n    function: [\n      /\\breturn\\s+/, // Return statements\n      /\\bthrow\\s+/, // Error handling\n      /\\bif\\s*\\(/, // Conditionals\n      /\\bfor\\s*\\(/, // Loops\n      /\\bcatch\\s*\\(/, // Error catching\n      /\\bswitch\\s*\\(/, // Switch statements\n      /\\bconst\\s+\\w+\\s*=/, // Important variable declarations\n      /\\blet\\s+\\w+\\s*=/, // Variable declarations\n      /\\/\\/ [A-Z]/, // Comments that start with capital letters (likely important)\n    ],\n    class: [\n      /\\bconstructor\\s*\\(/, // Constructor\n      /\\bstatic\\s+/, // Static methods/properties\n      /\\bget\\s+\\w+\\s*\\(/, // Getters\n      /\\bset\\s+\\w+\\s*\\(/, // Setters\n      /\\bextends\\s+/, // Inheritance\n      /\\bimplements\\s+/, // Interface implementation\n      /\\breturn\\s+/, // Return statements\n    ],\n    file: [\n      /\\bexport\\s+(default\\s+)?function\\s+/, // Exported functions\n      /\\bexport\\s+(default\\s+)?class\\s+/, // Exported classes\n      /\\bexport\\s+(default\\s+)?const\\s+/, // Exported constants\n      /\\bmodule\\.exports\\s*=/, // CommonJS exports\n      /\\bimport\\s+/, // Imports\n      /\\brequire\\s*\\(/, // Requires\n    ],\n  };\n\n  // Common patterns across all entity types\n  const commonPatterns = [\n    /\\/\\/ TODO:/, // TODOs\n    /\\/\\/ FIXME:/, // FIXMEs\n    /\\/\\/ NOTE:/, // Notes\n    /\\/\\*\\*/, // JSDoc comments\n  ];\n\n  // Get patterns for this entity type\n  const patterns = [\n    ...(importantPatterns[entityType] || []),\n    ...commonPatterns,\n  ];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (!line) continue; // Skip empty lines\n\n    let score = 0;\n\n    // Check for keyword matches\n    if (queryKeywords.length > 0) {\n      const tokens = tokenize(line, { includeIdentifiers: true });\n      const keywordMatches = queryKeywords.filter(\n        (keyword) =>\n          tokens.includes(keyword.toLowerCase()) ||\n          line.toLowerCase().includes(keyword.toLowerCase())\n      );\n\n      score += keywordMatches.length * 3; // High weight for query keywords\n    }\n\n    // Check for important patterns\n    for (const pattern of patterns) {\n      if (pattern.test(line)) {\n        score += 2;\n        break;\n      }\n    }\n\n    // Special score for first 5 and last 5 non-empty lines\n    if (i < 5) {\n      score += 1;\n    }\n\n    // Add a small score for lines with brackets (opening/closing) - structure indicators\n    if (line.includes(\"{\") || line.includes(\"}\")) {\n      score += 0.5;\n    }\n\n    // Push to scored lines\n    scoredLines.push({\n      line,\n      score,\n      index: i,\n    });\n  }\n\n  // Sort by score (highest first)\n  return scoredLines.sort((a, b) => b.score - a.score);\n}\n\n/**\n * Select important lines from scored lines, respecting the budget\n *\n * @param {Array<{line: string, score: number, index: number}>} scoredLines - Lines with scores\n * @param {number} budget - Character budget\n * @returns {string} Selected important lines\n */\nfunction selectImportantLines(scoredLines, budget) {\n  const selectedLines = [];\n  let usedBudget = 0;\n\n  // First, include all lines with a score above 3 (very important)\n  const highScoreLines = scoredLines.filter((item) => item.score >= 3);\n\n  for (const item of highScoreLines) {\n    if (usedBudget + item.line.length + 1 <= budget) {\n      // +1 for newline\n      selectedLines.push(item);\n      usedBudget += item.line.length + 1;\n    }\n  }\n\n  // Then add other lines if we have budget left\n  if (usedBudget < budget) {\n    const remainingLines = scoredLines\n      .filter((item) => item.score < 3)\n      .sort((a, b) => b.score - a.score); // Sort by score\n\n    for (const item of remainingLines) {\n      if (usedBudget + item.line.length + 1 <= budget) {\n        selectedLines.push(item);\n        usedBudget += item.line.length + 1;\n      }\n    }\n  }\n\n  // Sort by original index to maintain code order\n  selectedLines.sort((a, b) => a.index - b.index);\n\n  return selectedLines.map((item) => item.line).join(\"\\n\");\n}\n\n/**\n * Apply rule-based extractive summarization\n *\n * @param {string} text - The text to summarize\n * @param {number} maxLength - Maximum character length for the summary\n * @returns {string} Summarized text\n */\nfunction ruleBased(text, maxLength) {\n  // Split text into sentences\n  const sentences = splitIntoSentences(text);\n\n  // If we have very few sentences, handle specially\n  if (sentences.length <= 3) {\n    // For 1-3 sentences, return as much as fits within maxLength\n    return truncateToMaxLength(text, maxLength);\n  }\n\n  // Score sentences\n  const scoredSentences = sentences.map((sentence, index) => ({\n    text: sentence,\n    score: scoreSentence(sentence, index, sentences.length),\n    index,\n  }));\n\n  // Sort sentences by score (highest first)\n  scoredSentences.sort((a, b) => b.score - a.score);\n\n  // Select sentences to include in summary\n  const selectedSentences = [];\n  let currentLength = 0;\n\n  for (const scored of scoredSentences) {\n    // Check if adding this sentence would exceed maxLength\n    if (currentLength + scored.text.length + 1 <= maxLength) {\n      // +1 for space\n      selectedSentences.push(scored);\n      currentLength += scored.text.length + 1;\n    } else {\n      // If we can't add even the highest-scoring sentence, we need to truncate\n      if (selectedSentences.length === 0) {\n        return truncateToMaxLength(scored.text, maxLength);\n      }\n      // Otherwise, we've selected as many as we can\n      break;\n    }\n  }\n\n  // Sort selected sentences by original position to maintain coherence\n  selectedSentences.sort((a, b) => a.index - b.index);\n\n  // Join selected sentences\n  const summary = selectedSentences.map((s) => s.text).join(\" \");\n\n  // Final check to ensure we're within maxLength\n  return truncateToMaxLength(summary, maxLength);\n}\n\n/**\n * Split text into sentences using regex\n *\n * @param {string} text - Text to split into sentences\n * @returns {string[]} Array of sentences\n */\nfunction splitIntoSentences(text) {\n  // This regex handles common sentence endings (., !, ?)\n  // It tries to handle abbreviations, decimal numbers, etc.\n  const sentenceRegex = /[^.!?]*[.!?](?:\\s|$)/g;\n  const matches = text.match(sentenceRegex);\n\n  if (!matches) {\n    // If no matches (perhaps text doesn't end with punctuation),\n    // return the whole text as one sentence\n    return [text];\n  }\n\n  // Clean up sentences (trim whitespace)\n  return matches.map((s) => s.trim()).filter((s) => s.length > 0);\n}\n\n/**\n * Score a sentence based on heuristics\n *\n * @param {string} sentence - The sentence to score\n * @param {number} index - Index of sentence in original text\n * @param {number} totalSentences - Total number of sentences in text\n * @returns {number} Score for the sentence (higher is more important)\n */\nfunction scoreSentence(sentence, index, totalSentences) {\n  let score = 0;\n\n  // 1. Position score - first and last sentences are often important\n  if (index === 0) {\n    score += 3; // First sentence bonus\n  } else if (index === totalSentences - 1) {\n    score += 2; // Last sentence bonus\n  } else if (index === 1 || index === totalSentences - 2) {\n    score += 1; // Second and second-to-last sentence small bonus\n  }\n\n  // 2. Length score - penalize very short or very long sentences\n  const wordCount = sentence.split(/\\s+/).length;\n  if (wordCount >= 5 && wordCount <= 20) {\n    score += 1; // Ideal length\n  } else if (wordCount < 3 || wordCount > 30) {\n    score -= 1; // Too short or too long\n  }\n\n  // 3. Content score - check for indicators of important content\n  const importantPhrases = [\n    \"key\",\n    \"important\",\n    \"significant\",\n    \"critical\",\n    \"essential\",\n    \"main\",\n    \"primary\",\n    \"crucial\",\n    \"fundamental\",\n    \"vital\",\n    \"result\",\n    \"conclude\",\n    \"summary\",\n    \"therefore\",\n    \"thus\",\n    \"implement\",\n    \"function\",\n    \"method\",\n    \"class\",\n    \"object\",\n    \"return\",\n    \"export\",\n    \"import\",\n    \"require\",\n    \"define\",\n  ];\n\n  const lowerSentence = sentence.toLowerCase();\n\n  for (const phrase of importantPhrases) {\n    if (lowerSentence.includes(phrase)) {\n      score += 1;\n      break; // Only count once for important phrases\n    }\n  }\n\n  // 4. Code indication score - sentences with code patterns are often important\n  if (\n    lowerSentence.includes(\"function\") ||\n    lowerSentence.includes(\"class\") ||\n    lowerSentence.includes(\"=\") ||\n    lowerSentence.includes(\"return\") ||\n    sentence.includes(\"()\") ||\n    sentence.includes(\"{}\") ||\n    sentence.includes(\"[]\")\n  ) {\n    score += 2; // Code-related sentences are important in programming context\n  }\n\n  return score;\n}\n\n/**\n * Truncate text to ensure it doesn't exceed maxLength\n *\n * @param {string} text - Text to truncate\n * @param {number} maxLength - Maximum character length\n * @returns {string} Truncated text\n */\nfunction truncateToMaxLength(text, maxLength) {\n  if (text.length <= maxLength) {\n    return text;\n  }\n\n  // Try to cut at a sentence boundary\n  for (let i = maxLength - 1; i >= 0; i--) {\n    if (text[i] === \".\" || text[i] === \"!\" || text[i] === \"?\") {\n      return text.substring(0, i + 1);\n    }\n  }\n\n  // If no sentence boundary found, cut at a word boundary\n  for (let i = maxLength - 1; i >= 0; i--) {\n    if (text[i] === \" \") {\n      return text.substring(0, i) + \"...\";\n    }\n  }\n\n  // If all else fails, just truncate\n  return text.substring(0, maxLength - 3) + \"...\";\n}\n\n/**\n * Compresses a collection of context items to fit within token budget\n *\n * @param {Array<Object>} contextItems - Array of context items to compress\n * @param {Object} options - Compression options\n * @param {string} [options.detailLevel='medium'] - Detail level: 'high', 'medium', or 'low'\n * @param {number} [options.targetTokens=2000] - Target token count\n * @param {string[]} [options.queryKeywords=[]] - Optional query keywords for summarization\n * @returns {Promise<Array<Object>>} Compressed context items\n */\nexport async function compressContext(contextItems, options = {}) {\n  if (!contextItems || contextItems.length === 0) {\n    return [];\n  }\n\n  const detailLevel = options.detailLevel || \"medium\";\n  const targetTokens = options.targetTokens || 2000;\n  const queryKeywords = options.queryKeywords || [];\n\n  // Estimate average tokens per character for budget calculation\n  // This is a rough approximation (average English word is ~5 chars + 1 for space)\n  const tokensPerChar = 1 / 6;\n\n  // Convert token budget to character budget\n  const charBudget = Math.floor(targetTokens / tokensPerChar);\n\n  // Map context items to the format expected by manageTokenBudget\n  const scoredSnippets = contextItems.map((item) => ({\n    entity: {\n      entity_id: item.entity_id,\n      entity_type: item.type,\n      raw_content: item.content,\n      name: item.name,\n      file_path: item.path,\n    },\n    score: item.relevanceScore || 0.5,\n    content: item.content,\n  }));\n\n  // Apply detail level modifiers to budget\n  let modifiedBudget = charBudget;\n  switch (detailLevel) {\n    case \"high\":\n      // Increase budget by 30% for high detail\n      modifiedBudget = Math.floor(charBudget * 1.3);\n      break;\n    case \"low\":\n      // Decrease budget by 30% for low detail\n      modifiedBudget = Math.floor(charBudget * 0.7);\n      break;\n    default:\n      // Keep original budget for medium detail\n      break;\n  }\n\n  // Process snippets using manageTokenBudget\n  const processedSnippets = manageTokenBudget(\n    scoredSnippets,\n    modifiedBudget,\n    queryKeywords\n  );\n\n  // Transform back to the original format\n  return processedSnippets\n    .map((processed) => {\n      // Find the original item to copy properties from\n      const originalItem = contextItems.find(\n        (item) => item.entity_id === processed.entity_id\n      );\n      if (!originalItem) return null;\n\n      return {\n        ...originalItem,\n        content: processed.summarizedContent,\n        // Add compression metadata\n        compression: {\n          originalLength: originalItem.content.length,\n          compressedLength: processed.summarizedContent.length,\n          compressionRatio:\n            processed.summarizedContent.length / originalItem.content.length,\n          detailLevel,\n        },\n      };\n    })\n    .filter(Boolean); // Remove any nulls\n}\n", "\"use strict\";\n\n/**\n * main.js\n *\n * Main entry point for the MCP server.\n * Initializes the database connection and starts the MCP server.\n */\n\n// IMPORTANT: Set MCP_MODE before any imports or other code runs\nprocess.env.MCP_MODE = \"true\";\n\n// ========== INTERCEPT STDOUT/STDERR BEFORE IMPORTS ==========\n// Replace these functions before any imports so they can't be used\n// by imported modules to log messages that would break JSON parsing\n\n// Store original methods\nconst originalStdoutWrite = process.stdout.write;\nconst originalStderrWrite = process.stderr.write;\nconst originalConsoleLog = console.log;\nconst originalConsoleError = console.error;\nconst originalConsoleWarn = console.warn;\nconst originalConsoleInfo = console.info;\nconst originalConsoleDebug = console.debug;\n\n// Function to test if string is valid JSON\nfunction isValidJson(str) {\n  try {\n    JSON.parse(str);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// More comprehensive check for valid JSON output\nfunction isValidMcpOutput(str) {\n  if (typeof str !== \"string\") return false;\n\n  // Trim whitespace\n  const trimmed = str.trim();\n\n  // Must start with { or [ for valid JSON\n  if (!(trimmed.startsWith(\"{\") || trimmed.startsWith(\"[\"))) {\n    return false;\n  }\n\n  // Try parsing as JSON\n  try {\n    JSON.parse(trimmed);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// Completely replace stdout.write - only allow valid JSON through\nprocess.stdout.write = function (chunk, encoding, callback) {\n  // In MCP mode, strictly validate all output\n  if (process.env.MCP_MODE === \"true\") {\n    if (typeof chunk === \"string\" && isValidMcpOutput(chunk)) {\n      return originalStdoutWrite.apply(process.stdout, arguments);\n    }\n    // Silently drop invalid output\n    if (callback) callback();\n    return true;\n  } else {\n    // In normal mode, allow all output\n    return originalStdoutWrite.apply(process.stdout, arguments);\n  }\n};\n\n// Redirect all stderr to our own handler in MCP mode\nprocess.stderr.write = function (chunk, encoding, callback) {\n  // In MCP mode, don't output anything to stderr\n  if (process.env.MCP_MODE === \"true\") {\n    // Silently succeed, don't write anything\n    if (callback) callback();\n    return true;\n  } else {\n    // In normal mode, use original handler\n    return originalStderrWrite.apply(process.stderr, arguments);\n  }\n};\n\n// Replace all console methods\nconsole.log = function (...args) {\n  if (process.env.MCP_MODE === \"true\") {\n    // In MCP mode, only let valid JSON strings through to stdout\n    if (\n      args.length === 1 &&\n      typeof args[0] === \"string\" &&\n      isValidMcpOutput(args[0])\n    ) {\n      originalStdoutWrite.call(process.stdout, args[0] + \"\\n\");\n    }\n    // Silently drop all other output\n    return;\n  } else {\n    // In normal mode, use original method\n    return originalConsoleLog.apply(console, args);\n  }\n};\n\nconsole.error = function (...args) {\n  if (process.env.MCP_MODE === \"true\") {\n    // Completely suppress in MCP mode\n    return;\n  } else {\n    return originalConsoleError.apply(console, args);\n  }\n};\n\nconsole.warn = function (...args) {\n  if (process.env.MCP_MODE === \"true\") {\n    // Completely suppress in MCP mode\n    return;\n  } else {\n    return originalConsoleWarn.apply(console, args);\n  }\n};\n\nconsole.info = function (...args) {\n  if (process.env.MCP_MODE === \"true\") {\n    // Completely suppress in MCP mode\n    return;\n  } else {\n    return originalConsoleInfo.apply(console, args);\n  }\n};\n\nconsole.debug = function (...args) {\n  if (process.env.MCP_MODE === \"true\") {\n    // Completely suppress in MCP mode\n    return;\n  } else {\n    return originalConsoleDebug.apply(console, args);\n  }\n};\n\n// ========== NOW SAFE TO IMPORT MODULES ==========\n\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { TURSO_DATABASE_URL, TURSO_AUTH_TOKEN } from \"./config.js\";\nimport {\n  testDbConnection,\n  initializeDatabaseSchema,\n  getDbClient,\n} from \"./db.js\";\nimport { logMessage } from \"./utils/logger.js\";\nimport allTools from \"./tools/index.js\";\nimport {\n  createToolHandler,\n  createInitializeContextHandler,\n  createFinalizeContextHandler,\n} from \"./tools/mcpDevContextTools.js\";\nimport { applyDecayToAll } from \"./logic/ContextPrioritizerLogic.js\";\nimport { scheduleConsolidation } from \"./logic/GlobalPatternRepository.js\";\n\n// Store timers for cleanup during shutdown\nlet decayTimer = null;\n\n/**\n * Start the MCP server\n * Initializes database and listens for MCP requests\n */\nasync function startServer() {\n  // Determine if we're in MCP mode\n  const isMcpMode = process.env.MCP_MODE === \"true\";\n\n  if (!isMcpMode) {\n    // === NORMAL MODE STARTUP ===\n    // Check if database credentials are set\n    if (!TURSO_DATABASE_URL || !TURSO_AUTH_TOKEN) {\n      logMessage(\n        \"error\",\n        \"Database credentials not set. TURSO_DATABASE_URL and TURSO_AUTH_TOKEN are required.\"\n      );\n      process.exit(1);\n    }\n\n    // Get database client\n    try {\n      logMessage(\"info\", \"Getting database client...\");\n      const dbClient = getDbClient();\n      logMessage(\"info\", \"Database client created successfully.\");\n    } catch (error) {\n      logMessage(\"error\", `Failed to create database client: ${error.message}`);\n      process.exit(1);\n    }\n\n    // Test database connection\n    try {\n      logMessage(\"info\", \"Testing database connection...\");\n      await testDbConnection();\n      logMessage(\"info\", \"Database connection successful.\");\n    } catch (error) {\n      logMessage(\"error\", `Database connection failed: ${error.message}`);\n      process.exit(1);\n    }\n\n    // Initialize database schema\n    try {\n      logMessage(\"info\", \"Initializing database schema...\");\n      await initializeDatabaseSchema();\n      logMessage(\"info\", \"Database schema initialized successfully.\");\n    } catch (error) {\n      logMessage(\n        \"error\",\n        `Failed to initialize database schema: ${error.message}`\n      );\n      process.exit(1);\n    }\n\n    // Schedule periodic background tasks\n    try {\n      // Schedule pattern consolidation (e.g., every hour)\n      scheduleConsolidation(60);\n      logMessage(\"info\", \"Scheduled periodic pattern consolidation.\");\n\n      // Schedule context decay (e.g., every 24 hours)\n      const decayInterval = 24 * 60 * 60 * 1000; // 24 hours\n      decayTimer = setInterval(async () => {\n        try {\n          logMessage(\"info\", \"Applying context decay...\");\n          await applyDecayToAll();\n          logMessage(\"info\", \"Context decay applied successfully.\");\n        } catch (err) {\n          logMessage(\"error\", \"Error applying context decay:\", {\n            error: err.message,\n          });\n        }\n      }, decayInterval);\n      logMessage(\n        \"info\",\n        `Scheduled periodic context decay every ${\n          decayInterval / (60 * 60 * 1000)\n        } hours.`\n      );\n    } catch (error) {\n      logMessage(\n        \"warn\",\n        `Failed to schedule background tasks: ${error.message}`\n      );\n      // Continue server startup despite scheduling failure\n    }\n  } else {\n    // === MCP MODE STARTUP ===\n    // In MCP mode, we still need database, but do it silently\n    // And most importantly, never allow any logging to reach stdout\n    try {\n      // Wrap all DB operations in a single try/catch to prevent any errors from escaping\n      try {\n        // Create DB client silently\n        getDbClient();\n\n        // Test connection silently\n        await testDbConnection();\n\n        // Init schema silently\n        await initializeDatabaseSchema();\n      } catch (innerError) {\n        // Completely swallow any database errors in MCP mode\n        // Never log or throw - this prevents stdout corruption\n      }\n\n      // Skip scheduling background tasks in MCP mode\n    } catch (outerError) {\n      // Double protection - ensure nothing escapes\n      // Never log or throw in MCP mode\n    }\n  }\n\n  // Create and initialize the MCP server\n  const server = new McpServer({\n    name: \"cursor10x\",\n    version: \"2.0.0\",\n  });\n\n  // Register all tools with appropriate wrappers\n  for (const tool of allTools) {\n    let wrappedHandler;\n\n    // Use specialized handlers for initialize and finalize context tools\n    if (tool.name === \"initialize_conversation_context\") {\n      wrappedHandler = createInitializeContextHandler(tool.handler);\n    } else if (tool.name === \"finalize_conversation_context\") {\n      wrappedHandler = createFinalizeContextHandler(tool.handler);\n    } else {\n      // Use general handler for other tools\n      wrappedHandler = createToolHandler(tool.handler, tool.name);\n    }\n\n    // Register the tool with the wrapped handler\n    server.tool(tool.name, tool.inputSchema, wrappedHandler);\n    if (!isMcpMode) {\n      logMessage(\"info\", `Registered tool: ${tool.name}`);\n    }\n  }\n\n  const transport = new StdioServerTransport();\n  if (!isMcpMode) {\n    logMessage(\"info\", `Starting MCP server with PID ${process.pid}...`);\n  }\n\n  // Set up graceful shutdown handler\n  setupGracefulShutdown();\n\n  try {\n    await server.connect(transport);\n    if (!isMcpMode) {\n      logMessage(\"info\", \"MCP server stopped.\");\n    }\n    cleanupTimers();\n  } catch (error) {\n    if (!isMcpMode) {\n      logMessage(\"error\", `MCP server error: ${error.message}`);\n    }\n    cleanupTimers();\n    process.exit(1);\n  }\n}\n\n/**\n * Set up handlers for graceful shutdown\n */\nfunction setupGracefulShutdown() {\n  // Skip logging in MCP mode\n  const isMcpMode = process.env.MCP_MODE === \"true\";\n\n  // Handle terminal signals\n  process.on(\"SIGINT\", () => {\n    if (!isMcpMode) {\n      logMessage(\"info\", \"Received SIGINT signal. Shutting down gracefully...\");\n    }\n    cleanupTimers();\n    process.exit(0);\n  });\n\n  process.on(\"SIGTERM\", () => {\n    if (!isMcpMode) {\n      logMessage(\n        \"info\",\n        \"Received SIGTERM signal. Shutting down gracefully...\"\n      );\n    }\n    cleanupTimers();\n    process.exit(0);\n  });\n}\n\n/**\n * Clean up all interval timers\n */\nfunction cleanupTimers() {\n  const isMcpMode = process.env.MCP_MODE === \"true\";\n\n  if (decayTimer) {\n    clearInterval(decayTimer);\n    decayTimer = null;\n    if (!isMcpMode) {\n      logMessage(\"info\", \"Cleared context decay timer.\");\n    }\n  }\n}\n\n// Run the server unless this file is being required as a module\nif (\n  import.meta.url === import.meta.mainUrl ||\n  process.env.NODE_ENV !== \"test\"\n) {\n  startServer().catch((error) => {\n    // Skip logging in MCP mode\n    if (process.env.MCP_MODE !== \"true\") {\n      logMessage(\"error\", `Unhandled error in startServer: ${error.message}`);\n    }\n    // Don't use console.error here since we've replaced it\n    process.exit(1);\n  });\n}\n\nexport { startServer };\n", "/**\n * initializeConversationContext.tool.js\n *\n * MCP tool implementation for initializing conversation context\n * This tool gathers comprehensive context about the codebase and project for a new conversation\n */\n\nimport { z } from \"zod\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { executeQuery } from \"../db.js\";\nimport * as ConversationIntelligence from \"../logic/ConversationIntelligence.js\";\nimport * as ContextCompressorLogic from \"../logic/ContextCompressorLogic.js\";\nimport * as IntentPredictorLogic from \"../logic/IntentPredictorLogic.js\";\nimport * as SmartSearchServiceLogic from \"../logic/SmartSearchServiceLogic.js\";\nimport * as ActiveContextManager from \"../logic/ActiveContextManager.js\";\nimport * as TimelineManagerLogic from \"../logic/TimelineManagerLogic.js\";\nimport * as GlobalPatternRepository from \"../logic/GlobalPatternRepository.js\";\nimport {\n  initializeConversationContextInputSchema,\n  initializeConversationContextOutputSchema,\n} from \"../schemas/toolSchemas.js\";\nimport { logMessage } from \"../utils/logger.js\";\n\n/**\n * Handler for initialize_conversation_context tool\n *\n * @param {object} input - Tool input parameters\n * @param {object} sdkContext - SDK context\n * @returns {Promise<object>} Tool output\n */\nasync function handler(input, sdkContext) {\n  try {\n    logMessage(\"INFO\", `initialize_conversation_context tool started`, {\n      initialQuery: input.initialQuery,\n    });\n\n    // 1. Generate conversation ID if not provided\n    const conversationId = input.conversationId || uuidv4();\n    logMessage(\"DEBUG\", `Using conversation ID: ${conversationId}`);\n\n    // 2. Extract input parameters with defaults\n    const {\n      initialQuery = \"\",\n      focusHint,\n      includeArchitecture = true,\n      includeRecentConversations = true,\n      maxCodeContextItems = 5,\n      maxRecentChanges = 5,\n      contextDepth = \"standard\",\n      tokenBudget = 4000,\n    } = input;\n\n    // 3. Clear any active context and set initial focus if provided\n    try {\n      await ActiveContextManager.clearActiveContext();\n      if (focusHint) {\n        await ActiveContextManager.setActiveFocus(\n          focusHint.type,\n          focusHint.identifier\n        );\n        logMessage(\"INFO\", `Set initial focus`, {\n          type: focusHint.type,\n          identifier: focusHint.identifier,\n        });\n      }\n    } catch (err) {\n      logMessage(\n        \"WARN\",\n        `Failed to set initial focus, continuing with initialization`,\n        {\n          error: err.message,\n          focusHint,\n        }\n      );\n      // Continue with initialization despite focus setting error\n    }\n\n    // 4. Record the conversation start in timeline\n    try {\n      await TimelineManagerLogic.recordEvent(\n        \"conversation_started\",\n        {\n          initialQuery,\n          focusHint,\n          contextDepth,\n        },\n        [], // No associated entity IDs yet\n        conversationId\n      );\n      logMessage(\"DEBUG\", `Recorded conversation start in timeline`, {\n        conversationId,\n      });\n    } catch (err) {\n      // Non-critical failure, log but continue\n      logMessage(\"WARN\", `Failed to record conversation start in timeline`, {\n        error: err.message,\n        conversationId,\n      });\n    }\n\n    // 5. Initialize conversation intelligence tracker\n    try {\n      logMessage(\n        \"INFO\",\n        `Initializing conversation intelligence tracker with user query: \"${initialQuery}\"`,\n        {\n          conversationId,\n        }\n      );\n\n      await ConversationIntelligence.initializeConversation(\n        conversationId,\n        initialQuery\n      );\n\n      // Verify that messages were properly stored\n      const recentMessages = await ConversationIntelligence.getRecentMessages(\n        conversationId,\n        3\n      );\n      logMessage(\n        \"INFO\",\n        `Conversation initialized with ${recentMessages.length} messages`,\n        {\n          messages: recentMessages.map((m) => ({\n            role: m.role,\n            content:\n              m.content.substring(0, 50) + (m.content.length > 50 ? \"...\" : \"\"),\n          })),\n        }\n      );\n    } catch (err) {\n      logMessage(\"ERROR\", `Failed to initialize conversation intelligence`, {\n        error: err.message,\n        conversationId,\n      });\n      throw new Error(\n        `Conversation intelligence initialization failed: ${err.message}`\n      );\n    }\n\n    // 6. Predict initial intent based on query\n    let predictedIntent = \"\";\n    if (initialQuery) {\n      try {\n        const intentResult = await IntentPredictorLogic.inferIntentFromQuery(\n          initialQuery\n        );\n        predictedIntent = intentResult.intent;\n        logMessage(\"INFO\", `Predicted initial intent`, {\n          intent: predictedIntent,\n          confidence: intentResult.confidence || \"N/A\",\n        });\n      } catch (err) {\n        // Non-critical failure, log but continue with empty intent\n        logMessage(\n          \"WARN\",\n          `Intent prediction failed, continuing without intent`,\n          {\n            error: err.message,\n            initialQuery,\n          }\n        );\n      }\n    }\n\n    // 7. Gather comprehensive context\n    logMessage(\"INFO\", `Starting comprehensive context gathering`, {\n      conversationId,\n      includeArchitecture,\n      maxCodeContextItems,\n      contextDepth,\n    });\n\n    const comprehensiveContext = await gatherComprehensiveContext(\n      initialQuery,\n      focusHint,\n      conversationId,\n      {\n        includeArchitecture,\n        includeRecentConversations,\n        maxCodeContextItems,\n        maxRecentChanges,\n        contextDepth,\n        tokenBudget,\n      }\n    );\n\n    const contextCounts = {\n      codeContextItems: comprehensiveContext.codeContext?.length || 0,\n      architectureItems: comprehensiveContext.architectureContext?.length || 0,\n      recentChanges: comprehensiveContext.recentChanges?.length || 0,\n      patterns: comprehensiveContext.globalPatterns?.length || 0,\n    };\n\n    logMessage(\n      \"INFO\",\n      `Comprehensive context gathered successfully`,\n      contextCounts\n    );\n\n    // 8. Generate initial context summary\n    const initialContextSummary = generateInitialContextSummary(\n      comprehensiveContext,\n      initialQuery,\n      predictedIntent\n    );\n\n    logMessage(\"INFO\", `Generated initial context summary`, {\n      summaryLength: initialContextSummary?.length || 0,\n    });\n\n    // 9. Return the tool response with all gathered context\n    const responseData = {\n      message: `Conversation context initialized with ID: ${conversationId}`,\n      conversationId,\n      initialContextSummary,\n      predictedIntent,\n      comprehensiveContext,\n    };\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify(responseData),\n        },\n      ],\n    };\n  } catch (error) {\n    // Log detailed error information\n    logMessage(\"ERROR\", `Error in initialize_conversation_context tool`, {\n      error: error.message,\n      stack: error.stack,\n      input: {\n        initialQuery: input.initialQuery,\n        focusHint: input.focusHint,\n        contextDepth: input.contextDepth,\n      },\n    });\n\n    // Return error response\n    const errorResponse = {\n      error: true,\n      errorCode: error.code || \"INITIALIZATION_FAILED\",\n      errorDetails: error.message,\n    };\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify(errorResponse),\n        },\n      ],\n    };\n  }\n}\n\n/**\n * Gathers comprehensive context about the codebase and project\n *\n * @param {string} initialQuery - Initial user query\n * @param {object} focusHint - Focus hint information\n * @param {string} conversationId - Conversation ID\n * @param {object} options - Context gathering options\n * @returns {Promise<object>} Comprehensive context object\n */\nasync function gatherComprehensiveContext(\n  initialQuery,\n  focusHint,\n  conversationId,\n  options\n) {\n  const context = {};\n\n  try {\n    logMessage(\"DEBUG\", `Starting to gather code context`, {\n      initialQuery: initialQuery?.substring(0, 50),\n      focusHint,\n    });\n\n    // 1. Gather code context based on query and/or focus\n    context.codeContext = await gatherCodeContext(\n      initialQuery,\n      focusHint,\n      options\n    );\n\n    logMessage(\"DEBUG\", `Gathered code context`, {\n      itemCount: context.codeContext?.length || 0,\n    });\n\n    // 2. Gather architecture context (READMEs, docs)\n    if (options.includeArchitecture) {\n      try {\n        context.architectureContext = await gatherArchitectureContext(options);\n        logMessage(\"DEBUG\", `Gathered architecture context`, {\n          itemCount: context.architectureContext?.length || 0,\n        });\n      } catch (err) {\n        logMessage(\"WARN\", `Failed to gather architecture context`, {\n          error: err.message,\n        });\n        context.architectureContext = null;\n      }\n    } else {\n      context.architectureContext = null;\n    }\n\n    // 3. Get project structure overview\n    try {\n      context.projectStructure = await gatherProjectStructure();\n      logMessage(\"DEBUG\", `Gathered project structure`, {\n        directoryCount: context.projectStructure?.directories?.length || 0,\n        fileCount: context.projectStructure?.files?.length || 0,\n      });\n    } catch (err) {\n      logMessage(\"WARN\", `Failed to gather project structure`, {\n        error: err.message,\n      });\n      context.projectStructure = { directories: [], files: [] };\n    }\n\n    // 4. Get recent conversations if requested\n    if (options.includeRecentConversations) {\n      try {\n        context.recentConversations = await gatherRecentConversations(options);\n        logMessage(\"DEBUG\", `Gathered recent conversations`, {\n          count: context.recentConversations?.length || 0,\n        });\n      } catch (err) {\n        logMessage(\"WARN\", `Failed to gather recent conversations`, {\n          error: err.message,\n        });\n        context.recentConversations = [];\n      }\n    }\n\n    // 5. Get recent changes\n    try {\n      context.recentChanges = await gatherRecentChanges(\n        options.maxRecentChanges\n      );\n      logMessage(\"DEBUG\", `Gathered recent changes`, {\n        count: context.recentChanges?.length || 0,\n      });\n    } catch (err) {\n      logMessage(\"WARN\", `Failed to gather recent changes`, {\n        error: err.message,\n      });\n      context.recentChanges = [];\n    }\n\n    // 6. Get active workflows and milestones\n    try {\n      context.activeWorkflows = await gatherActiveWorkflows();\n      logMessage(\"DEBUG\", `Gathered active workflows`, {\n        count: context.activeWorkflows?.length || 0,\n      });\n    } catch (err) {\n      logMessage(\"WARN\", `Failed to gather active workflows`, {\n        error: err.message,\n      });\n      context.activeWorkflows = [];\n    }\n\n    // 7. Get relevant global patterns\n    try {\n      context.globalPatterns = await gatherGlobalPatterns(\n        initialQuery,\n        options\n      );\n      logMessage(\"DEBUG\", `Gathered global patterns`, {\n        count: context.globalPatterns?.length || 0,\n      });\n    } catch (err) {\n      logMessage(\"WARN\", `Failed to gather global patterns`, {\n        error: err.message,\n      });\n      context.globalPatterns = [];\n    }\n\n    return context;\n  } catch (error) {\n    logMessage(\"ERROR\", `Error gathering comprehensive context`, {\n      error: error.message,\n      conversationId,\n    });\n    throw error; // Re-throw to be caught by the main handler\n  }\n}\n\n/**\n * Gathers code context based on query and focus\n *\n * @param {string} query - User query\n * @param {object} focusHint - Focus hint\n * @param {object} options - Options\n * @returns {Promise<Array>} Code context items\n */\nasync function gatherCodeContext(query, focusHint, options) {\n  try {\n    // Create search constraints\n    const searchConstraints = {\n      limit: options.maxCodeContextItems * 2, // Get more than we need for filtering\n    };\n\n    // Add focus constraints if provided\n    if (focusHint) {\n      if (focusHint.type === \"file\" || focusHint.type === \"directory\") {\n        searchConstraints.filePaths = [focusHint.identifier];\n      }\n    }\n\n    // Extract keywords if query is provided, otherwise use basic terms\n    const searchTerms = query\n      ? await extractKeywords(query)\n      : [\"README\", \"main\", \"index\", \"config\"];\n\n    // Perform search\n    const searchResults = await SmartSearchServiceLogic.searchByKeywords(\n      searchTerms,\n      searchConstraints\n    );\n\n    // Process and compress search results\n    let codeItems = searchResults.map((result) => ({\n      entity_id: result.entity.entity_id,\n      path: result.entity.file_path,\n      type: result.entity.entity_type,\n      name: result.entity.name,\n      content: result.entity.raw_content,\n      relevanceScore: result.relevanceScore,\n    }));\n\n    // Limit to max items\n    codeItems = codeItems.slice(0, options.maxCodeContextItems);\n\n    // Apply compression based on context depth\n    const compressionOptions = {\n      detailLevel: options.contextDepth,\n      targetTokens: Math.floor(options.tokenBudget * 0.6), // Allocate 60% of token budget to code\n    };\n\n    const compressedItems = await ContextCompressorLogic.compressContext(\n      codeItems,\n      compressionOptions\n    );\n\n    return compressedItems;\n  } catch (error) {\n    console.error(`[gatherCodeContext] Error: ${error.message}`);\n    return [];\n  }\n}\n\n/**\n * Gathers architecture context information\n *\n * @param {object} options - Options\n * @returns {Promise<object>} Architecture context\n */\nasync function gatherArchitectureContext(options) {\n  try {\n    // Search for documentation files\n    const docSearchResults = await SmartSearchServiceLogic.searchByKeywords(\n      [\"README\", \"documentation\", \"architecture\", \"overview\", \"guide\", \"setup\"],\n      {\n        limit: 5,\n        strategy: \"keywords\",\n      }\n    );\n\n    if (docSearchResults.length === 0) {\n      return null;\n    }\n\n    // Extract documentation content\n    const docSources = docSearchResults.map((result) => ({\n      name: result.entity.name,\n      path: result.entity.file_path,\n    }));\n\n    // Combine and summarize documentation\n    const docContents = docSearchResults\n      .map((result) => result.entity.raw_content)\n      .join(\"\\n\\n\");\n\n    // Compress documentation based on context depth\n    const compressionOptions = {\n      detailLevel: options.contextDepth,\n      targetTokens: Math.floor(options.tokenBudget * 0.2), // Allocate 20% of token budget to architecture docs\n    };\n\n    // Generate summary\n    const summary =\n      docContents.length > 1000\n        ? docContents.substring(0, 1000) + \"...\" // Simple truncation for now\n        : docContents;\n\n    return {\n      summary,\n      sources: docSources,\n    };\n  } catch (error) {\n    console.error(`[gatherArchitectureContext] Error: ${error.message}`);\n    return null;\n  }\n}\n\n/**\n * Gathers project structure information\n *\n * @returns {Promise<object>} Project structure\n */\nasync function gatherProjectStructure() {\n  try {\n    // Query for directory structure\n    const dirQuery = `\n      SELECT \n        file_path,\n        COUNT(*) as file_count\n      FROM \n        code_entities\n      WHERE \n        entity_type = 'file'\n      GROUP BY \n        SUBSTR(file_path, 1, INSTR(file_path, '/'))\n      ORDER BY \n        file_count DESC\n      LIMIT 10\n    `;\n\n    const directories = await executeQuery(dirQuery);\n\n    // Check if directories has a rows property and it's an array\n    const rows =\n      directories && directories.rows && Array.isArray(directories.rows)\n        ? directories.rows\n        : Array.isArray(directories)\n        ? directories\n        : [];\n\n    // If no valid results, return basic structure\n    if (rows.length === 0) {\n      return {\n        topLevelDirs: [],\n        totalFiles: 0,\n      };\n    }\n\n    return {\n      topLevelDirs: rows.map((dir) => ({\n        path: dir.file_path.split(\"/\")[0],\n        fileCount: dir.file_count,\n      })),\n      totalFiles: rows.reduce((sum, dir) => sum + dir.file_count, 0),\n    };\n  } catch (error) {\n    console.error(`[gatherProjectStructure] Error: ${error.message}`);\n    return null;\n  }\n}\n\n/**\n * Gathers recent conversations for context\n *\n * @param {object} options - Options\n * @returns {Promise<Array>} Recent conversations\n */\nasync function gatherRecentConversations(options) {\n  try {\n    // Get recent conversation events from timeline\n    const recentConversationEvents = await TimelineManagerLogic.getEvents({\n      types: [\"conversation_completed\"],\n      limit: 3,\n    });\n\n    if (recentConversationEvents.length === 0) {\n      return [];\n    }\n\n    // Format conversation summaries\n    return recentConversationEvents.map((event) => ({\n      timestamp: event.timestamp,\n      summary: event.data.summary || \"Conversation completed\",\n      purpose: event.data.purpose || \"Unknown purpose\",\n    }));\n  } catch (error) {\n    console.error(`[gatherRecentConversations] Error: ${error.message}`);\n    return [];\n  }\n}\n\n/**\n * Gathers recent changes in the project\n *\n * @param {number} maxChanges - Maximum number of changes to retrieve\n * @returns {Promise<Array>} Recent changes\n */\nasync function gatherRecentChanges(maxChanges) {\n  try {\n    // Get recent file change events from timeline\n    const recentChangeEvents = await TimelineManagerLogic.getEvents({\n      types: [\"file_change\", \"file_create\", \"code_commit\"],\n      limit: maxChanges,\n    });\n\n    if (recentChangeEvents.length === 0) {\n      return [];\n    }\n\n    // Format change events\n    return recentChangeEvents.map((event) => ({\n      timestamp: event.timestamp,\n      files: event.data.files || [event.data.filePath || \"Unknown file\"],\n      summary: event.data.message || `${event.event_type} event occurred`,\n    }));\n  } catch (error) {\n    console.error(`[gatherRecentChanges] Error: ${error.message}`);\n    return [];\n  }\n}\n\n/**\n * Gathers active workflows and milestones\n *\n * @returns {Promise<Array>} Active workflows\n */\nasync function gatherActiveWorkflows() {\n  try {\n    // Get recent milestone events\n    const milestoneEvents = await TimelineManagerLogic.getEvents({\n      types: [\"milestone\"],\n      limit: 3,\n      includeMilestones: true,\n    });\n\n    if (milestoneEvents.length === 0) {\n      return [];\n    }\n\n    // Format milestones\n    return milestoneEvents.map((event) => ({\n      name: event.data.name || \"Unnamed milestone\",\n      description: event.data.description || \"No description provided\",\n      timestamp: event.timestamp,\n    }));\n  } catch (error) {\n    console.error(`[gatherActiveWorkflows] Error: ${error.message}`);\n    return [];\n  }\n}\n\n/**\n * Gathers global patterns relevant to the query\n *\n * @param {string} query - User query\n * @param {object} options - Options\n * @returns {Promise<Array>} Global patterns\n */\nasync function gatherGlobalPatterns(query, options) {\n  try {\n    // Get global patterns\n    const globalPatterns = await GlobalPatternRepository.retrieveGlobalPatterns(\n      {\n        minConfidence: 0.4,\n        limit: 5,\n      }\n    );\n\n    if (globalPatterns.length === 0) {\n      return [];\n    }\n\n    // Format patterns\n    return globalPatterns.map((pattern) => ({\n      name: pattern.name,\n      type: pattern.pattern_type,\n      description: pattern.description,\n      confidence: pattern.confidence_score,\n    }));\n  } catch (error) {\n    console.error(`[gatherGlobalPatterns] Error: ${error.message}`);\n    return [];\n  }\n}\n\n/**\n * Generates a summary of the initial context\n *\n * @param {object} context - Comprehensive context\n * @param {string} query - Initial query\n * @param {string} intent - Predicted intent\n * @returns {string} Context summary\n */\nfunction generateInitialContextSummary(context, query, intent) {\n  // Create initial summary\n  let summary = \"Project context initialized\";\n\n  // Add query info if present\n  if (query) {\n    summary += ` for query: \"${query}\"`;\n  }\n\n  // Add intent if predicted\n  if (intent) {\n    summary += ` with intent: ${intent}`;\n  }\n\n  // Count code context items\n  if (context.codeContext && context.codeContext.length > 0) {\n    summary += `. Found ${context.codeContext.length} relevant code items`;\n  }\n\n  // Add architecture context if present\n  if (context.architectureContext) {\n    summary += \". Project documentation available\";\n  }\n\n  // Add recent activity info\n  if (context.recentChanges && context.recentChanges.length > 0) {\n    summary += `. ${context.recentChanges.length} recent file changes detected`;\n  }\n\n  // Add pattern info\n  if (context.globalPatterns && context.globalPatterns.length > 0) {\n    summary += `. ${context.globalPatterns.length} relevant patterns identified`;\n  }\n\n  return summary;\n}\n\n/**\n * Extract keywords from text\n *\n * @param {string} text - Text to extract keywords from\n * @returns {Promise<Array>} Keywords\n */\nasync function extractKeywords(text) {\n  // Simple keyword extraction (in production would call TextTokenizerLogic)\n  return text\n    .toLowerCase()\n    .replace(/[^\\w\\s]/g, \"\")\n    .split(/\\s+/)\n    .filter((word) => word.length > 2)\n    .filter((word) => ![\"the\", \"and\", \"for\", \"with\"].includes(word));\n}\n\n// Export the tool definition for server registration\nexport default {\n  name: \"initialize_conversation_context\",\n  description:\n    \"Initializes a new conversation context with comprehensive codebase information\",\n  inputSchema: initializeConversationContextInputSchema,\n  outputSchema: initializeConversationContextOutputSchema,\n  handler,\n};\n", "/**\n * ConversationIntelligence.js\n *\n * Provides logic for recording and analyzing conversation messages,\n * including semantic markers and sentiment indicators.\n */\n\nimport { executeQuery } from \"../db.js\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport * as TextTokenizerLogic from \"./TextTokenizerLogic.js\";\nimport * as ContextIndexerLogic from \"./ContextIndexerLogic.js\";\nimport * as ConversationSegmenter from \"./ConversationSegmenter.js\";\nimport * as ConversationPurposeDetector from \"./ConversationPurposeDetector.js\";\nimport * as ContextCompressorLogic from \"./ContextCompressorLogic.js\";\nimport { logMessage } from \"../utils/logger.js\";\n\n/**\n * Records a message in the conversation history, extracting semantic markers and sentiment indicators.\n *\n * @param {string} messageContent - The content of the message\n * @param {string} role - The role of the sender (e.g., 'user', 'assistant')\n * @param {string} conversationId - The conversation ID\n * @param {string[]} [relatedContextEntityIds=[]] - Array of related context entity IDs\n * @param {string} [topicSegmentId] - Optional topic segment ID\n * @param {string} [userIntent] - Optional user intent for the message\n * @returns {Promise<string>} The ID of the recorded message\n */\nexport async function recordMessage(\n  messageContent,\n  role,\n  conversationId,\n  relatedContextEntityIds = [],\n  topicSegmentId,\n  userIntent\n) {\n  try {\n    // 1. Generate message_id\n    const message_id = uuidv4();\n    const timestamp = new Date().toISOString();\n\n    // Print detailed input parameters for debugging\n    logMessage(\"info\", \"===== RECORD MESSAGE - START =====\");\n    logMessage(\"info\", \"Input parameters:\");\n    logMessage(\"info\", \"- message_id:\", message_id);\n    logMessage(\"info\", \"- conversation_id:\", conversationId);\n    logMessage(\"info\", \"- role:\", role);\n    logMessage(\n      \"info\",\n      \"- content:\",\n      messageContent &&\n        messageContent.substring(0, 50) +\n          (messageContent.length > 50 ? \"...\" : \"\")\n    );\n    logMessage(\"info\", \"- timestamp:\", timestamp);\n    logMessage(\"info\", \"- topic_segment_id:\", topicSegmentId || \"null\");\n    logMessage(\"info\", \"- user_intent:\", userIntent || \"null\");\n    logMessage(\n      \"info\",\n      \"- related_context_entity_ids:\",\n      JSON.stringify(relatedContextEntityIds || [])\n    );\n\n    // 2. Extract semantic markers (e.g., idioms, emphasis, question, etc.)\n    let semantic_markers = [];\n    if (role === \"user\" && TextTokenizerLogic.identifyLanguageSpecificIdioms) {\n      // Always provide a language parameter, defaulting to \"plaintext\" if none is detected\n      semantic_markers =\n        TextTokenizerLogic.identifyLanguageSpecificIdioms(\n          messageContent,\n          \"plaintext\"\n        ) || [];\n    } else {\n      // Fallback: simple keyword spotting for emphasis/questions\n      if (messageContent.includes(\"!\")) semantic_markers.push(\"emphasis\");\n      if (messageContent.includes(\"?\")) semantic_markers.push(\"question\");\n    }\n\n    // 3. Extract sentiment indicators (basic regex for positive/negative keywords)\n    const positiveKeywords = [\n      \"great\",\n      \"good\",\n      \"excellent\",\n      \"awesome\",\n      \"love\",\n      \"like\",\n      \"well done\",\n      \"thanks\",\n      \"thank you\",\n      \"perfect\",\n      \"amazing\",\n      \"fantastic\",\n      \"nice\",\n      \"happy\",\n      \"success\",\n      \"yay\",\n    ];\n    const negativeKeywords = [\n      \"bad\",\n      \"error\",\n      \"fail\",\n      \"hate\",\n      \"problem\",\n      \"issue\",\n      \"bug\",\n      \"broken\",\n      \"wrong\",\n      \"difficult\",\n      \"hard\",\n      \"annoy\",\n      \"frustrate\",\n      \"sad\",\n      \"unhappy\",\n      \"disappoint\",\n      \"no\",\n      \"not working\",\n      \"doesn't work\",\n      \"crash\",\n      \"stuck\",\n    ];\n    const foundPositive = positiveKeywords.filter((kw) =>\n      messageContent.toLowerCase().includes(kw)\n    );\n    const foundNegative = negativeKeywords.filter((kw) =>\n      messageContent.toLowerCase().includes(kw)\n    );\n    const sentiment_indicators = {\n      positive_keywords: foundPositive,\n      negative_keywords: foundNegative,\n    };\n\n    // Create the message object to be indexed\n    const messageObject = {\n      message_id,\n      conversation_id: conversationId,\n      role,\n      content: messageContent,\n      timestamp,\n      relatedContextEntityIds: JSON.stringify(relatedContextEntityIds || []),\n      summary: null,\n      userIntent: userIntent || null,\n      topicSegmentId: topicSegmentId || null,\n      semantic_markers: JSON.stringify(semantic_markers),\n      sentiment_indicators: JSON.stringify(sentiment_indicators),\n    };\n\n    logMessage(\"info\", \"Message object to be indexed:\", {\n      message_id: messageObject.message_id,\n      conversation_id: messageObject.conversation_id,\n      role: messageObject.role,\n      topic_segment_id: messageObject.topicSegmentId,\n      user_intent: messageObject.userIntent,\n    });\n\n    // 4. Call ContextIndexerLogic.indexConversationMessage\n    await ContextIndexerLogic.indexConversationMessage(messageObject);\n\n    logMessage(\"info\", \"===== RECORD MESSAGE - COMPLETE =====\");\n    logMessage(\"info\", \"Successfully recorded message with ID:\", message_id);\n\n    // 5. Return the message_id\n    return message_id;\n  } catch (error) {\n    logMessage(\"error\", \"===== RECORD MESSAGE - ERROR =====\");\n    logMessage(\"error\", \"Failed to record message:\", { error: error.message });\n    logMessage(\"error\", \"Error stack:\", { stack: error.stack });\n    throw new Error(\"Failed to record message: \" + error.message);\n  }\n}\n\n/**\n * Detects if a new message represents a topic shift in the conversation.\n *\n * @param {string} newMessageContent - The content of the new message\n * @param {string} conversationId - The conversation ID\n * @returns {Promise<boolean>} True if a topic shift is detected, false otherwise\n */\nexport async function detectTopicShift(newMessageContent, conversationId) {\n  // Fetch recent conversation history (last 5-10 messages)\n  const history = await getConversationHistory(conversationId, 10);\n  // Build the new message object (assume role is 'user' for this context)\n  const newMessage = { content: newMessageContent, role: \"user\" };\n  // Delegate to ConversationSegmenter\n  const isShift = await ConversationSegmenter.detectTopicShift(\n    newMessage,\n    history\n  );\n  return isShift;\n}\n\n/**\n * Gets all topics for a conversation, either as a flat list or hierarchical structure.\n *\n * @param {string} conversationId - The conversation ID\n * @param {boolean} [hierarchical=false] - Whether to return a hierarchical structure\n * @returns {Promise<Topic[] | {rootTopics: Topic[], topicMap: Record<string, Topic>}>}\n */\nexport async function getConversationTopics(\n  conversationId,\n  hierarchical = false\n) {\n  try {\n    if (hierarchical) {\n      // Use ConversationSegmenter to build hierarchy\n      return await ConversationSegmenter.buildTopicHierarchy(conversationId);\n    }\n    // Flat list: query conversation_topics table\n    const query = `\n      SELECT * FROM conversation_topics\n      WHERE conversation_id = ?\n      ORDER BY start_timestamp ASC\n    `;\n    const result = await executeQuery(query, [conversationId]);\n\n    // Check if result has rows property and it's not empty\n    if (!result || !result.rows || result.rows.length === 0) {\n      logMessage(\"info\", `No topics found for conversation: ${conversationId}`);\n      return [];\n    }\n\n    // Create new objects with parsed JSON fields instead of modifying the originals\n    return result.rows.map((topic) => {\n      const newTopic = { ...topic }; // Create a shallow copy\n\n      try {\n        // Parse JSON strings into new properties\n        newTopic.primary_entities = topic.primary_entities\n          ? JSON.parse(topic.primary_entities)\n          : [];\n        newTopic.keywords = topic.keywords ? JSON.parse(topic.keywords) : [];\n      } catch (err) {\n        logMessage(\n          \"warn\",\n          `Error parsing JSON fields in topic: ${err.message}`\n        );\n        newTopic.primary_entities = [];\n        newTopic.keywords = [];\n      }\n      return newTopic;\n    });\n  } catch (error) {\n    logMessage(\"warn\", `Failed to retrieve conversation topics`, {\n      error: error.message,\n      conversationId,\n    });\n    // Return empty array on error\n    return [];\n  }\n}\n\n/**\n * Returns messages most relevant to a query, using keyword overlap and optional topic/purpose boosting.\n *\n * @param {string} query - The search query\n * @param {string} conversationId - The conversation ID\n * @param {Object} [options] - Optional filters and limit\n * @param {boolean} [options.purposeFilter] - Boost messages in active purpose\n * @param {boolean} [options.topicFilter] - Boost messages in active topic\n * @param {number} [options.limit] - Max number of results to return\n * @returns {Promise<Message[]>} Array of relevant messages\n */\nexport async function getRelevantConversationContext(\n  query,\n  conversationId,\n  options = {}\n) {\n  // 1. Fetch all messages for the conversation (limit to 200 for performance)\n  const allMessages = await getConversationHistory(conversationId, 200);\n  if (!allMessages || allMessages.length === 0) return [];\n\n  // 2. Tokenize query and extract keywords\n  const queryTokens = TextTokenizerLogic.tokenize(query);\n  const queryKeywords = new Set(\n    TextTokenizerLogic.extractKeywords(queryTokens, 10)\n  );\n\n  // 3. Get active topic and purpose if needed\n  let activeTopicId = null;\n  let activePurpose = null;\n  if (options.topicFilter) {\n    const activeTopic =\n      await ConversationSegmenter.getActiveTopicForConversation(conversationId);\n    activeTopicId = activeTopic ? activeTopic.topic_id : null;\n  }\n  if (options.purposeFilter) {\n    activePurpose = await ConversationPurposeDetector.getActivePurpose(\n      conversationId\n    );\n  }\n\n  // 4. Score each message\n  const scoredMessages = allMessages.map((msg) => {\n    // Tokenize and extract keywords from message content\n    const msgTokens = TextTokenizerLogic.tokenize(msg.content || \"\");\n    const msgKeywords = new Set(\n      TextTokenizerLogic.extractKeywords(msgTokens, 10)\n    );\n    // Calculate Jaccard index (overlap / union)\n    const intersection = new Set(\n      [...queryKeywords].filter((x) => msgKeywords.has(x))\n    );\n    const union = new Set([...queryKeywords, ...msgKeywords]);\n    let relevance = union.size > 0 ? intersection.size / union.size : 0;\n\n    // Boost for topic\n    if (\n      options.topicFilter &&\n      activeTopicId &&\n      msg.topic_segment_id === activeTopicId\n    ) {\n      relevance += 0.2;\n    }\n    // Boost for purpose (if message timestamp falls within active purpose window)\n    if (\n      options.purposeFilter &&\n      activePurpose &&\n      activePurpose.start_timestamp\n    ) {\n      const msgTime = msg.timestamp || msg.created_at;\n      if (\n        msgTime >= activePurpose.start_timestamp &&\n        (!activePurpose.end_timestamp || msgTime <= activePurpose.end_timestamp)\n      ) {\n        relevance += 0.15;\n      }\n    }\n    return { ...msg, relevance };\n  });\n\n  // 5. Sort by relevance DESC\n  scoredMessages.sort((a, b) => b.relevance - a.relevance);\n\n  // 6. Apply limit\n  const limit = options.limit || 10;\n  const topMessages = scoredMessages.slice(0, limit);\n\n  // 7. Remove temporary relevance field before returning\n  return topMessages.map(({ relevance, ...msg }) => msg);\n}\n\n/**\n * Infers the type of development task being discussed in a conversation.\n *\n * @param {string} conversationId - The conversation ID\n * @returns {Promise<string|null>} The inferred task type or null if not confident\n */\nexport async function getTaskTypeFromConversation(conversationId) {\n  // 1. Classify the conversation\n  const classification = await classifyConversation(conversationId);\n  if (!classification || !classification.purpose) return null;\n\n  const { purpose, confidence } = classification;\n\n  // 2. Define mapping from purpose to task type\n  const purposeToTaskType = {\n    debugging: \"bug_fixing\",\n    feature_planning: \"new_feature_development\",\n    code_review: \"code_review\",\n    learning: \"research\",\n    code_generation: \"implementation\",\n    optimization: \"performance_optimization\",\n    refactoring: \"refactoring\",\n    general_query: \"research\",\n    documentation: \"documentation\",\n    testing: \"testing\",\n  };\n\n  // 3. Heuristic: if confidence is low or purpose is too generic, return null or default\n  if (confidence < 0.55 || purpose === \"general_query\") {\n    return null;\n  }\n\n  // 4. Map purpose to task type\n  const taskType = purposeToTaskType[purpose] || \"general_development_task\";\n  return taskType;\n}\n\n/**\n * Provides purpose-specific summaries of different conversation segments.\n *\n * @param {string} conversationId - The conversation ID\n * @returns {Promise<{purpose: string, summary: string}[]>} Array of summaries by purpose\n */\nexport async function getConversationSummaryByPurpose(conversationId) {\n  // 1. Get purpose history\n  const purposeHistory = await ConversationPurposeDetector.getPurposeHistory(\n    conversationId\n  );\n  if (!purposeHistory || purposeHistory.length === 0) return [];\n\n  const summaries = [];\n\n  for (const segment of purposeHistory) {\n    // 2. Fetch all messages in this purpose segment\n    const query = `\n      SELECT content FROM conversation_history\n      WHERE conversation_id = ?\n        AND timestamp >= ?\n        ${segment.end_timestamp ? \"AND timestamp <= ?\" : \"\"}\n      ORDER BY timestamp ASC\n    `;\n    const params = [conversationId, segment.start_timestamp];\n    if (segment.end_timestamp) params.push(segment.end_timestamp);\n    const messages = await executeQuery(query, params);\n    if (!messages || messages.length === 0) continue;\n\n    // 3. Concatenate message contents\n    const concatenated = messages.map((m) => m.content).join(\" \");\n\n    // 4. Summarize using ContextCompressorLogic\n    const summary = await ContextCompressorLogic.summarizeText(concatenated, {\n      targetLength: 150,\n      preserveKeyPoints: true,\n    });\n\n    summaries.push({\n      purpose: segment.purpose_type,\n      summary,\n    });\n  }\n\n  return summaries;\n}\n\n/**\n * Generates an overall summary for an entire conversation.\n *\n * @param {string} conversationId - The conversation ID\n * @returns {Promise<string>} The generated summary\n */\nexport async function summarizeConversation(conversationId) {\n  // 1. Fetch all messages for the conversation, ordered by timestamp ASC\n  const query = `\n    SELECT role, content FROM conversation_history\n    WHERE conversation_id = ?\n    ORDER BY timestamp ASC\n  `;\n  const messages = await executeQuery(query, [conversationId]);\n\n  // Check if results has a rows property and it's an array\n  if (\n    !messages ||\n    !messages.rows ||\n    !Array.isArray(messages.rows) ||\n    messages.rows.length === 0\n  ) {\n    logMessage(\n      \"warn\",\n      `No valid messages found for conversation ${conversationId}`\n    );\n    return \"\";\n  }\n\n  // 2. Concatenate messages as 'role: content' lines\n  const concatenated = messages.rows\n    .map((m) => `${m.role}: ${m.content}`)\n    .join(\"\\n\");\n\n  // 3. Summarize using ContextCompressorLogic\n  const summary = await ContextCompressorLogic.summarizeText(concatenated, {\n    targetLength: 250,\n    preserveKeyPoints: true,\n  });\n\n  // 4. Return the summary string\n  return summary;\n}\n\n/**\n * Initializes a new conversation in the system\n *\n * @param {string} conversationId - The conversation ID\n * @param {string} initialQuery - The initial query that started the conversation\n * @returns {Promise<void>}\n */\nexport async function initializeConversation(conversationId, initialQuery) {\n  try {\n    const timestamp = new Date().toISOString();\n    let userMessageId = null; // Define outside the if block to make it available in the scope\n\n    // First, record the user's initial query as a 'user' message\n    if (initialQuery && initialQuery.trim()) {\n      userMessageId = uuidv4();\n      const userQuery = `\n        INSERT INTO conversation_history (\n          message_id,\n          conversation_id, \n          role,\n          content,\n          timestamp,\n          related_context_entity_ids,\n          summary,\n          user_intent\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n      `;\n\n      await executeQuery(userQuery, [\n        userMessageId,\n        conversationId,\n        \"user\", // Store as user role to properly track the user's input\n        initialQuery,\n        timestamp,\n        JSON.stringify([]),\n        \"Initial user query\",\n        \"start_conversation\",\n      ]);\n\n      logMessage(\"info\", `User query recorded with ID: ${userMessageId}`);\n    }\n\n    // Then create the system message to record conversation initialization\n    const systemMessageId = uuidv4();\n    const systemQuery = `\n      INSERT INTO conversation_history (\n        message_id,\n        conversation_id, \n        role,\n        content,\n        timestamp,\n        related_context_entity_ids,\n        summary,\n        user_intent\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n    `;\n\n    await executeQuery(systemQuery, [\n      systemMessageId,\n      conversationId,\n      \"system\",\n      initialQuery ? \"Conversation started with query\" : \"Conversation started\",\n      timestamp,\n      JSON.stringify([]),\n      \"Conversation initialization\",\n      \"start_conversation\",\n    ]);\n\n    // Initialize conversation purpose based on initial query\n    if (initialQuery) {\n      await ConversationPurposeDetector.detectInitialPurpose(\n        conversationId,\n        initialQuery\n      );\n    }\n\n    // Create initial topic segment using the user message ID if available\n    const messageIdForSegment = userMessageId || systemMessageId;\n\n    await ConversationSegmenter.createNewTopicSegment(\n      conversationId,\n      messageIdForSegment,\n      {\n        name: \"Initial conversation\",\n        description: initialQuery || \"Conversation start\",\n        primaryEntities: [],\n        keywords: [],\n      }\n    );\n\n    logMessage(\"info\", `Conversation initialized with ID: ${conversationId}`);\n  } catch (error) {\n    logMessage(\"error\", \"Error initializing conversation:\", {\n      error: error.message,\n    });\n    throw new Error(\"Failed to initialize conversation: \" + error.message);\n  }\n}\n\n/**\n * Gets the conversation history for a specific conversation ID\n *\n * @param {string} conversationId - The conversation ID\n * @param {number} [limit=50] - Maximum number of messages to return\n * @param {number} [offset=0] - Offset for pagination\n * @returns {Promise<Array>} Array of message objects\n */\nexport async function getConversationHistory(\n  conversationId,\n  limit = 50,\n  offset = 0\n) {\n  try {\n    if (!conversationId) {\n      throw new Error(\"Conversation ID is required\");\n    }\n\n    const query = `\n      SELECT \n        message_id,\n        conversation_id,\n        role,\n        content,\n        timestamp,\n        related_context_entity_ids,\n        summary,\n        user_intent,\n        topic_segment_id,\n        semantic_markers,\n        sentiment_indicators\n      FROM \n        conversation_history\n      WHERE \n        conversation_id = ?\n      ORDER BY \n        timestamp ASC\n      LIMIT ? OFFSET ?\n    `;\n\n    const results = await executeQuery(query, [conversationId, limit, offset]);\n\n    // Check if results has a rows property and it's an array\n    if (!results || !results.rows || !Array.isArray(results.rows)) {\n      logMessage(\n        \"warn\",\n        \"No valid rows returned from conversation history query\"\n      );\n      return [];\n    }\n\n    // Parse JSON fields\n    return results.rows.map((message) => {\n      try {\n        // Map database column names to camelCase property names for API consistency\n        const mappedMessage = {\n          messageId: message.message_id,\n          conversationId: message.conversation_id,\n          role: message.role,\n          content: message.content,\n          timestamp: message.timestamp,\n          relatedContextEntityIds: [],\n          summary: message.summary,\n          userIntent: message.user_intent,\n          topicSegmentId: message.topic_segment_id,\n          semanticMarkers: [],\n          sentimentIndicators: {},\n        };\n\n        if (message.related_context_entity_ids) {\n          mappedMessage.relatedContextEntityIds = JSON.parse(\n            message.related_context_entity_ids\n          );\n        }\n\n        if (message.semantic_markers) {\n          mappedMessage.semanticMarkers = JSON.parse(message.semantic_markers);\n        }\n\n        if (message.sentiment_indicators) {\n          mappedMessage.sentimentIndicators = JSON.parse(\n            message.sentiment_indicators\n          );\n        }\n\n        return mappedMessage;\n      } catch (err) {\n        logMessage(\n          \"error\",\n          \"Error parsing JSON fields in conversation message:\"\n        );\n        logMessage(\"error\", err);\n        return {\n          messageId: message.message_id,\n          conversationId: message.conversation_id,\n          role: message.role,\n          content: message.content,\n          timestamp: message.timestamp,\n          relatedContextEntityIds: [],\n          summary: message.summary,\n          userIntent: message.user_intent,\n          topicSegmentId: message.topic_segment_id,\n          semanticMarkers: [],\n          sentimentIndicators: {},\n        };\n      }\n    });\n  } catch (error) {\n    logMessage(\n      \"error\",\n      `Error getting conversation history for ${conversationId}:`\n    );\n    logMessage(\"error\", error);\n    return [];\n  }\n}\n\n/**\n * Gets the current purpose of a conversation\n *\n * @param {string} conversationId - The ID of the conversation\n * @returns {Promise<{purposeType: string, confidence: number, startTimestamp: string}>} The conversation purpose information\n */\nexport async function getConversationPurpose(conversationId) {\n  try {\n    if (!conversationId) {\n      throw new Error(\"Conversation ID is required\");\n    }\n\n    // Use the ConversationPurposeDetector to get the active purpose\n    const activePurpose = await ConversationPurposeDetector.getActivePurpose(\n      conversationId\n    );\n\n    if (!activePurpose) {\n      // Default response if no purpose is detected\n      return {\n        purposeType: \"general_query\",\n        confidence: 0.5,\n        startTimestamp: new Date().toISOString(),\n      };\n    }\n\n    return activePurpose;\n  } catch (error) {\n    logMessage(\n      \"error\",\n      `Error getting conversation purpose for ${conversationId}:`\n    );\n    logMessage(\"error\", error);\n\n    // Default response in case of error\n    return {\n      purposeType: \"general_query\",\n      confidence: 0.5,\n      startTimestamp: new Date().toISOString(),\n    };\n  }\n}\n\n/**\n * Gets the most recent messages for a conversation\n *\n * @param {string} conversationId - The conversation ID\n * @param {number} [count=5] - Number of most recent messages to return\n * @returns {Promise<Array>} Array of the most recent message objects\n */\nexport async function getRecentMessages(conversationId, count = 5) {\n  try {\n    if (!conversationId) {\n      throw new Error(\"Conversation ID is required\");\n    }\n\n    const query = `\n      SELECT \n        message_id,\n        conversation_id,\n        role,\n        content,\n        timestamp,\n        related_context_entity_ids,\n        summary,\n        user_intent,\n        topic_segment_id,\n        semantic_markers,\n        sentiment_indicators\n      FROM \n        conversation_history\n      WHERE \n        conversation_id = ?\n      ORDER BY \n        timestamp DESC\n      LIMIT ?\n    `;\n\n    const results = await executeQuery(query, [conversationId, count]);\n\n    // Check if results has a rows property and it's an array\n    if (!results || !results.rows || !Array.isArray(results.rows)) {\n      logMessage(\"warn\", \"No valid rows returned from recent messages query\");\n      return [];\n    }\n\n    // Parse JSON fields using the same mapping as getConversationHistory\n    return results.rows.map((message) => {\n      try {\n        // Map database column names to camelCase property names for API consistency\n        const mappedMessage = {\n          messageId: message.message_id,\n          conversationId: message.conversation_id,\n          role: message.role,\n          content: message.content,\n          timestamp: message.timestamp,\n          relatedContextEntityIds: [],\n          summary: message.summary,\n          userIntent: message.user_intent,\n          topicSegmentId: message.topic_segment_id,\n          semanticMarkers: [],\n          sentimentIndicators: {},\n        };\n\n        if (message.related_context_entity_ids) {\n          mappedMessage.relatedContextEntityIds = JSON.parse(\n            message.related_context_entity_ids\n          );\n        }\n\n        if (message.semantic_markers) {\n          mappedMessage.semanticMarkers = JSON.parse(message.semantic_markers);\n        }\n\n        if (message.sentiment_indicators) {\n          mappedMessage.sentimentIndicators = JSON.parse(\n            message.sentiment_indicators\n          );\n        }\n\n        return mappedMessage;\n      } catch (err) {\n        logMessage(\n          \"error\",\n          \"Error parsing JSON fields in conversation message:\"\n        );\n        logMessage(\"error\", err);\n        return {\n          messageId: message.message_id,\n          conversationId: message.conversation_id,\n          role: message.role,\n          content: message.content,\n          timestamp: message.timestamp,\n          relatedContextEntityIds: [],\n          summary: message.summary,\n          userIntent: message.user_intent,\n          topicSegmentId: message.topic_segment_id,\n          semanticMarkers: [],\n          sentimentIndicators: {},\n        };\n      }\n    });\n  } catch (error) {\n    logMessage(\"error\", `Error getting recent messages for ${conversationId}:`);\n    logMessage(\"error\", error);\n    return [];\n  }\n}\n", "/**\n * ContextIndexerLogic.js\n *\n * Provides functions for indexing code files and extracting structured information\n * about code entities and their relationships.\n */\n\nimport { v4 as uuidv4 } from \"uuid\";\nimport crypto from \"crypto\";\nimport path from \"path\";\nimport * as acorn from \"acorn\";\nimport { executeQuery } from \"../db.js\";\nimport { tokenize, extractKeywords } from \"./TextTokenizerLogic.js\";\nimport { addRelationship } from \"./RelationshipContextManagerLogic.js\";\nimport { buildAST } from \"./CodeStructureAnalyzerLogic.js\";\nimport { calculateImportanceScore } from \"./ContextPrioritizerLogic.js\";\nimport { logMessage } from \"../utils/logger.js\";\n\n/**\n * Calculate SHA-256 hash of content\n *\n * @param {string} content - Content to hash\n * @returns {string} SHA-256 hash as hex string\n */\nfunction calculateContentHash(content) {\n  return crypto.createHash(\"sha256\").update(content).digest(\"hex\");\n}\n\n/**\n * Extract filename from path\n *\n * @param {string} filePath - Path to file\n * @returns {string} Filename without directory\n */\nfunction extractFilename(filePath) {\n  return path.basename(filePath);\n}\n\n/**\n * Detect language from file extension if not provided\n *\n * @param {string} filePath - Path to file\n * @param {string} languageHint - Language hint\n * @returns {string} Detected language\n */\nfunction detectLanguage(filePath, languageHint) {\n  if (languageHint) {\n    return languageHint.toLowerCase();\n  }\n\n  const extension = path.extname(filePath).toLowerCase();\n\n  const extensionMap = {\n    \".js\": \"javascript\",\n    \".jsx\": \"javascript\",\n    \".ts\": \"typescript\",\n    \".tsx\": \"typescript\",\n    \".py\": \"python\",\n    \".rb\": \"ruby\",\n    \".java\": \"java\",\n    \".go\": \"go\",\n    \".rs\": \"rust\",\n    \".php\": \"php\",\n    \".c\": \"c\",\n    \".cpp\": \"cpp\",\n    \".h\": \"c\",\n    \".hpp\": \"cpp\",\n    \".cs\": \"csharp\",\n    \".swift\": \"swift\",\n    \".kt\": \"kotlin\",\n    \".html\": \"html\",\n    \".css\": \"css\",\n    \".scss\": \"scss\",\n    \".json\": \"json\",\n    \".md\": \"markdown\",\n    \".xml\": \"xml\",\n    \".yaml\": \"yaml\",\n    \".yml\": \"yaml\",\n  };\n\n  return extensionMap[extension] || \"unknown\";\n}\n\n/**\n * Extract line number from character position\n *\n * @param {string} content - File content\n * @param {number} position - Character position\n * @returns {number} Line number\n */\nfunction getLineFromPosition(content, position) {\n  const lines = content.substring(0, position).split(\"\\n\");\n  return lines.length;\n}\n\n/**\n * Extract code entities using regex for languages without AST support\n *\n * @param {string} content - File content\n * @param {string} language - Language of the file\n * @returns {Array} Extracted entities\n */\nfunction extractEntitiesWithRegex(content, language) {\n  const entities = [];\n\n  // Common patterns for different languages\n  const patterns = {\n    // Function patterns\n    function: {\n      python: /def\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\([^)]*\\)\\s*:/g,\n      ruby: /def\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*(\\([^)]*\\))?\\s*(do|\\n)/g,\n      java: /(public|private|protected|static|\\s) +[\\w\\<\\>\\[\\]]+\\s+(\\w+) *\\([^\\)]*\\) *(\\{?|[^;])/g,\n      go: /func\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\([^)]*\\)\\s*(?:\\([^)]*\\))?\\s*\\{/g,\n      php: /function\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\([^)]*\\)\\s*\\{/g,\n      default: /function\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\([^)]*\\)\\s*\\{/g,\n    },\n    // Class patterns\n    class: {\n      python: /class\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*(\\([^)]*\\))?\\s*:/g,\n      ruby: /class\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*((<|::)\\s*[A-Za-z0-9_:]*)?/g,\n      java: /class\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*(extends\\s+[A-Za-z0-9_]+)?\\s*(implements\\s+[A-Za-z0-9_,\\s]+)?\\s*\\{/g,\n      go: /type\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s+struct\\s*\\{/g,\n      php: /class\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*(extends\\s+[A-Za-z0-9_]+)?\\s*(implements\\s+[A-Za-z0-9_,\\s]+)?\\s*\\{/g,\n      default:\n        /class\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*(extends\\s+[A-Za-z0-9_]+)?\\s*\\{/g,\n    },\n    // Variable/constant patterns\n    variable: {\n      python: /(^|\\s)([a-zA-Z_][a-zA-Z0-9_]*)\\s*=\\s*(?!==)/g,\n      ruby: /(^|\\s)([a-zA-Z_][a-zA-Z0-9_]*)\\s*=\\s*(?!=)/g,\n      java: /(private|protected|public|static|\\s) +[\\w\\<\\>\\[\\]]+\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*=\\s*[^;]+;/g,\n      go: /var\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s+[\\w\\[\\]]+(\\s*=\\s*[^;]+)?/g,\n      php: /(\\$[a-zA-Z_][a-zA-Z0-9_]*)\\s*=\\s*(?!=)/g,\n      default: /(const|let|var)\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*=\\s*[^;]+;/g,\n    },\n  };\n\n  // Extract functions\n  const functionPattern =\n    patterns.function[language] || patterns.function.default;\n  let match;\n  while ((match = functionPattern.exec(content)) !== null) {\n    const name = match[1] || match[2]; // Some patterns capture name in different groups\n    const startPosition = match.index;\n\n    // Find the end of the function\n    // This is a simplification - would need language-specific logic for accurate ending\n    const startLine = getLineFromPosition(content, startPosition);\n    let endLine = startLine + 10; // Assume small functions for simplicity\n\n    entities.push({\n      type: \"function\",\n      name,\n      start_position: startPosition,\n      start_line: startLine,\n      end_line: endLine, // Approximation\n      raw_content: content.substring(\n        startPosition,\n        startPosition + match[0].length + 100\n      ), // Approximate content\n    });\n  }\n\n  // Extract classes with similar approach\n  const classPattern = patterns.class[language] || patterns.class.default;\n  while ((match = classPattern.exec(content)) !== null) {\n    const name = match[1];\n    const startPosition = match.index;\n    const startLine = getLineFromPosition(content, startPosition);\n    let endLine = startLine + 20; // Assume larger for classes\n\n    entities.push({\n      type: \"class\",\n      name,\n      start_position: startPosition,\n      start_line: startLine,\n      end_line: endLine, // Approximation\n      raw_content: content.substring(\n        startPosition,\n        startPosition + match[0].length + 500\n      ), // Approximate content\n    });\n  }\n\n  // Could continue with variables, methods, etc.\n\n  return entities;\n}\n\n/**\n * Extract code entities from JavaScript/TypeScript AST\n *\n * @param {Object} ast - Abstract Syntax Tree\n * @param {string} content - File content\n * @returns {Object} Extracted entities and relationships\n */\nfunction extractEntitiesFromAST(ast, content) {\n  // Check if we're in MCP mode - control logging\n  const inMcpMode = process.env.MCP_MODE === \"true\";\n\n  const entities = [];\n  const relationships = [];\n  const idMap = new Map(); // Maps node to entity for relationship tracking\n  const lines = content.split(\"\\n\");\n\n  if (!ast || ast.error) {\n    if (!inMcpMode) {\n      logMessage(\"warn\", \"Invalid AST provided to extractEntitiesFromAST\", {\n        error: ast && ast.error ? ast.message : \"No AST provided\",\n      });\n    }\n    return { entities, relationships };\n  }\n\n  function createEntity(\n    type,\n    name,\n    startPosition,\n    endPosition,\n    startLine,\n    endLine,\n    rawContent,\n    parentEntity = null,\n    customMetadata = {}\n  ) {\n    const entity = {\n      type,\n      name,\n      start_position: startPosition,\n      end_position: endPosition,\n      start_line: startLine,\n      end_line: endLine,\n      raw_content: rawContent,\n      parent: parentEntity,\n      custom_metadata: customMetadata,\n    };\n\n    entities.push(entity);\n\n    // Log entity extraction in non-MCP mode\n    if (!inMcpMode) {\n      logMessage(\"debug\", `Extracted ${type} entity: ${name}`, {\n        lines: `${startLine}-${endLine}`,\n        size: rawContent.length,\n      });\n    }\n\n    return entity;\n  }\n\n  function visit(node, parentNode = null, parentEntity = null, scope = null) {\n    if (!node || typeof node !== \"object\") return;\n\n    // Track current scope for nested entities\n    let currentScope = scope;\n\n    // Process node based on type\n    switch (node.type) {\n      case \"Program\":\n        // Process each statement in the program body\n        if (node.body && Array.isArray(node.body)) {\n          node.body.forEach((stmt) =>\n            visit(stmt, node, parentEntity, \"global\")\n          );\n        }\n        break;\n\n      case \"FunctionDeclaration\":\n        {\n          const name = node.id ? node.id.name : \"anonymous\";\n          const startLine = node.loc.start.line;\n          const endLine = node.loc.end.line;\n          const startPosition = node.start;\n          const endPosition = node.end;\n          const rawContent = content.substring(startPosition, endPosition);\n\n          // Get function params\n          const params = node.params.map((p) => p.name || \"unnamed\");\n\n          // Create function entity\n          const functionEntity = createEntity(\n            \"function\",\n            name,\n            startPosition,\n            endPosition,\n            startLine,\n            endLine,\n            rawContent,\n            parentEntity,\n            { params }\n          );\n\n          // Create relationship to parent if exists\n          if (parentEntity) {\n            relationships.push({\n              source: parentEntity,\n              target: functionEntity,\n              type: \"contains\",\n            });\n          }\n\n          // Process function body with this function as parent\n          if (node.body) {\n            visit(node.body, node, functionEntity, name);\n          }\n        }\n        break;\n\n      case \"ClassDeclaration\":\n      case \"ClassExpression\":\n        {\n          const name = node.id ? node.id.name : \"AnonymousClass\";\n          const startLine = node.loc.start.line;\n          const endLine = node.loc.end.line;\n          const startPosition = node.start;\n          const endPosition = node.end;\n          const rawContent = content.substring(startPosition, endPosition);\n\n          // Create class entity\n          const classEntity = createEntity(\n            \"class\",\n            name,\n            startPosition,\n            endPosition,\n            startLine,\n            endLine,\n            rawContent,\n            parentEntity\n          );\n\n          // Create relationship to parent if exists\n          if (parentEntity) {\n            relationships.push({\n              source: parentEntity,\n              target: classEntity,\n              type: \"contains\",\n            });\n          }\n\n          // Process class body with this class as parent\n          if (node.body && node.body.body) {\n            node.body.body.forEach((member) => {\n              visit(member, node, classEntity, name);\n            });\n          }\n        }\n        break;\n\n      case \"MethodDefinition\":\n        {\n          const name = node.key.name || node.key.value || \"unnamed\";\n          const startLine = node.loc.start.line;\n          const endLine = node.loc.end.line;\n          const startPosition = node.start;\n          const endPosition = node.end;\n          const rawContent = content.substring(startPosition, endPosition);\n\n          // Create method entity\n          const methodEntity = createEntity(\n            \"method\",\n            name,\n            startPosition,\n            endPosition,\n            startLine,\n            endLine,\n            rawContent,\n            parentEntity,\n            { kind: node.kind } // constructor, method, get/set\n          );\n\n          // Create relationship to parent class\n          if (parentEntity) {\n            relationships.push({\n              source: parentEntity,\n              target: methodEntity,\n              type: \"contains\",\n            });\n          }\n\n          // Process method body with this method as parent\n          if (node.value && node.value.body) {\n            visit(node.value.body, node, methodEntity, `${scope}.${name}`);\n          }\n        }\n        break;\n\n      case \"ArrowFunctionExpression\":\n      case \"FunctionExpression\":\n        {\n          // Only create entities for named function expressions or arrow functions assigned to variables\n          if (\n            parentNode &&\n            (parentNode.type === \"VariableDeclarator\" ||\n              parentNode.type === \"AssignmentExpression\")\n          ) {\n            let name = \"anonymous\";\n\n            // Try to determine name from parent\n            if (parentNode.id && parentNode.id.name) {\n              name = parentNode.id.name;\n            } else if (parentNode.left && parentNode.left.name) {\n              name = parentNode.left.name;\n            }\n\n            const startLine = node.loc.start.line;\n            const endLine = node.loc.end.line;\n            const startPosition = node.start;\n            const endPosition = node.end;\n            const rawContent = content.substring(startPosition, endPosition);\n\n            // Create function entity\n            const functionEntity = createEntity(\n              \"function\",\n              name,\n              startPosition,\n              endPosition,\n              startLine,\n              endLine,\n              rawContent,\n              parentEntity\n            );\n\n            // Process function body with this function as parent\n            if (node.body) {\n              visit(node.body, node, functionEntity, name);\n            }\n          } else {\n            // For anonymous functions, just process the body without creating an entity\n            if (node.body) {\n              visit(node.body, node, parentEntity, scope);\n            }\n          }\n        }\n        break;\n\n      case \"BlockStatement\":\n        // Process each statement in the block\n        if (node.body && Array.isArray(node.body)) {\n          node.body.forEach((stmt) => visit(stmt, node, parentEntity, scope));\n        }\n        break;\n\n      // Handle variable declarations which might contain functions or classes\n      case \"VariableDeclaration\":\n        if (node.declarations) {\n          node.declarations.forEach((decl) =>\n            visit(decl, node, parentEntity, scope)\n          );\n        }\n        break;\n\n      case \"VariableDeclarator\":\n        // Process initializer, which might be a function/class expression\n        if (node.init) {\n          visit(node.init, node, parentEntity, scope);\n        }\n        break;\n\n      case \"ExportNamedDeclaration\":\n      case \"ExportDefaultDeclaration\":\n        // Process the exported declaration\n        if (node.declaration) {\n          visit(node.declaration, node, parentEntity, scope);\n        }\n        break;\n\n      default:\n        // For other node types, just traverse their children\n        for (const key in node) {\n          if (node.hasOwnProperty(key)) {\n            const child = node[key];\n            if (child && typeof child === \"object\") {\n              if (Array.isArray(child)) {\n                child.forEach((item) => visit(item, node, parentEntity, scope));\n              } else {\n                visit(child, node, parentEntity, scope);\n              }\n            }\n          }\n        }\n        break;\n    }\n  }\n\n  // Start traversal from the root\n  visit(ast);\n\n  return { entities, relationships };\n}\n\n/**\n * Stores file and its code entities in the database\n *\n * @param {string} filePath - Path to the file\n * @param {string} fileContent - Content of the file\n * @param {string} languageHint - Programming language hint\n * @returns {Promise<void>}\n */\nexport async function indexCodeFile(filePath, fileContent, languageHint) {\n  try {\n    // Check if we're in MCP mode - never log in MCP mode\n    const inMcpMode = process.env.MCP_MODE === \"true\";\n\n    if (!inMcpMode) {\n      logMessage(\"info\", `Indexing code file ${filePath}`);\n    }\n\n    // Calculate content hash\n    const contentHash = calculateContentHash(fileContent);\n\n    // Extract filename\n    const filename = extractFilename(filePath);\n\n    // Detect or use provided language\n    const language = detectLanguage(filePath, languageHint);\n\n    // Check if file already exists\n    const existingFile = await executeQuery(\n      `SELECT entity_id, content_hash FROM code_entities WHERE file_path = ? AND entity_type = 'file'`,\n      [filePath]\n    );\n\n    // Initialize file entity ID\n    let fileEntityId;\n\n    // Update or create file entity\n    if (existingFile.rows && existingFile.rows.length > 0) {\n      fileEntityId = existingFile.rows[0].entity_id;\n\n      // Skip indexing if content hash matches\n      if (existingFile[0].content_hash === contentHash) {\n        logMessage(\"info\", `File ${filePath} is unchanged, skipping indexing`);\n        return fileEntityId;\n      }\n\n      // Update existing file entity\n      await executeQuery(\n        `\n        UPDATE code_entities SET\n          raw_content = ?,\n          content_hash = ?,\n          language = ?,\n          last_modified_at = CURRENT_TIMESTAMP\n        WHERE entity_id = ?\n      `,\n        [fileContent, contentHash, language, fileEntityId]\n      );\n\n      // Delete existing sub-entities for re-indexing\n      await executeQuery(\n        `\n        DELETE FROM code_entities\n        WHERE parent_entity_id = ?\n      `,\n        [fileEntityId]\n      );\n    } else {\n      // Create a new file entity\n      fileEntityId = uuidv4();\n\n      // Calculate importance score for the file entity\n      let importanceScore = 1.0; // Default score\n      try {\n        importanceScore = await calculateImportanceScore({\n          entity_id: fileEntityId,\n          entity_type: \"file\",\n          file_path: filePath,\n          name: filename,\n          raw_content: fileContent,\n          language: language,\n        });\n      } catch (scoreError) {\n        if (!inMcpMode) {\n          logMessage(\n            \"warn\",\n            `Error calculating importance score for ${filePath}: ${scoreError.message}`\n          );\n        }\n      }\n\n      await executeQuery(\n        `\n        INSERT INTO code_entities (\n          entity_id,\n          file_path,\n          entity_type,\n          name,\n          content_hash,\n          raw_content,\n          language,\n          importance_score\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n      `,\n        [\n          fileEntityId,\n          filePath,\n          \"file\",\n          filename,\n          contentHash,\n          fileContent,\n          language,\n          importanceScore,\n        ]\n      );\n    }\n\n    // Process file content based on language\n    let codeEntities = [];\n    let relationships = [];\n\n    // Language-specific processing\n    if (language === \"javascript\" || language === \"typescript\") {\n      try {\n        // Parse content using Acorn or a similar parser\n        const ast = buildAST(fileContent, language);\n        const { entities, entityRelationships } = extractEntitiesFromAST(\n          ast,\n          fileContent\n        );\n        codeEntities = entities;\n        relationships = entityRelationships;\n      } catch (parseError) {\n        if (!inMcpMode) {\n          logMessage(\n            \"warn\",\n            `Error parsing ${language} file ${filePath}: ${parseError.message}`\n          );\n          // Fallback to regex for basic extraction on parse error\n          codeEntities = extractEntitiesWithRegex(fileContent, language);\n        }\n      }\n    } else {\n      // For other languages, use regex extraction\n      codeEntities = extractEntitiesWithRegex(fileContent, language);\n    }\n\n    // Save extracted entities and relationships to database\n    for (const entity of codeEntities) {\n      const entityId = uuidv4();\n      entity.id = entityId;\n\n      // Calculate importance score for the entity\n      let importanceScore = 1.0; // Default score\n      try {\n        // Create a proper entity object for scoring\n        const entityForScoring = {\n          entity_id: entityId,\n          entity_type: entity.type,\n          file_path: filePath,\n          name: entity.name,\n          raw_content: entity.raw_content,\n          start_line: entity.start_line,\n          end_line: entity.end_line,\n          language: language,\n          parent_entity_id: fileEntityId,\n        };\n\n        importanceScore = await calculateImportanceScore(entityForScoring);\n      } catch (scoreError) {\n        if (!inMcpMode) {\n          logMessage(\n            \"warn\",\n            `Error calculating importance score for entity ${entity.name}: ${scoreError.message}`\n          );\n        }\n      }\n\n      // Generate summary for the entity\n      let summary = null;\n      try {\n        // Import dynamically to avoid circular dependencies\n        const { summarizeCodeEntity } = await import(\n          \"./ContextCompressorLogic.js\"\n        );\n\n        // Create entity object for summarization - must include necessary properties\n        const entityForSummary = {\n          entity_type: entity.type,\n          name: entity.name,\n          raw_content: entity.raw_content,\n        };\n\n        // Generate summary with a reasonable character limit (increased from 500 to 1000)\n        summary = summarizeCodeEntity(entityForSummary, 1000);\n\n        // Log summary generation for debugging (only in non-MCP mode)\n        if (!inMcpMode && summary) {\n          logMessage(\n            \"debug\",\n            `Generated summary for ${entity.type} '${entity.name}' (${summary.length} chars)`\n          );\n        }\n      } catch (summaryError) {\n        if (!inMcpMode) {\n          logMessage(\n            \"warn\",\n            `Error generating summary for entity ${entity.name}: ${summaryError.message}`\n          );\n        }\n        // Continue without a summary\n      }\n\n      // Save entity to database\n      await executeQuery(\n        `\n        INSERT INTO code_entities (\n          entity_id,\n          parent_entity_id,\n          file_path,\n          entity_type,\n          name,\n          start_line,\n          end_line,\n          raw_content,\n          language,\n          summary,\n          importance_score\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `,\n        [\n          entityId,\n          fileEntityId,\n          filePath,\n          entity.type,\n          entity.name,\n          entity.start_line,\n          entity.end_line,\n          entity.raw_content,\n          language,\n          summary,\n          importanceScore,\n        ]\n      );\n\n      // Extract keywords for the entity\n      try {\n        const keywords = extractKeywords(entity.raw_content);\n\n        // Save keywords\n        for (const keyword of keywords) {\n          await executeQuery(\n            `\n            INSERT INTO entity_keywords (\n              entity_id,\n              keyword,\n              term_frequency,\n              keyword_type\n            ) VALUES (?, ?, ?, ?)\n            ON CONFLICT(entity_id, keyword, keyword_type) DO UPDATE SET\n              term_frequency = excluded.term_frequency\n          `,\n            [entityId, keyword.term, keyword.frequency, \"extracted\"]\n          );\n        }\n      } catch (keywordError) {\n        if (!inMcpMode) {\n          logMessage(\n            \"warn\",\n            `Error extracting keywords for ${entity.name}: ${keywordError.message}`\n          );\n        }\n        // Continue despite keyword extraction errors\n      }\n    }\n\n    // Save relationships\n    for (const rel of relationships) {\n      try {\n        if (rel.source && rel.target) {\n          await addRelationship(\n            rel.source.id,\n            rel.target.id,\n            rel.type,\n            rel.metadata\n          );\n        }\n      } catch (relError) {\n        if (!inMcpMode) {\n          logMessage(\"warn\", `Error saving relationship: ${relError.message}`);\n        }\n        // Continue despite relationship errors\n      }\n    }\n\n    return fileEntityId;\n  } catch (error) {\n    if (process.env.MCP_MODE === \"true\") {\n      throw new Error(); // Empty error in MCP mode to prevent logging\n    } else {\n      throw new Error(`Error indexing file ${filePath}: ${error.message}`);\n    }\n  }\n}\n\n/**\n * Message object type definition\n * @typedef {Object} MessageObject\n * @property {string} messageId - Unique identifier for the message\n * @property {string} conversationId - ID of the conversation this message belongs to\n * @property {string} role - Role of the message sender (e.g., 'user', 'assistant')\n * @property {string} content - Content of the message\n * @property {Date} timestamp - When the message was sent\n * @property {string[]} [relatedContextEntityIds] - IDs of related code entities\n * @property {string} [summary] - Summary of the message content\n * @property {string} [userIntent] - Inferred user intent\n * @property {string} [topicSegmentId] - ID of topic segment this message belongs to\n * @property {string[]} [semanticMarkers] - Semantic markers for enhanced retrieval\n * @property {Object} [sentimentIndicators] - Sentiment analysis results\n */\n\n/**\n * Indexes a conversation message for later retrieval\n *\n * @param {MessageObject} message - Message object to index\n * @returns {Promise<void>}\n */\nexport async function indexConversationMessage(message) {\n  try {\n    logMessage(\"debug\", \"===== INDEX MESSAGE - START =====\");\n    logMessage(\"debug\", \"Input parameters:\", {\n      message_id: message.message_id,\n      conversation_id: message.conversation_id,\n      role: message.role,\n      content_length: message.content ? message.content.length : 0,\n      timestamp: message.timestamp,\n    });\n\n    // Validate required message properties\n    if (\n      !message.message_id ||\n      !message.conversation_id ||\n      !message.role ||\n      !message.content\n    ) {\n      throw new Error(\"Message object missing required properties\");\n    }\n\n    // Convert arrays and objects to JSON strings for storage\n    const relatedContextEntityIds = message.relatedContextEntityIds\n      ? message.relatedContextEntityIds\n      : null;\n\n    const semanticMarkers = message.semantic_markers\n      ? message.semantic_markers\n      : null;\n\n    const sentimentIndicators = message.sentiment_indicators\n      ? message.sentiment_indicators\n      : null;\n\n    // Format timestamp\n    const timestamp =\n      message.timestamp instanceof Date\n        ? message.timestamp.toISOString()\n        : message.timestamp || new Date().toISOString();\n\n    // Check if message already exists\n    const existingMessageQuery = `\n      SELECT message_id FROM conversation_history \n      WHERE message_id = ?\n    `;\n\n    logMessage(\"debug\", \"Checking if message exists:\", {\n      message_id: message.message_id,\n    });\n    const existingMessage = await executeQuery(existingMessageQuery, [\n      message.message_id,\n    ]);\n\n    logMessage(\"debug\", \"Existing message check result:\", {\n      result: JSON.stringify(existingMessage),\n    });\n\n    if (\n      existingMessage &&\n      existingMessage.rows &&\n      existingMessage.rows.length > 0\n    ) {\n      logMessage(\"debug\", \"Updating existing message:\", {\n        message_id: message.message_id,\n      });\n      // Update existing message\n      try {\n        const updateQuery = `UPDATE conversation_history \n         SET content = ?, \n             summary = ?, \n             user_intent = ?, \n             topic_segment_id = ?, \n             related_context_entity_ids = ?, \n             semantic_markers = ?, \n             sentiment_indicators = ?\n         WHERE message_id = ?`;\n\n        const updateParams = [\n          message.content,\n          message.summary || null,\n          message.userIntent || null,\n          message.topicSegmentId || null,\n          relatedContextEntityIds,\n          semanticMarkers,\n          sentimentIndicators,\n          message.message_id,\n        ];\n\n        logMessage(\"debug\", \"Update query parameters:\", {\n          message_id: message.message_id,\n          content_length: message.content ? message.content.length : 0,\n        });\n\n        const updateResult = await executeQuery(updateQuery, updateParams);\n        logMessage(\"debug\", \"Message update result:\", {\n          result: JSON.stringify(updateResult),\n        });\n      } catch (updateError) {\n        logMessage(\"error\", \"Update error:\", { error: updateError });\n        throw updateError;\n      }\n    } else {\n      logMessage(\"debug\", \"Inserting new message:\", {\n        message_id: message.message_id,\n      });\n      // Insert new message\n      try {\n        const insertQuery = `INSERT INTO conversation_history (\n          message_id, \n          conversation_id, \n          role, \n          content, \n          timestamp, \n          summary, \n          user_intent, \n          topic_segment_id, \n          related_context_entity_ids, \n          semantic_markers, \n          sentiment_indicators\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;\n\n        const insertParams = [\n          message.message_id,\n          message.conversation_id,\n          message.role,\n          message.content,\n          timestamp,\n          message.summary || null,\n          message.userIntent || null,\n          message.topicSegmentId || null,\n          relatedContextEntityIds,\n          semanticMarkers,\n          sentimentIndicators,\n        ];\n\n        logMessage(\"debug\", \"Insert query parameters:\", {\n          message_id: message.message_id,\n          conversation_id: message.conversation_id,\n          role: message.role,\n          timestamp: timestamp,\n        });\n\n        const insertResult = await executeQuery(insertQuery, insertParams);\n        logMessage(\"debug\", \"Message insert result:\", {\n          result: JSON.stringify(insertResult),\n        });\n      } catch (insertError) {\n        logMessage(\"error\", \"Insert error:\", { error: insertError });\n        logMessage(\"error\", \"Error stack:\", { stack: insertError.stack });\n        throw insertError;\n      }\n    }\n\n    // Process message content for keywords\n    const tokens = tokenize(message.content);\n    const keywords = extractKeywords(tokens);\n\n    logMessage(\"debug\", \"===== INDEX MESSAGE - COMPLETE =====\");\n    logMessage(\"info\", \"Successfully indexed message:\", {\n      message_id: message.message_id,\n    });\n\n    return {\n      messageId: message.message_id,\n      keywords: keywords,\n    };\n  } catch (error) {\n    logMessage(\"error\", \"===== INDEX MESSAGE - ERROR =====\");\n    logMessage(\"error\", `Error indexing message ${message?.message_id}:`, {\n      error: error.message,\n    });\n    logMessage(\"error\", \"Error stack:\", { stack: error.stack });\n    throw error;\n  }\n}\n", "/**\n * CodeStructureAnalyzerLogic.js\n *\n * Provides code structure analysis capabilities by parsing code into an AST\n * (Abstract Syntax Tree) for further analysis and understanding.\n */\n\nimport * as acorn from \"acorn\";\nimport { executeQuery } from \"../db.js\";\nimport { logMessage } from \"../utils/logger.js\";\n\n/**\n * Builds an abstract syntax tree (AST) from code content\n *\n * @param {string} content - The code content to parse\n * @param {string} language - The programming language of the code\n * @returns {Promise<Object|null>} The AST node (for JS/TS) or null for unsupported languages\n */\nexport async function buildAST(content, language) {\n  // Check if we're in MCP mode - control logging\n  const inMcpMode = process.env.MCP_MODE === \"true\";\n\n  // Handle empty content\n  if (!content || content.trim() === \"\") {\n    if (!inMcpMode) {\n      logMessage(\"warn\", \"Empty code content provided to buildAST\");\n    }\n    return null;\n  }\n\n  // Normalize language to lowercase\n  const normalizedLanguage = language ? language.toLowerCase() : \"unknown\";\n\n  // Handle JavaScript and TypeScript parsing with acorn\n  if (\n    [\"javascript\", \"typescript\", \"js\", \"ts\", \"jsx\", \"tsx\"].includes(\n      normalizedLanguage\n    )\n  ) {\n    try {\n      // Configure acorn parser options\n      const options = {\n        ecmaVersion: \"latest\",\n        sourceType: \"module\",\n        locations: true,\n        ranges: true,\n        // Enable JSX parsing if the language includes 'jsx' or 'tsx'\n        allowAwaitOutsideFunction: true,\n        allowImportExportEverywhere: true,\n        allowReserved: true,\n        allowReturnOutsideFunction: false,\n        allowSuperOutsideMethod: false,\n      };\n\n      // Parse the content using acorn\n      const ast = acorn.parse(content, options);\n\n      // Log successful parsing in non-MCP mode\n      if (!inMcpMode) {\n        logMessage(\"debug\", `Successfully parsed ${normalizedLanguage} code`, {\n          bodyType: ast.type,\n          bodyLength: ast.body ? ast.body.length : 0,\n        });\n      }\n\n      return ast;\n    } catch (error) {\n      if (!inMcpMode) {\n        logMessage(\"error\", `Error parsing ${normalizedLanguage} code:`, {\n          message: error.message,\n          location: error.loc\n            ? `${error.loc.line}:${error.loc.column}`\n            : \"unknown\",\n        });\n      }\n\n      // Return a structured error object instead of null\n      return {\n        error: true,\n        message: error.message,\n        location: error.loc,\n        type: \"AST_PARSE_ERROR\",\n      };\n    }\n  } else {\n    // For unsupported languages, try to use regex-based extraction\n    if (!inMcpMode) {\n      logMessage(\n        \"info\",\n        `AST generation not supported for ${normalizedLanguage}, using regex fallback`\n      );\n    }\n\n    // Return null to signal fallback to regex\n    return null;\n  }\n}\n\n/**\n * Extracts structural features from an Abstract Syntax Tree\n *\n * @param {Object} ast - The AST node (output from buildAST)\n * @returns {Object} Object containing features array and complexity number\n */\nexport function extractStructuralFeatures(ast) {\n  // Handle null or invalid AST\n  if (!ast || ast.error) {\n    return { features: [], complexity: 0 };\n  }\n\n  // Initialize the result object\n  const result = {\n    features: [],\n    complexity: 1, // Base complexity is 1\n  };\n\n  // Track maximum nesting depth\n  let maxNestingDepth = 0;\n  let currentNestingDepth = 0;\n\n  // Track visited nodes to prevent infinite recursion in case of circular references\n  const visitedNodes = new WeakSet();\n\n  // Visit function to traverse the AST\n  function visit(node, parentNode = null, currentScope = \"global\") {\n    // Skip if node is null, undefined, or already visited\n    if (!node || visitedNodes.has(node)) {\n      return;\n    }\n\n    visitedNodes.add(node);\n\n    // Skip non-object nodes (primitive values)\n    if (typeof node !== \"object\") {\n      return;\n    }\n\n    // Get line number if available\n    const line = node.loc?.start?.line;\n\n    // Process node based on its type\n    switch (node.type) {\n      // Control flow statements\n      case \"IfStatement\":\n        result.features.push({\n          type: \"control_flow\",\n          statement: \"if\",\n          line,\n          nesting: currentNestingDepth,\n        });\n        result.complexity++; // Add to cyclomatic complexity\n        break;\n\n      case \"ForStatement\":\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        result.features.push({\n          type: \"control_flow\",\n          statement: \"for\",\n          line,\n          nesting: currentNestingDepth,\n        });\n        result.complexity++; // Add to cyclomatic complexity\n        break;\n\n      case \"WhileStatement\":\n      case \"DoWhileStatement\":\n        result.features.push({\n          type: \"control_flow\",\n          statement: \"while\",\n          line,\n          nesting: currentNestingDepth,\n        });\n        result.complexity++; // Add to cyclomatic complexity\n        break;\n\n      case \"SwitchStatement\":\n        result.features.push({\n          type: \"control_flow\",\n          statement: \"switch\",\n          line,\n          nesting: currentNestingDepth,\n        });\n        // Each case adds to complexity\n        const caseCount = node.cases?.length || 0;\n        result.complexity += caseCount > 0 ? caseCount - 1 : 0;\n        break;\n\n      case \"TryStatement\":\n        result.features.push({\n          type: \"control_flow\",\n          statement: \"try\",\n          line,\n          nesting: currentNestingDepth,\n        });\n        // Catch and finally don't add to complexity, but we record them\n        break;\n\n      case \"ConditionalExpression\": // ternary operator: a ? b : c\n        result.features.push({\n          type: \"control_flow\",\n          statement: \"conditional\",\n          line,\n          nesting: currentNestingDepth,\n        });\n        result.complexity++; // Add to cyclomatic complexity\n        break;\n\n      case \"LogicalExpression\":\n        if (node.operator === \"&&\" || node.operator === \"||\") {\n          result.features.push({\n            type: \"control_flow\",\n            statement: \"logical\",\n            operator: node.operator,\n            line,\n            nesting: currentNestingDepth,\n          });\n          result.complexity++; // Logical expressions add to complexity\n        }\n        break;\n\n      // Function declarations and expressions\n      case \"FunctionDeclaration\":\n        result.features.push({\n          type: \"function_declaration\",\n          name: node.id?.name || \"anonymous\",\n          params: node.params?.length || 0,\n          line,\n          async: node.async || false,\n          generator: node.generator || false,\n        });\n        // Enter a new scope\n        currentScope = node.id?.name || \"anonymous\";\n        break;\n\n      case \"FunctionExpression\":\n      case \"ArrowFunctionExpression\":\n        result.features.push({\n          type: \"function_expression\",\n          name: node.id?.name || \"anonymous\",\n          params: node.params?.length || 0,\n          line,\n          async: node.async || false,\n          generator:\n            node.type === \"FunctionExpression\"\n              ? node.generator || false\n              : false,\n          arrow: node.type === \"ArrowFunctionExpression\",\n        });\n        // Enter an anonymous scope\n        currentScope = node.id?.name || \"anonymous\";\n        break;\n\n      // Function calls\n      case \"CallExpression\":\n        let callName = \"unknown\";\n\n        // Determine the function name being called\n        if (node.callee.type === \"Identifier\") {\n          callName = node.callee.name;\n        } else if (node.callee.type === \"MemberExpression\") {\n          // For expressions like object.method()\n          if (\n            node.callee.property &&\n            node.callee.property.type === \"Identifier\"\n          ) {\n            callName = node.callee.property.name;\n            // If we can determine the object name, include it\n            if (\n              node.callee.object &&\n              node.callee.object.type === \"Identifier\"\n            ) {\n              callName = `${node.callee.object.name}.${callName}`;\n            }\n          }\n        }\n\n        result.features.push({\n          type: \"function_call\",\n          name: callName,\n          arguments: node.arguments?.length || 0,\n          line,\n        });\n        break;\n\n      // Variable declarations\n      case \"VariableDeclaration\":\n        // Process each declarator separately\n        node.declarations.forEach((declarator) => {\n          if (declarator.id && declarator.id.type === \"Identifier\") {\n            result.features.push({\n              type: \"variable_declaration\",\n              name: declarator.id.name,\n              kind: node.kind, // 'var', 'let', or 'const'\n              scope: currentScope,\n              line,\n              initialized: declarator.init !== null,\n            });\n          }\n        });\n        break;\n\n      // Class declarations\n      case \"ClassDeclaration\":\n        result.features.push({\n          type: \"class_declaration\",\n          name: node.id?.name || \"anonymous\",\n          extends: node.superClass ? node.superClass.name || \"unknown\" : null,\n          line,\n        });\n        break;\n\n      // Import / Export statements\n      case \"ImportDeclaration\":\n        result.features.push({\n          type: \"import\",\n          source: node.source?.value,\n          line,\n        });\n        break;\n\n      case \"ExportNamedDeclaration\":\n      case \"ExportDefaultDeclaration\":\n        result.features.push({\n          type: \"export\",\n          default: node.type === \"ExportDefaultDeclaration\",\n          line,\n        });\n        break;\n    }\n\n    // Track nesting depth for block statements\n    if (node.type === \"BlockStatement\") {\n      currentNestingDepth++;\n      maxNestingDepth = Math.max(maxNestingDepth, currentNestingDepth);\n    }\n\n    // Recursively visit all child nodes\n    for (const key in node) {\n      const child = node[key];\n\n      // Skip special properties and non-AST properties\n      if (\n        key === \"type\" ||\n        key === \"loc\" ||\n        key === \"range\" ||\n        key === \"parent\" ||\n        key === \"leadingComments\" ||\n        key === \"trailingComments\"\n      ) {\n        continue;\n      }\n\n      if (Array.isArray(child)) {\n        // For arrays (like body), visit each element\n        for (const item of child) {\n          visit(item, node, currentScope);\n        }\n      } else if (child && typeof child === \"object\") {\n        // Visit child node\n        visit(child, node, currentScope);\n      }\n    }\n\n    // Decrement nesting depth when leaving a block\n    if (node.type === \"BlockStatement\") {\n      currentNestingDepth--;\n    }\n  }\n\n  // Start traversal from the root node\n  visit(ast);\n\n  // Add overall nesting depth as a feature\n  result.features.push({\n    type: \"metadata\",\n    name: \"max_nesting_depth\",\n    value: maxNestingDepth,\n  });\n\n  return result;\n}\n\n/**\n * Stores structural metadata for a code entity in the database\n *\n * @param {string} entityId - ID of the code entity\n * @param {Array} features - Array of structural features from extractStructuralFeatures\n * @returns {Promise<void>} Promise that resolves when the update is complete\n */\nexport async function storeStructuralMetadata(entityId, features) {\n  if (!entityId) {\n    throw new Error(\"Entity ID is required for storing structural metadata\");\n  }\n\n  if (!features || !Array.isArray(features)) {\n    throw new Error(\"Features must be a valid array\");\n  }\n\n  try {\n    // First, retrieve the current custom_metadata to merge with it\n    const currentMetadataQuery = `\n      SELECT custom_metadata \n      FROM code_entities \n      WHERE id = ?\n    `;\n\n    const result = await executeQuery(currentMetadataQuery, [entityId]);\n\n    // Parse existing metadata or initialize as empty object\n    let existingMetadata = {};\n\n    if (result && result.length > 0 && result[0].custom_metadata) {\n      try {\n        // Handle the case where custom_metadata might be stored as a string or object\n        const metadataValue = result[0].custom_metadata;\n        existingMetadata =\n          typeof metadataValue === \"string\"\n            ? JSON.parse(metadataValue)\n            : metadataValue;\n      } catch (parseError) {\n        console.warn(\n          `Error parsing existing metadata for entity ${entityId}:`,\n          parseError\n        );\n        // Continue with empty object if parsing fails\n      }\n    }\n\n    // Create the updated metadata by merging with existing\n    // Overwrite specifically the structural_features key\n    const updatedMetadata = {\n      ...existingMetadata,\n      structural_features: features,\n      // Add timestamp of when this analysis was performed\n      structural_analysis_timestamp: new Date().toISOString(),\n    };\n\n    // Prepare the UPDATE query\n    const updateQuery = `\n      UPDATE code_entities \n      SET \n        custom_metadata = ?,\n        updated_at = CURRENT_TIMESTAMP\n      WHERE id = ?\n    `;\n\n    // Execute the query with the serialized metadata\n    await executeQuery(updateQuery, [\n      JSON.stringify(updatedMetadata),\n      entityId,\n    ]);\n\n    console.log(`Structural metadata updated for entity ${entityId}`);\n  } catch (error) {\n    console.error(\n      `Error storing structural metadata for entity ${entityId}:`,\n      error\n    );\n    throw error; // Re-throw to allow caller to handle\n  }\n}\n\n/**\n * Compares two Abstract Syntax Trees to determine structural similarity\n *\n * @param {Object} ast1 - First AST node\n * @param {Object} ast2 - Second AST node\n * @returns {Object} Object containing similarity score and array of differences\n */\nexport function compareStructures(ast1, ast2) {\n  // Handle null or invalid ASTs\n  if (!ast1 || ast1.error || !ast2 || ast2.error) {\n    return {\n      similarity: 0,\n      differences: [\n        {\n          type: \"invalid_ast\",\n          description: \"One or both ASTs are null or invalid\",\n        },\n      ],\n    };\n  }\n\n  // Array to collect structural differences\n  const differences = [];\n\n  // Extract node type distributions from both ASTs\n  const dist1 = extractNodeTypeDistribution(ast1);\n  const dist2 = extractNodeTypeDistribution(ast2);\n\n  // Compare basic tree structure statistics\n  const basicStats1 = extractBasicStats(ast1);\n  const basicStats2 = extractBasicStats(ast2);\n\n  // Generate structural fingerprints for comparison\n  const fingerprint1 = generateStructuralFingerprint(ast1);\n  const fingerprint2 = generateStructuralFingerprint(ast2);\n\n  // Calculate similarity based on various metrics\n  const typeSimilarity = calculateTypeDistributionSimilarity(dist1, dist2);\n  const statsSimilarity = calculateStatsSimilarity(basicStats1, basicStats2);\n  const fingerprintSimilarity = calculateFingerprintSimilarity(\n    fingerprint1,\n    fingerprint2\n  );\n\n  // Detect key structural differences\n  detectStructuralDifferences(ast1, ast2, differences);\n\n  // Weight the different similarity components for a final score\n  // Fingerprint similarity should have the highest weight as it captures structure\n  const similarity =\n    typeSimilarity * 0.3 + statsSimilarity * 0.2 + fingerprintSimilarity * 0.5;\n\n  // Return bounded similarity score and differences\n  return {\n    similarity: Math.max(0, Math.min(1, similarity)), // Ensure between 0 and 1\n    differences,\n  };\n}\n\n/**\n * Extracts the distribution of node types in an AST\n *\n * @param {Object} ast - The AST to analyze\n * @returns {Object} Map of node types to their frequency\n * @private\n */\nfunction extractNodeTypeDistribution(ast) {\n  const distribution = {};\n  const visitedNodes = new WeakSet();\n\n  function visit(node) {\n    if (!node || typeof node !== \"object\" || visitedNodes.has(node)) {\n      return;\n    }\n\n    visitedNodes.add(node);\n\n    if (node.type) {\n      distribution[node.type] = (distribution[node.type] || 0) + 1;\n    }\n\n    // Recursively visit child nodes\n    for (const key in node) {\n      const child = node[key];\n\n      if (key === \"type\" || key === \"loc\" || key === \"range\") {\n        continue;\n      }\n\n      if (Array.isArray(child)) {\n        for (const item of child) {\n          visit(item);\n        }\n      } else if (child && typeof child === \"object\") {\n        visit(child);\n      }\n    }\n  }\n\n  visit(ast);\n  return distribution;\n}\n\n/**\n * Extracts basic structural statistics from an AST\n *\n * @param {Object} ast - The AST to analyze\n * @returns {Object} Basic structure statistics\n * @private\n */\nfunction extractBasicStats(ast) {\n  const stats = {\n    nodeCount: 0,\n    maxDepth: 0,\n    leafCount: 0,\n    blockCount: 0,\n    functionCount: 0,\n    expressionCount: 0,\n  };\n\n  const visitedNodes = new WeakSet();\n\n  function visit(node, depth = 0) {\n    if (!node || typeof node !== \"object\" || visitedNodes.has(node)) {\n      return;\n    }\n\n    visitedNodes.add(node);\n    stats.nodeCount++;\n    stats.maxDepth = Math.max(stats.maxDepth, depth);\n\n    let hasChildren = false;\n\n    // Count specific node types\n    if (node.type) {\n      if (node.type === \"BlockStatement\") {\n        stats.blockCount++;\n      } else if (\n        node.type === \"FunctionDeclaration\" ||\n        node.type === \"FunctionExpression\" ||\n        node.type === \"ArrowFunctionExpression\"\n      ) {\n        stats.functionCount++;\n      } else if (node.type.includes(\"Expression\")) {\n        stats.expressionCount++;\n      }\n    }\n\n    // Recursively visit child nodes\n    for (const key in node) {\n      const child = node[key];\n\n      if (key === \"type\" || key === \"loc\" || key === \"range\") {\n        continue;\n      }\n\n      if (Array.isArray(child)) {\n        if (child.length > 0) {\n          hasChildren = true;\n          for (const item of child) {\n            visit(item, depth + 1);\n          }\n        }\n      } else if (child && typeof child === \"object\") {\n        hasChildren = true;\n        visit(child, depth + 1);\n      }\n    }\n\n    if (!hasChildren) {\n      stats.leafCount++;\n    }\n  }\n\n  visit(ast);\n  return stats;\n}\n\n/**\n * Generates a structural fingerprint for an AST\n * This creates a simplified representation of the AST structure\n *\n * @param {Object} ast - The AST to fingerprint\n * @returns {Object} Structural fingerprint with depth-based node sequences\n * @private\n */\nfunction generateStructuralFingerprint(ast) {\n  const fingerprint = {\n    // Store sequences of node types at each depth\n    sequencesByDepth: {},\n    // Store parent-child type relationships\n    relationships: {},\n    // Top-level node structure\n    topLevel: [],\n  };\n\n  const visitedNodes = new WeakSet();\n\n  function visit(node, depth = 0, path = \"\") {\n    if (!node || typeof node !== \"object\" || visitedNodes.has(node)) {\n      return;\n    }\n\n    visitedNodes.add(node);\n\n    if (node.type) {\n      // Add to sequence at this depth\n      if (!fingerprint.sequencesByDepth[depth]) {\n        fingerprint.sequencesByDepth[depth] = [];\n      }\n      fingerprint.sequencesByDepth[depth].push(node.type);\n\n      // For root level nodes, capture more detail\n      if (depth === 1 && node.type) {\n        fingerprint.topLevel.push(node.type);\n      }\n    }\n\n    // Recursively visit child nodes\n    for (const key in node) {\n      const child = node[key];\n\n      if (key === \"type\" || key === \"loc\" || key === \"range\") {\n        continue;\n      }\n\n      if (Array.isArray(child)) {\n        for (let i = 0; i < child.length; i++) {\n          const item = child[i];\n          const newPath = `${path}.${key}[${i}]`;\n\n          if (item && item.type && node.type) {\n            const relationship = `${node.type}->${item.type}`;\n            fingerprint.relationships[relationship] =\n              (fingerprint.relationships[relationship] || 0) + 1;\n          }\n\n          visit(item, depth + 1, newPath);\n        }\n      } else if (child && typeof child === \"object\") {\n        const newPath = `${path}.${key}`;\n\n        if (child.type && node.type) {\n          const relationship = `${node.type}->${child.type}`;\n          fingerprint.relationships[relationship] =\n            (fingerprint.relationships[relationship] || 0) + 1;\n        }\n\n        visit(child, depth + 1, newPath);\n      }\n    }\n  }\n\n  visit(ast, 0, \"root\");\n  return fingerprint;\n}\n\n/**\n * Calculates similarity between two node type distributions\n *\n * @param {Object} dist1 - First node type distribution\n * @param {Object} dist2 - Second node type distribution\n * @returns {number} Similarity score between 0 and 1\n * @private\n */\nfunction calculateTypeDistributionSimilarity(dist1, dist2) {\n  // Get all unique node types\n  const allTypes = new Set([...Object.keys(dist1), ...Object.keys(dist2)]);\n\n  if (allTypes.size === 0) {\n    return 0;\n  }\n\n  // Calculate cosine similarity\n  let dotProduct = 0;\n  let magnitude1 = 0;\n  let magnitude2 = 0;\n\n  for (const type of allTypes) {\n    const count1 = dist1[type] || 0;\n    const count2 = dist2[type] || 0;\n\n    dotProduct += count1 * count2;\n    magnitude1 += count1 * count1;\n    magnitude2 += count2 * count2;\n  }\n\n  magnitude1 = Math.sqrt(magnitude1);\n  magnitude2 = Math.sqrt(magnitude2);\n\n  if (magnitude1 === 0 || magnitude2 === 0) {\n    return 0;\n  }\n\n  return dotProduct / (magnitude1 * magnitude2);\n}\n\n/**\n * Calculates similarity between two sets of basic structure statistics\n *\n * @param {Object} stats1 - First structure statistics\n * @param {Object} stats2 - Second structure statistics\n * @returns {number} Similarity score between 0 and 1\n * @private\n */\nfunction calculateStatsSimilarity(stats1, stats2) {\n  // Normalize and compare key statistics\n  const metrics = [\n    \"nodeCount\",\n    \"maxDepth\",\n    \"leafCount\",\n    \"blockCount\",\n    \"functionCount\",\n    \"expressionCount\",\n  ];\n\n  let totalSimilarity = 0;\n\n  for (const metric of metrics) {\n    // If both values are 0, consider them perfectly similar for this metric\n    if (stats1[metric] === 0 && stats2[metric] === 0) {\n      totalSimilarity += 1;\n      continue;\n    }\n\n    // Calculate ratio of smaller to larger value\n    const ratio =\n      Math.min(stats1[metric], stats2[metric]) /\n      Math.max(stats1[metric], stats2[metric]);\n\n    totalSimilarity += ratio;\n  }\n\n  return totalSimilarity / metrics.length;\n}\n\n/**\n * Calculates similarity between two structural fingerprints\n *\n * @param {Object} fp1 - First fingerprint\n * @param {Object} fp2 - Second fingerprint\n * @returns {number} Similarity score between 0 and 1\n * @private\n */\nfunction calculateFingerprintSimilarity(fp1, fp2) {\n  // Compare sequences at each depth (with higher weight for lower depths)\n  let sequenceSimilarity = 0;\n  let totalWeight = 0;\n\n  // Find the maximum depth across both fingerprints\n  const maxDepth = Math.max(\n    ...Object.keys(fp1.sequencesByDepth).map(Number),\n    ...Object.keys(fp2.sequencesByDepth).map(Number)\n  );\n\n  for (let depth = 0; depth <= maxDepth; depth++) {\n    const seq1 = fp1.sequencesByDepth[depth] || [];\n    const seq2 = fp2.sequencesByDepth[depth] || [];\n\n    // Skip if both sequences are empty\n    if (seq1.length === 0 && seq2.length === 0) {\n      continue;\n    }\n\n    // Calculate longest common subsequence length\n    const lcsLength = longestCommonSubsequenceLength(seq1, seq2);\n\n    // Calculate sequence similarity as ratio of LCS to max length\n    const maxSeqLength = Math.max(seq1.length, seq2.length);\n    const seqSimilarity = maxSeqLength > 0 ? lcsLength / maxSeqLength : 0;\n\n    // Weight decreases with depth (root nodes are more important)\n    const weight = 1 / (depth + 1);\n    sequenceSimilarity += seqSimilarity * weight;\n    totalWeight += weight;\n  }\n\n  const normalizedSequenceSimilarity =\n    totalWeight > 0 ? sequenceSimilarity / totalWeight : 0;\n\n  // Compare top-level structure (higher weight)\n  const topLevelSimilarity = compareArrays(fp1.topLevel, fp2.topLevel);\n\n  // Compare parent-child relationships\n  const relationshipSimilarity = compareRelationships(\n    fp1.relationships,\n    fp2.relationships\n  );\n\n  // Combine with weights\n  return (\n    normalizedSequenceSimilarity * 0.4 +\n    topLevelSimilarity * 0.4 +\n    relationshipSimilarity * 0.2\n  );\n}\n\n/**\n * Compares arrays by finding elements in common\n *\n * @param {Array} arr1 - First array\n * @param {Array} arr2 - Second array\n * @returns {number} Similarity score between 0 and 1\n * @private\n */\nfunction compareArrays(arr1, arr2) {\n  if (arr1.length === 0 && arr2.length === 0) {\n    return 1; // Both empty means they're identical\n  }\n\n  if (arr1.length === 0 || arr2.length === 0) {\n    return 0; // One empty means no similarity\n  }\n\n  // Count elements in common\n  const set1 = new Set(arr1);\n  const set2 = new Set(arr2);\n\n  let common = 0;\n  for (const item of set1) {\n    if (set2.has(item)) {\n      common++;\n    }\n  }\n\n  // Jaccard similarity: intersection size / union size\n  const union = set1.size + set2.size - common;\n  return union > 0 ? common / union : 0;\n}\n\n/**\n * Compares relationship maps between two fingerprints\n *\n * @param {Object} rel1 - First relationship map\n * @param {Object} rel2 - Second relationship map\n * @returns {number} Similarity score between 0 and 1\n * @private\n */\nfunction compareRelationships(rel1, rel2) {\n  const allRelationships = new Set([\n    ...Object.keys(rel1),\n    ...Object.keys(rel2),\n  ]);\n\n  if (allRelationships.size === 0) {\n    return 0;\n  }\n\n  let similarity = 0;\n\n  for (const rel of allRelationships) {\n    const count1 = rel1[rel] || 0;\n    const count2 = rel2[rel] || 0;\n\n    // Ratio of smaller to larger count\n    const ratio = Math.min(count1, count2) / Math.max(count1, count2);\n    similarity += ratio;\n  }\n\n  return similarity / allRelationships.size;\n}\n\n/**\n * Finds the length of the longest common subsequence of two arrays\n *\n * @param {Array} arr1 - First array\n * @param {Array} arr2 - Second array\n * @returns {number} Length of longest common subsequence\n * @private\n */\nfunction longestCommonSubsequenceLength(arr1, arr2) {\n  if (!arr1.length || !arr2.length) {\n    return 0;\n  }\n\n  // Initialize DP table\n  const dp = Array(arr1.length + 1)\n    .fill()\n    .map(() => Array(arr2.length + 1).fill(0));\n\n  // Fill the DP table\n  for (let i = 1; i <= arr1.length; i++) {\n    for (let j = 1; j <= arr2.length; j++) {\n      if (arr1[i - 1] === arr2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n      } else {\n        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n      }\n    }\n  }\n\n  return dp[arr1.length][arr2.length];\n}\n\n/**\n * Detects structural differences between two ASTs and adds them to the differences array\n *\n * @param {Object} ast1 - First AST\n * @param {Object} ast2 - Second AST\n * @param {Array} differences - Array to store detected differences\n * @private\n */\nfunction detectStructuralDifferences(ast1, ast2, differences) {\n  // Extract basic stats for comparison\n  const stats1 = extractBasicStats(ast1);\n  const stats2 = extractBasicStats(ast2);\n\n  // Compare node counts\n  const nodeDiff = Math.abs(stats1.nodeCount - stats2.nodeCount);\n  const nodeRatio =\n    stats1.nodeCount === 0 && stats2.nodeCount === 0\n      ? 1\n      : Math.min(stats1.nodeCount, stats2.nodeCount) /\n        Math.max(stats1.nodeCount, stats2.nodeCount);\n\n  if (nodeRatio < 0.7) {\n    differences.push({\n      type: \"node_count_mismatch\",\n      description: `Node count differs significantly: ${stats1.nodeCount} vs ${stats2.nodeCount}`,\n      severity: \"high\",\n    });\n  }\n\n  // Compare depth\n  if (Math.abs(stats1.maxDepth - stats2.maxDepth) > 2) {\n    differences.push({\n      type: \"depth_mismatch\",\n      description: `Tree depth differs: ${stats1.maxDepth} vs ${stats2.maxDepth}`,\n      severity: \"medium\",\n    });\n  }\n\n  // Compare function counts\n  if (stats1.functionCount !== stats2.functionCount) {\n    differences.push({\n      type: \"function_count_mismatch\",\n      description: `Function count differs: ${stats1.functionCount} vs ${stats2.functionCount}`,\n      severity: \"medium\",\n    });\n  }\n\n  // Compare root structure\n  const rootType1 = ast1.type;\n  const rootType2 = ast2.type;\n\n  if (rootType1 !== rootType2) {\n    differences.push({\n      type: \"root_type_mismatch\",\n      description: `Root node type differs: ${rootType1} vs ${rootType2}`,\n      severity: \"high\",\n    });\n  }\n\n  // Analyze top-level structure\n  const body1 = ast1.body || [];\n  const body2 = ast2.body || [];\n\n  if (body1.length !== body2.length) {\n    differences.push({\n      type: \"program_body_length_mismatch\",\n      description: `Program body length differs: ${body1.length} vs ${body2.length}`,\n      severity: \"medium\",\n    });\n  }\n\n  // Compare top-level statement types\n  const topLevelTypes1 = (body1 || []).map((node) => node.type);\n  const topLevelTypes2 = (body2 || []).map((node) => node.type);\n\n  // Find missing types in each direction\n  const missingInAst2 = topLevelTypes1.filter(\n    (type) => !topLevelTypes2.includes(type)\n  );\n  const missingInAst1 = topLevelTypes2.filter(\n    (type) => !topLevelTypes1.includes(type)\n  );\n\n  if (missingInAst2.length > 0) {\n    differences.push({\n      type: \"missing_node_types\",\n      description: `Node types in AST1 but missing in AST2: ${missingInAst2.join(\n        \", \"\n      )}`,\n      severity: \"medium\",\n    });\n  }\n\n  if (missingInAst1.length > 0) {\n    differences.push({\n      type: \"missing_node_types\",\n      description: `Node types in AST2 but missing in AST1: ${missingInAst1.join(\n        \", \"\n      )}`,\n      severity: \"medium\",\n    });\n  }\n}\n\n/**\n * Finds entities with similar structural features to the source entity\n *\n * @param {string} entityId - ID of the source entity\n * @param {number} threshold - Similarity threshold (0 to 1), defaults to 0.7\n * @returns {Promise<Array>} Array of similar entities with similarity scores\n */\nexport async function findStructurallySimilarEntities(\n  entityId,\n  threshold = 0.7\n) {\n  if (!entityId) {\n    throw new Error(\"Entity ID is required for finding similar entities\");\n  }\n\n  // Validate threshold\n  if (threshold < 0 || threshold > 1) {\n    throw new Error(\"Threshold must be between 0 and 1\");\n  }\n\n  try {\n    // 1. Retrieve the source entity's metadata including features\n    const sourceQuery = `\n      SELECT id, type, path, custom_metadata \n      FROM code_entities \n      WHERE id = ?\n    `;\n\n    const sourceResult = await executeQuery(sourceQuery, [entityId]);\n\n    if (!sourceResult || sourceResult.length === 0) {\n      throw new Error(`Source entity with ID ${entityId} not found`);\n    }\n\n    const sourceEntity = sourceResult[0];\n    let sourceFeatures = null;\n\n    // Try to get structural features from custom_metadata\n    if (sourceEntity.custom_metadata) {\n      try {\n        const metadata =\n          typeof sourceEntity.custom_metadata === \"string\"\n            ? JSON.parse(sourceEntity.custom_metadata)\n            : sourceEntity.custom_metadata;\n\n        if (metadata.structural_features) {\n          sourceFeatures = metadata.structural_features;\n        }\n      } catch (parseError) {\n        console.warn(\n          `Error parsing metadata for source entity ${entityId}:`,\n          parseError\n        );\n      }\n    }\n\n    if (\n      !sourceFeatures ||\n      !Array.isArray(sourceFeatures) ||\n      sourceFeatures.length === 0\n    ) {\n      console.warn(\n        `No structural features found for entity ${entityId}. Cannot compare similarity.`\n      );\n      return [];\n    }\n\n    // 2. Find candidate entities (same type as source for more relevant comparisons)\n    const candidatesQuery = `\n      SELECT id, type, path, custom_metadata \n      FROM code_entities \n      WHERE id != ? \n      AND type = ?\n    `;\n\n    const candidateEntities = await executeQuery(candidatesQuery, [\n      entityId,\n      sourceEntity.type,\n    ]);\n\n    if (!candidateEntities || candidateEntities.length === 0) {\n      console.log(\n        `No candidate entities found for comparison with ${entityId}`\n      );\n      return [];\n    }\n\n    // 3. Compare source features with each candidate's features\n    const similarEntities = [];\n\n    for (const candidate of candidateEntities) {\n      let candidateFeatures = null;\n\n      // Extract candidate features from metadata\n      if (candidate.custom_metadata) {\n        try {\n          const metadata =\n            typeof candidate.custom_metadata === \"string\"\n              ? JSON.parse(candidate.custom_metadata)\n              : candidate.custom_metadata;\n\n          if (metadata.structural_features) {\n            candidateFeatures = metadata.structural_features;\n          }\n        } catch (parseError) {\n          console.warn(\n            `Error parsing metadata for candidate entity ${candidate.id}:`,\n            parseError\n          );\n          continue; // Skip this candidate\n        }\n      }\n\n      // Skip if candidate has no features\n      if (\n        !candidateFeatures ||\n        !Array.isArray(candidateFeatures) ||\n        candidateFeatures.length === 0\n      ) {\n        continue;\n      }\n\n      // Calculate similarity score between source and candidate features\n      const similarityScore = calculateFeatureSimilarity(\n        sourceFeatures,\n        candidateFeatures\n      );\n\n      // Add to results if above threshold\n      if (similarityScore >= threshold) {\n        similarEntities.push({\n          entityId: candidate.id,\n          path: candidate.path,\n          type: candidate.type,\n          similarity: similarityScore,\n        });\n      }\n    }\n\n    // 4. Sort by similarity score (descending)\n    similarEntities.sort((a, b) => b.similarity - a.similarity);\n\n    return similarEntities;\n  } catch (error) {\n    console.error(\n      `Error finding structurally similar entities for ${entityId}:`,\n      error\n    );\n    throw error;\n  }\n}\n\n/**\n * Calculates similarity between two sets of structural features\n *\n * @param {Array} features1 - First set of features\n * @param {Array} features2 - Second set of features\n * @returns {number} Similarity score between 0 and 1\n * @private\n */\nfunction calculateFeatureSimilarity(features1, features2) {\n  if (!features1 || !features2 || !features1.length || !features2.length) {\n    return 0;\n  }\n\n  // Extract feature types for a simple Jaccard similarity\n  const types1 = new Set(\n    features1.map((f) => `${f.type}:${f.statement || f.name || \"\"}`)\n  );\n  const types2 = new Set(\n    features2.map((f) => `${f.type}:${f.statement || f.name || \"\"}`)\n  );\n\n  // Find complexity value if present\n  const getComplexity = (features) => {\n    const metadataFeature = features.find(\n      (f) => f.type === \"metadata\" && f.name === \"max_nesting_depth\"\n    );\n    return metadataFeature ? metadataFeature.value : 0;\n  };\n\n  const nestingDepth1 = getComplexity(features1);\n  const nestingDepth2 = getComplexity(features2);\n\n  // Calculate count of each feature type\n  const countByType1 = countFeaturesByType(features1);\n  const countByType2 = countFeaturesByType(features2);\n\n  // Calculate different similarity components\n\n  // 1. Jaccard similarity of feature types (40% weight)\n  const intersection = new Set([...types1].filter((x) => types2.has(x)));\n  const union = new Set([...types1, ...types2]);\n  const jaccardSimilarity = intersection.size / union.size;\n\n  // 2. Feature count similarity (30% weight)\n  const countSimilarity = calculateCountSimilarity(countByType1, countByType2);\n\n  // 3. Nesting depth similarity (30% weight)\n  const maxNesting = Math.max(nestingDepth1, nestingDepth2);\n  const nestingSimilarity =\n    maxNesting === 0\n      ? 1 // If both have zero nesting, they're similar\n      : 1 - Math.abs(nestingDepth1 - nestingDepth2) / maxNesting;\n\n  // Weighted combination of similarity measures\n  return (\n    jaccardSimilarity * 0.4 + countSimilarity * 0.3 + nestingSimilarity * 0.3\n  );\n}\n\n/**\n * Count features by type in a feature array\n *\n * @param {Array} features - Array of features\n * @returns {Object} Map of feature types to counts\n * @private\n */\nfunction countFeaturesByType(features) {\n  const counts = {};\n\n  for (const feature of features) {\n    const type = feature.type;\n    counts[type] = (counts[type] || 0) + 1;\n  }\n\n  return counts;\n}\n\n/**\n * Calculate similarity between feature type counts\n *\n * @param {Object} counts1 - Feature counts for first entity\n * @param {Object} counts2 - Feature counts for second entity\n * @returns {number} Similarity score between 0 and 1\n * @private\n */\nfunction calculateCountSimilarity(counts1, counts2) {\n  // Get all unique feature types\n  const allTypes = new Set([...Object.keys(counts1), ...Object.keys(counts2)]);\n\n  if (allTypes.size === 0) {\n    return 0;\n  }\n\n  let similarity = 0;\n\n  for (const type of allTypes) {\n    const count1 = counts1[type] || 0;\n    const count2 = counts2[type] || 0;\n\n    // Skip if both counts are 0\n    if (count1 === 0 && count2 === 0) {\n      continue;\n    }\n\n    // Calculate ratio (smaller/larger)\n    const ratio = Math.min(count1, count2) / Math.max(count1, count2);\n    similarity += ratio;\n  }\n\n  return similarity / allTypes.size;\n}\n\n/**\n * Generates a data flow graph from a function's Abstract Syntax Tree\n *\n * @param {Object} functionAst - AST node representing a function\n * @returns {Object} Data flow graph with nodes and edges\n */\nexport function getDataFlowGraph(functionAst) {\n  // Return empty graph for invalid input\n  if (!functionAst || functionAst.error) {\n    return { nodes: [], edges: [] };\n  }\n\n  // Verify that the AST node is a function\n  const isFunctionNode =\n    functionAst.type === \"FunctionDeclaration\" ||\n    functionAst.type === \"FunctionExpression\" ||\n    functionAst.type === \"ArrowFunctionExpression\";\n\n  if (!isFunctionNode) {\n    return { nodes: [], edges: [] };\n  }\n\n  // Initialize graph components\n  const nodes = [];\n  const edges = [];\n\n  // Track node IDs to avoid duplicates\n  const nodeIds = new Set();\n\n  // Track variable declarations and their scopes\n  const variables = new Map();\n\n  // Track current scope and parent scope chain\n  const scopeChain = [];\n  let currentScope = \"function\";\n\n  // Helper to add a node if it doesn't already exist\n  function addNode(id, type) {\n    if (!nodeIds.has(id)) {\n      nodes.push({ id, type });\n      nodeIds.add(id);\n    }\n  }\n\n  // Helper to add an edge between nodes\n  function addEdge(source, target, type) {\n    // Ensure both nodes exist first\n    if (nodeIds.has(source) && nodeIds.has(target)) {\n      edges.push({ source, target, type });\n    }\n  }\n\n  // Add function parameters as nodes\n  functionAst.params?.forEach((param) => {\n    if (param.type === \"Identifier\") {\n      const paramId = param.name;\n      addNode(paramId, \"parameter\");\n      variables.set(paramId, currentScope);\n    } else if (\n      param.type === \"AssignmentPattern\" &&\n      param.left.type === \"Identifier\"\n    ) {\n      // Handle default parameters: function(a = 1)\n      const paramId = param.left.name;\n      addNode(paramId, \"parameter\");\n      variables.set(paramId, currentScope);\n\n      // Add default value node and edge\n      if (param.right) {\n        const defaultValueId = `default_${paramId}`;\n        addNode(defaultValueId, \"literal\");\n        addEdge(defaultValueId, paramId, \"default_value\");\n      }\n    }\n  });\n\n  // Begin AST traversal for the function body\n  const visitedNodes = new WeakSet();\n\n  function visit(node, parentNode = null) {\n    // Skip if node is null, undefined, or already visited\n    if (!node || typeof node !== \"object\" || visitedNodes.has(node)) {\n      return;\n    }\n\n    visitedNodes.add(node);\n\n    // Handle variable declarations\n    if (node.type === \"VariableDeclaration\") {\n      node.declarations.forEach((declarator) => {\n        if (declarator.id && declarator.id.type === \"Identifier\") {\n          const varId = declarator.id.name;\n          addNode(varId, \"variable\");\n          variables.set(varId, currentScope);\n\n          // If there's an initializer, create a data flow edge\n          if (declarator.init) {\n            // For literals, create a literal node\n            if (declarator.init.type === \"Literal\") {\n              const literalId = `literal_${varId}`;\n              addNode(literalId, \"literal\");\n              addEdge(literalId, varId, \"assignment\");\n            }\n            // For identifiers (another variable)\n            else if (declarator.init.type === \"Identifier\") {\n              const sourceId = declarator.init.name;\n              // Only create edge if source exists as a node\n              if (nodeIds.has(sourceId)) {\n                addEdge(sourceId, varId, \"assignment\");\n              }\n            }\n            // For binary expressions (e.g., a + b)\n            else if (declarator.init.type === \"BinaryExpression\") {\n              processExpression(declarator.init, varId);\n            }\n            // For function calls\n            else if (declarator.init.type === \"CallExpression\") {\n              processCallExpression(declarator.init, varId);\n            }\n          }\n        }\n      });\n    }\n\n    // Handle assignments\n    else if (node.type === \"AssignmentExpression\") {\n      if (node.left.type === \"Identifier\") {\n        const targetId = node.left.name;\n\n        // Make sure the target exists as a node\n        if (!nodeIds.has(targetId)) {\n          addNode(targetId, \"variable\");\n          variables.set(targetId, currentScope);\n        }\n\n        // For identifier on right side (another variable)\n        if (node.right.type === \"Identifier\") {\n          const sourceId = node.right.name;\n          if (nodeIds.has(sourceId)) {\n            addEdge(sourceId, targetId, \"assignment\");\n          }\n        }\n        // For literals\n        else if (node.right.type === \"Literal\") {\n          const literalId = `literal_${targetId}_${node.start}`;\n          addNode(literalId, \"literal\");\n          addEdge(literalId, targetId, \"assignment\");\n        }\n        // For binary expressions\n        else if (node.right.type === \"BinaryExpression\") {\n          processExpression(node.right, targetId);\n        }\n        // For function calls\n        else if (node.right.type === \"CallExpression\") {\n          processCallExpression(node.right, targetId);\n        }\n      }\n    }\n\n    // Handle return statements\n    else if (node.type === \"ReturnStatement\") {\n      if (node.argument) {\n        const returnId = `return_${node.start}`;\n        addNode(returnId, \"return\");\n\n        // Create flow from returned value to return node\n        if (node.argument.type === \"Identifier\") {\n          const sourceId = node.argument.name;\n          if (nodeIds.has(sourceId)) {\n            addEdge(sourceId, returnId, \"return_value\");\n          }\n        }\n        // For literals in return\n        else if (node.argument.type === \"Literal\") {\n          const literalId = `literal_return_${node.start}`;\n          addNode(literalId, \"literal\");\n          addEdge(literalId, returnId, \"return_value\");\n        }\n        // For expressions in return\n        else if (node.argument.type === \"BinaryExpression\") {\n          processExpression(node.argument, returnId, \"return_value\");\n        }\n        // For function calls in return\n        else if (node.argument.type === \"CallExpression\") {\n          processCallExpression(node.argument, returnId, \"return_value\");\n        }\n      }\n    }\n\n    // Handle function calls not covered in other cases\n    else if (\n      node.type === \"CallExpression\" &&\n      parentNode?.type !== \"VariableDeclarator\" &&\n      parentNode?.type !== \"AssignmentExpression\" &&\n      parentNode?.type !== \"ReturnStatement\"\n    ) {\n      processCallExpression(node);\n    }\n\n    // Handle entering new block scope\n    if (node.type === \"BlockStatement\") {\n      scopeChain.push(currentScope);\n      currentScope = `block_${node.start}`;\n    }\n\n    // Recursively visit all child nodes\n    for (const key in node) {\n      const child = node[key];\n\n      // Skip special properties\n      if (\n        key === \"type\" ||\n        key === \"loc\" ||\n        key === \"range\" ||\n        key === \"parent\"\n      ) {\n        continue;\n      }\n\n      if (Array.isArray(child)) {\n        // For arrays (like body), visit each element\n        for (const item of child) {\n          visit(item, node);\n        }\n      } else if (child && typeof child === \"object\") {\n        // Visit child node\n        visit(child, node);\n      }\n    }\n\n    // Handle exiting block scope\n    if (node.type === \"BlockStatement\") {\n      currentScope = scopeChain.pop();\n    }\n  }\n\n  // Helper to process expressions and their effect on data flow\n  function processExpression(expression, targetId, edgeType = \"assignment\") {\n    // For binary expressions like a + b, track flow from operands to result\n    if (expression.left?.type === \"Identifier\") {\n      const leftId = expression.left.name;\n      if (nodeIds.has(leftId)) {\n        addEdge(leftId, targetId, edgeType);\n      }\n    }\n\n    if (expression.right?.type === \"Identifier\") {\n      const rightId = expression.right.name;\n      if (nodeIds.has(rightId)) {\n        addEdge(rightId, targetId, edgeType);\n      }\n    }\n\n    // If operands are themselves expressions, process them recursively\n    if (expression.left?.type === \"BinaryExpression\") {\n      processExpression(expression.left, targetId, edgeType);\n    }\n\n    if (expression.right?.type === \"BinaryExpression\") {\n      processExpression(expression.right, targetId, edgeType);\n    }\n\n    // If operands are literals, create nodes for them\n    if (expression.left?.type === \"Literal\") {\n      const literalId = `literal_left_${expression.left.start}`;\n      addNode(literalId, \"literal\");\n      addEdge(literalId, targetId, edgeType);\n    }\n\n    if (expression.right?.type === \"Literal\") {\n      const literalId = `literal_right_${expression.right.start}`;\n      addNode(literalId, \"literal\");\n      addEdge(literalId, targetId, edgeType);\n    }\n  }\n\n  // Helper to process function calls and their effect on data flow\n  function processCallExpression(\n    callNode,\n    targetId = null,\n    edgeType = \"assignment\"\n  ) {\n    const callId = `call_${callNode.start}`;\n    let functionName = \"unknown\";\n\n    // Try to determine the function name\n    if (callNode.callee.type === \"Identifier\") {\n      functionName = callNode.callee.name;\n    } else if (\n      callNode.callee.type === \"MemberExpression\" &&\n      callNode.callee.property.type === \"Identifier\"\n    ) {\n      functionName = callNode.callee.property.name;\n    }\n\n    addNode(callId, \"function_call\");\n\n    // Connect parameters/arguments to the function call\n    callNode.arguments.forEach((arg, index) => {\n      if (arg.type === \"Identifier\") {\n        const argId = arg.name;\n        if (nodeIds.has(argId)) {\n          addEdge(argId, callId, \"call_argument\");\n        }\n      } else if (arg.type === \"Literal\") {\n        const literalId = `literal_arg_${index}_${callNode.start}`;\n        addNode(literalId, \"literal\");\n        addEdge(literalId, callId, \"call_argument\");\n      }\n    });\n\n    // If this call's result is assigned to a variable\n    if (targetId) {\n      addEdge(callId, targetId, edgeType);\n    }\n  }\n\n  // Start traversal from the function body\n  if (functionAst.body) {\n    visit(functionAst.body);\n  }\n\n  return { nodes, edges };\n}\n", "/**\n * SmartSearchServiceLogic.js\n *\n * Provides advanced search capabilities for code entities using a combination\n * of Full-Text Search (FTS) and keyword-based matching.\n */\n\nimport { executeQuery } from \"../db.js\";\nimport { tokenize, extractKeywords, stem } from \"./TextTokenizerLogic.js\";\n\n/**\n * @typedef {Object} SearchOptions\n * @property {string[]} [entityTypes] - Types of entities to search (e.g., 'file', 'function', 'class')\n * @property {string[]} [filePaths] - File paths to limit the search to\n * @property {Object} [dateRange] - Date range to filter by last modified date\n * @property {Date} [dateRange.start] - Start date of range\n * @property {Date} [dateRange.end] - End date of range\n * @property {string} [sortBy] - Field to sort results by\n * @property {number} [limit] - Maximum number of results to return\n * @property {number} [minRelevance] - Minimum relevance score for results\n * @property {string} [strategy] - Search strategy to use ('fts', 'keywords', 'combined')\n * @property {string} [booleanOperator] - Boolean operator for keyword combination\n * @property {boolean} [useExactMatch] - Whether to use exact phrase matching\n * @property {boolean} [useProximity] - Whether to use proximity search\n * @property {number} [proximityDistance] - Distance for proximity search\n */\n\n/**\n * @typedef {Object} CodeEntity\n * @property {string} entity_id - Unique identifier for the code entity\n * @property {string} file_path - Path to the file containing the entity\n * @property {string} entity_type - Type of code entity (e.g., 'file', 'function', 'class')\n * @property {string} name - Name of the code entity\n * @property {string} [parent_entity_id] - ID of the parent entity (if any)\n * @property {string} [content_hash] - Hash of the entity content\n * @property {string} [raw_content] - Raw content of the entity\n * @property {number} [start_line] - Start line of the entity within the file\n * @property {number} [end_line] - End line of the entity within the file\n * @property {string} [language] - Programming language of the entity\n * @property {string} [created_at] - Creation timestamp\n * @property {string} [last_modified_at] - Last modification timestamp\n */\n\n/**\n * @typedef {Object} SearchResult\n * @property {CodeEntity} entity - The found code entity\n * @property {number} relevanceScore - Relevance score for the search result\n */\n\n/**\n * Searches code entities by keywords using Full-Text Search and/or entity_keywords table\n *\n * @param {string[]} keywords - Keywords to search for\n * @param {SearchOptions} [options={}] - Search options including:\n *   - entityTypes: Types of entities to search\n *   - filePaths: File paths with glob pattern support\n *   - dateRange: Date range to filter by\n *   - sortBy: Field to sort by\n *   - limit: Max results\n *   - minRelevance: Minimum relevance score\n *   - strategy: Search strategy ('fts', 'keywords', 'combined')\n *   - booleanOperator: 'AND' or 'OR' for keyword combination\n *   - useExactMatch: Whether to use exact phrase matching\n *   - useProximity: Whether to use proximity search\n *   - proximityDistance: Distance for proximity search\n * @returns {Promise<SearchResult[]>} Array of search results\n */\nexport async function searchByKeywords(keywords, options = {}) {\n  try {\n    // Validate and normalize input\n    if (!keywords || !Array.isArray(keywords) || keywords.length === 0) {\n      throw new Error(\"Keywords array is required and cannot be empty\");\n    }\n\n    // Handle single string input with boolean operators\n    if (\n      keywords.length === 1 &&\n      /\\s+(AND|OR|NOT|NEAR\\/\\d+)\\s+/i.test(keywords[0])\n    ) {\n      // Keep as is - will be processed by searchUsingFTS\n    } else {\n      // Process and clean keywords\n      keywords = keywords.map((kw) => kw.trim()).filter((kw) => kw.length > 0);\n    }\n\n    // Set default options\n    options = {\n      strategy: \"combined\", // Default to combined search\n      booleanOperator: \"OR\", // Default to OR for broader matches\n      limit: 100, // Default result limit\n      ...options,\n    };\n\n    // Prepare results array\n    let searchResults = [];\n\n    // If strategy is 'fts' or 'combined', perform FTS search\n    if (options.strategy === \"fts\" || options.strategy === \"combined\") {\n      const ftsResults = await searchUsingFTS(keywords, options);\n      searchResults = [...ftsResults];\n    }\n\n    // If strategy is 'keywords' or 'combined', or if FTS returned no results, perform keyword-based search\n    if (\n      options.strategy === \"keywords\" ||\n      options.strategy === \"combined\" ||\n      (options.strategy === \"fts\" && searchResults.length === 0)\n    ) {\n      const keywordResults = await searchUsingKeywords(keywords, options);\n\n      if (options.strategy === \"combined\" && searchResults.length > 0) {\n        // Merge and deduplicate results\n        searchResults = mergeSearchResults(searchResults, keywordResults);\n      } else {\n        searchResults = keywordResults;\n      }\n    }\n\n    // Apply minimum relevance filter if specified\n    if (options.minRelevance) {\n      searchResults = searchResults.filter(\n        (result) => result.relevanceScore >= options.minRelevance\n      );\n    }\n\n    // Apply result limit if not already applied in search functions\n    if (options.limit && searchResults.length > options.limit) {\n      searchResults = searchResults.slice(0, options.limit);\n    }\n\n    // Return the search results\n    return searchResults;\n  } catch (error) {\n    console.error(\"Error in searchByKeywords:\", error);\n    throw error;\n  }\n}\n\n/**\n * Searches code entities using Full-Text Search\n *\n * @param {string[]} keywords - Keywords to search for\n * @param {SearchOptions} options - Search options\n * @returns {Promise<SearchResult[]>} Search results\n */\nasync function searchUsingFTS(keywords, options) {\n  try {\n    // Process keywords for FTS5 query\n    const processedKeywords = keywords.map((keyword) => {\n      // Apply stemming to match the behavior used when indexing content\n      const stemmed = stem(keyword.toLowerCase());\n\n      // Sanitize special characters and escape quotes for FTS\n      // Note: SQLite FTS5 has special handling for \" and other special characters\n      const sanitized = stemmed.replace(\n        /[\\\\\"\\(\\)\\[\\]\\{\\}\\^\\$\\+\\*\\?\\.]/g,\n        (char) => `\\\\${char}`\n      );\n\n      return sanitized;\n    });\n\n    // Determine boolean operator based on options or use default\n    // Default to OR for broader results, use AND for more specific matching\n    const booleanOperator =\n      options.booleanOperator?.toUpperCase() === \"AND\" ? \"AND\" : \"OR\";\n\n    // Construct the FTS query\n    let ftsQuery;\n\n    if (options.useExactMatch) {\n      // For exact phrase matching, wrap the entire phrase in quotes\n      ftsQuery = `\"${processedKeywords.join(\" \")}\"`;\n    } else if (options.useProximity && processedKeywords.length > 1) {\n      // For proximity search, use NEAR operator with optional distance\n      const distance = options.proximityDistance || 10;\n      ftsQuery = `${processedKeywords.join(` NEAR/${distance} `)}`;\n    } else {\n      // Standard boolean search\n      ftsQuery = processedKeywords.join(` ${booleanOperator} `);\n    }\n\n    // Check if the user provided explicit boolean syntax like \"library AND file OR module\"\n    // If so, respect their input instead of our processing\n    if (\n      keywords.length === 1 &&\n      /\\s+(AND|OR|NOT|NEAR\\/\\d+)\\s+/i.test(keywords[0])\n    ) {\n      ftsQuery = keywords[0];\n    }\n\n    // Start building the SQL query\n    let sql = `\n      SELECT\n        e.*,\n        fts.rank as relevance_score\n      FROM\n        code_entities_fts fts\n      JOIN\n        code_entities e ON fts.rowid = e.rowid\n      WHERE\n        fts.code_entities_fts MATCH ?\n    `;\n\n    // Array to hold query parameters\n    const queryParams = [ftsQuery];\n\n    // Apply filters from options\n    if (options.entityTypes && options.entityTypes.length > 0) {\n      const placeholders = options.entityTypes.map(() => \"?\").join(\", \");\n      sql += ` AND e.entity_type IN (${placeholders})`;\n      queryParams.push(...options.entityTypes);\n    }\n\n    // Apply file path filters with proper wildcard handling\n    if (options.filePaths && options.filePaths.length > 0) {\n      sql += \" AND (\";\n\n      const filePathConditions = [];\n\n      for (const pathPattern of options.filePaths) {\n        // Handle glob patterns by converting to SQL LIKE patterns\n        let sqlPattern = pathPattern\n          .replace(/\\*/g, \"%\") // Convert * to %\n          .replace(/\\?/g, \"_\"); // Convert ? to _\n\n        // Handle **/ pattern (recursive directory matching)\n        sqlPattern = sqlPattern.replace(/%\\/%/g, \"%\");\n\n        filePathConditions.push(\"e.file_path LIKE ?\");\n        queryParams.push(sqlPattern);\n      }\n\n      sql += filePathConditions.join(\" OR \");\n      sql += \")\";\n    }\n\n    // Apply date range filter\n    if (options.dateRange) {\n      if (options.dateRange.start) {\n        sql += \" AND e.last_modified_at >= ?\";\n        queryParams.push(options.dateRange.start.toISOString());\n      }\n\n      if (options.dateRange.end) {\n        sql += \" AND e.last_modified_at <= ?\";\n        queryParams.push(options.dateRange.end.toISOString());\n      }\n    }\n\n    // Apply custom ranking if available, otherwise use default FTS rank\n    if (options.customRanking) {\n      sql += ` ORDER BY ${options.customRanking}`;\n    } else {\n      // Enhance default ranking with optional boosts\n      sql += `\n        ORDER BY \n          relevance_score * \n          CASE \n            WHEN e.entity_type = 'file' THEN 1.2\n            WHEN e.entity_type = 'class' THEN 1.1\n            WHEN e.entity_type = 'function' THEN 1.0\n            ELSE 0.9\n          END DESC\n      `;\n    }\n\n    // Apply limit with reasonable default\n    const limit = options.limit && options.limit > 0 ? options.limit : 100;\n    sql += \" LIMIT ?\";\n    queryParams.push(limit);\n\n    // Execute the query\n    const results = await executeQuery(sql, queryParams);\n\n    // Map results to SearchResult objects\n    return mapToSearchResults(results);\n  } catch (error) {\n    console.error(\"Error in searchUsingFTS:\", error);\n    throw error;\n  }\n}\n\n/**\n * Searches code entities using the entity_keywords table\n *\n * @param {string[]} keywords - Keywords to search for\n * @param {SearchOptions} options - Search options\n * @returns {Promise<SearchResult[]>} Search results\n */\nasync function searchUsingKeywords(keywords, options) {\n  try {\n    // Handle single string input with boolean operators by splitting into individual terms\n    let processedKeywords;\n    if (keywords.length === 1 && /\\s+(AND|OR|NOT)\\s+/i.test(keywords[0])) {\n      // Split the complex query string into individual terms, ignoring operators\n      processedKeywords = keywords[0]\n        .split(/\\s+(?:AND|OR|NOT)\\s+/i)\n        .map((term) => term.trim())\n        .filter((term) => term.length > 0);\n    } else {\n      processedKeywords = keywords;\n    }\n\n    // Stem the keywords for more effective matching with the entity_keywords table\n    const stemmedKeywords = processedKeywords.map((keyword) =>\n      stem(keyword.toLowerCase())\n    );\n\n    // Use prepared statement with placeholders for security\n    let sql = `\n      SELECT \n        e.*,\n        SUM(ek.weight * (1.0 + (0.1 * count_matches))) as relevance_score\n      FROM (\n        SELECT \n          entity_id, \n          COUNT(DISTINCT keyword) as count_matches,\n          MAX(weight) as weight\n        FROM \n          entity_keywords\n        WHERE \n          keyword IN (${stemmedKeywords.map(() => \"?\").join(\",\")})\n        GROUP BY \n          entity_id\n      ) as ek\n      JOIN \n        code_entities e ON ek.entity_id = e.entity_id\n    `;\n\n    // Array to hold query parameters\n    const queryParams = [...stemmedKeywords];\n\n    // Apply filters using our updated filter function\n    sql = applyFilters(sql, options, queryParams);\n\n    // Apply ranking with type-based boosts similar to searchUsingFTS\n    if (options.sortBy) {\n      sql += ` ORDER BY e.${options.sortBy}`;\n    } else {\n      // Provide entity-type-based boosting along with the keyword match score\n      sql += `\n        ORDER BY \n          relevance_score * \n          CASE \n            WHEN e.entity_type = 'file' THEN 1.2\n            WHEN e.entity_type = 'class' THEN 1.1\n            WHEN e.entity_type = 'function' THEN 1.0\n            ELSE 0.9\n          END DESC\n      `;\n    }\n\n    // Apply limit with reasonable default\n    const limit = options.limit && options.limit > 0 ? options.limit : 100;\n    sql += \" LIMIT ?\";\n    queryParams.push(limit);\n\n    // Execute the query\n    const results = await executeQuery(sql, queryParams);\n\n    // Map results to SearchResult objects\n    return mapToSearchResults(results);\n  } catch (error) {\n    console.error(\"Error in searchUsingKeywords:\", error);\n    throw error;\n  }\n}\n\n/**\n * Apply filters from search options to SQL query\n * Note: This function is mainly used by searchUsingKeywords.\n * The searchUsingFTS function now applies filters directly for better query construction.\n *\n * @param {string} sql - SQL query to enhance\n * @param {SearchOptions} options - Search options\n * @param {Array} queryParams - Query parameters array to append to\n * @returns {string} Enhanced SQL query with filters\n */\nfunction applyFilters(sql, options, queryParams) {\n  // The provided SQL should already have a WHERE clause, so we'll use AND\n\n  // Apply entity type filters\n  if (options.entityTypes && options.entityTypes.length > 0) {\n    const placeholders = options.entityTypes.map(() => \"?\").join(\", \");\n    sql += ` AND e.entity_type IN (${placeholders})`;\n    queryParams.push(...options.entityTypes);\n  }\n\n  // Apply file path filters with proper glob pattern support\n  if (options.filePaths && options.filePaths.length > 0) {\n    sql += \" AND (\";\n\n    const filePathConditions = [];\n\n    for (const pathPattern of options.filePaths) {\n      // Handle glob patterns by converting to SQL LIKE patterns\n      let sqlPattern = pathPattern\n        .replace(/\\*/g, \"%\") // Convert * to %\n        .replace(/\\?/g, \"_\"); // Convert ? to _\n\n      // Handle **/ pattern (recursive directory matching)\n      sqlPattern = sqlPattern.replace(/%\\/%/g, \"%\");\n\n      filePathConditions.push(\"e.file_path LIKE ?\");\n      queryParams.push(sqlPattern);\n    }\n\n    sql += filePathConditions.join(\" OR \");\n    sql += \")\";\n  }\n\n  // Apply date range filter\n  if (options.dateRange) {\n    if (options.dateRange.start) {\n      sql += \" AND e.last_modified_at >= ?\";\n      queryParams.push(options.dateRange.start.toISOString());\n    }\n\n    if (options.dateRange.end) {\n      sql += \" AND e.last_modified_at <= ?\";\n      queryParams.push(options.dateRange.end.toISOString());\n    }\n  }\n\n  return sql;\n}\n\n/**\n * Map database results to SearchResult objects\n *\n * @param {Array} results - Database query results\n * @returns {Array<SearchResult>} Mapped search results\n */\nfunction mapToSearchResults(results) {\n  // Check if results has a rows property and it's an array\n  const rows =\n    results && results.rows && Array.isArray(results.rows)\n      ? results.rows\n      : Array.isArray(results)\n      ? results\n      : [];\n\n  // If no valid results, return empty array\n  if (rows.length === 0) {\n    console.warn(\"No valid search results found to map\");\n    return [];\n  }\n\n  return rows.map((row) => ({\n    entity: {\n      entity_id: row.entity_id,\n      file_path: row.file_path,\n      entity_type: row.entity_type,\n      name: row.name,\n      parent_entity_id: row.parent_entity_id,\n      content_hash: row.content_hash,\n      raw_content: row.raw_content,\n      start_line: row.start_line,\n      end_line: row.end_line,\n      language: row.language,\n      created_at: row.created_at,\n      last_modified_at: row.last_modified_at,\n    },\n    relevanceScore: row.relevance_score,\n  }));\n}\n\n/**\n * Merge and deduplicate search results from multiple sources\n *\n * @param {Array<SearchResult>} resultsA - First set of search results\n * @param {Array<SearchResult>} resultsB - Second set of search results\n * @returns {Array<SearchResult>} Merged and deduplicated results\n */\nfunction mergeSearchResults(resultsA, resultsB) {\n  // Create a map to deduplicate by entity_id\n  const entityMap = new Map();\n\n  // Process the first result set (higher priority)\n  for (const result of resultsA) {\n    entityMap.set(result.entity.entity_id, result);\n  }\n\n  // Process the second result set, only adding entities not already present\n  // or combining scores if the entity already exists\n  for (const result of resultsB) {\n    const entityId = result.entity.entity_id;\n\n    if (entityMap.has(entityId)) {\n      // Entity already exists, update relevance score\n      // Using a weighted average here, favoring FTS results\n      const existingResult = entityMap.get(entityId);\n      const combinedScore =\n        existingResult.relevanceScore * 0.7 + result.relevanceScore * 0.3;\n\n      entityMap.set(entityId, {\n        ...existingResult,\n        relevanceScore: combinedScore,\n      });\n    } else {\n      // New entity, add to results\n      entityMap.set(entityId, result);\n    }\n  }\n\n  // Convert map back to array and sort by relevance score\n  return Array.from(entityMap.values()).sort(\n    (a, b) => b.relevanceScore - a.relevanceScore\n  );\n}\n\n/**\n * Calculate a custom relevance score for an entity based on non-vector factors\n *\n * @param {CodeEntity} entity - The code entity to score\n * @param {string[]} queryKeywords - Keywords from the search query\n * @param {string[]} [focusKeywords=[]] - Keywords representing the current focus area\n * @returns {number} A relevance score between 0 and 1\n */\nexport function nonVectorRelevanceScore(\n  entity,\n  queryKeywords,\n  focusKeywords = []\n) {\n  // Ensure we have valid inputs\n  if (!entity || !queryKeywords || queryKeywords.length === 0) {\n    return 0;\n  }\n\n  // Initialize base score\n  let score = 0.5;\n\n  // Prepare keywords by stemming\n  const stemmedQueryKeywords = queryKeywords.map((kw) =>\n    stem(kw.toLowerCase())\n  );\n  const stemmedFocusKeywords = focusKeywords.map((kw) =>\n    stem(kw.toLowerCase())\n  );\n\n  // 1. Keyword Matching Score\n  const keywordMatchScore = calculateKeywordMatchScore(\n    entity,\n    stemmedQueryKeywords\n  );\n\n  // 2. Focus Area Boost\n  const focusBoost = calculateFocusAreaBoost(entity, stemmedFocusKeywords);\n\n  // 3. Recency Factor\n  const recencyFactor = calculateRecencyFactor(entity);\n\n  // 4. Importance Score Factor\n  const importanceFactor =\n    entity.importance_score !== undefined ? entity.importance_score : 0.5;\n\n  // 5. Type-Based Weighting\n  const typeWeight = calculateTypeWeight(entity);\n\n  // 6. Hierarchical Proximity (simplified first pass)\n  const hierarchyBoost = 1.0; // Default value for now, can be enhanced later\n\n  // Combine all factors with appropriate weights\n  score =\n    (keywordMatchScore * 0.35 + // 35% weight for keyword matching\n      focusBoost * 0.2 + // 20% weight for focus area boost\n      recencyFactor * 0.15 + // 15% weight for recency\n      importanceFactor * 0.2 + // 20% weight for importance\n      typeWeight * 0.1) * // 10% weight for entity type\n    hierarchyBoost; // Apply hierarchy boost as a multiplier\n\n  // Ensure score is between 0 and 1\n  return Math.max(0, Math.min(1, score));\n}\n\n/**\n * Calculate keyword matching score based on entity content and query keywords\n *\n * @param {CodeEntity} entity - The code entity\n * @param {string[]} stemmedQueryKeywords - Stemmed query keywords\n * @returns {number} Keyword match score between 0 and 1\n */\nfunction calculateKeywordMatchScore(entity, stemmedQueryKeywords) {\n  // Extract meaningful tokens from entity name and content\n  const nameTokens = tokenize(entity.name || \"\").map((token) =>\n    stem(token.toLowerCase())\n  );\n\n  // Use summary if available, otherwise use raw_content\n  const contentText = entity.summary || entity.raw_content || \"\";\n  const contentTokens = tokenize(contentText).map((token) =>\n    stem(token.toLowerCase())\n  );\n\n  // Combine unique tokens\n  const entityTokens = Array.from(new Set([...nameTokens, ...contentTokens]));\n\n  if (entityTokens.length === 0) return 0;\n\n  // Calculate matches\n  let nameMatches = 0;\n  let contentMatches = 0;\n\n  for (const queryKw of stemmedQueryKeywords) {\n    // Check for matches in name (higher importance)\n    if (nameTokens.includes(queryKw)) {\n      nameMatches++;\n    }\n    // Check for matches in content\n    else if (contentTokens.includes(queryKw)) {\n      contentMatches++;\n    }\n  }\n\n  // Calculate Jaccard index for overall similarity\n  const matchingTokens = stemmedQueryKeywords.filter((kw) =>\n    entityTokens.includes(kw)\n  ).length;\n\n  const jaccardIndex =\n    matchingTokens /\n    (entityTokens.length + stemmedQueryKeywords.length - matchingTokens);\n\n  // Calculate final keyword score with boosted name matches\n  const nameMatchScore = (nameMatches / stemmedQueryKeywords.length) * 1.5; // 50% boost for name matches\n  const contentMatchScore = contentMatches / stemmedQueryKeywords.length;\n  const overallMatchScore = jaccardIndex * 0.5; // Base similarity\n\n  return Math.min(1.0, nameMatchScore + contentMatchScore + overallMatchScore);\n}\n\n/**\n * Calculate focus area boost based on overlap with focus keywords\n *\n * @param {CodeEntity} entity - The code entity\n * @param {string[]} stemmedFocusKeywords - Stemmed focus area keywords\n * @returns {number} Focus area boost between 0 and 1\n */\nfunction calculateFocusAreaBoost(entity, stemmedFocusKeywords) {\n  if (!stemmedFocusKeywords || stemmedFocusKeywords.length === 0) {\n    return 0;\n  }\n\n  // Extract tokens from entity\n  const entityText = [\n    entity.name || \"\",\n    entity.summary || \"\",\n    entity.raw_content || \"\",\n  ].join(\" \");\n\n  const entityTokens = tokenize(entityText).map((token) =>\n    stem(token.toLowerCase())\n  );\n\n  // Count matching focus keywords\n  const matchingFocusKeywords = stemmedFocusKeywords.filter((kw) =>\n    entityTokens.includes(kw)\n  ).length;\n\n  // Calculate focus boost based on proportion of matching focus keywords\n  return matchingFocusKeywords / stemmedFocusKeywords.length;\n}\n\n/**\n * Calculate recency factor based on entity's last modified or accessed date\n *\n * @param {CodeEntity} entity - The code entity\n * @returns {number} Recency factor between 0 and 1\n */\nfunction calculateRecencyFactor(entity) {\n  // Use last_modified_at or last_accessed_at, whichever is more recent\n  const lastModified = entity.last_modified_at\n    ? new Date(entity.last_modified_at)\n    : null;\n  const lastAccessed = entity.last_accessed_at\n    ? new Date(entity.last_accessed_at)\n    : null;\n\n  if (!lastModified && !lastAccessed) {\n    return 0.5; // Default value if no dates available\n  }\n\n  // Use the most recent date\n  const mostRecentDate = !lastAccessed\n    ? lastModified\n    : !lastModified\n    ? lastAccessed\n    : lastAccessed > lastModified\n    ? lastAccessed\n    : lastModified;\n\n  const now = new Date();\n  const ageInDays = (now - mostRecentDate) / (1000 * 60 * 60 * 24);\n\n  // Exponential decay function: score = e^(-ageInDays/30)\n  // This gives a score of ~1.0 for today, ~0.37 for 30 days ago, ~0.14 for 60 days ago\n  return Math.exp(-ageInDays / 30);\n}\n\n/**\n * Calculate type-based weight for different entity types\n *\n * @param {CodeEntity} entity - The code entity\n * @returns {number} Type weight between 0 and 1\n */\nfunction calculateTypeWeight(entity) {\n  // Define weights for different entity types\n  const typeWeights = {\n    function: 0.9,\n    class: 0.9,\n    method: 0.85,\n    file: 0.8,\n    variable: 0.75,\n    comment: 0.5,\n    default: 0.7, // Default weight for unknown types\n  };\n\n  const entityType = (entity.entity_type || \"\").toLowerCase();\n  return typeWeights[entityType] || typeWeights.default;\n}\n\n/**\n * Retrieves code entities by their entity IDs\n *\n * @param {string[]} entityIds - Array of entity IDs to retrieve\n * @returns {Promise<CodeEntity[]>} Array of code entities\n */\nexport async function searchByEntityIds(entityIds) {\n  try {\n    // Validate input\n    if (!entityIds || !Array.isArray(entityIds) || entityIds.length === 0) {\n      throw new Error(\"Entity IDs array is required and cannot be empty\");\n    }\n\n    // Create placeholders for the IN clause\n    const placeholders = entityIds.map(() => \"?\").join(\", \");\n\n    // Build and execute the query\n    const sql = `\n      SELECT * FROM code_entities\n      WHERE entity_id IN (${placeholders})\n    `;\n\n    const results = await executeQuery(sql, entityIds);\n\n    // Return the raw entity objects\n    return results;\n  } catch (error) {\n    console.error(\"Error in searchByEntityIds:\", error);\n    throw error;\n  }\n}\n", "/**\n * ContextPrioritizerLogic.js\n *\n * Logic for prioritizing and scoring context snippets based on\n * query relevance, focus area alignment, recency, and relationships.\n */\n\nimport { nonVectorRelevanceScore } from \"./SmartSearchServiceLogic.js\";\nimport { getRelatedEntities } from \"./RelationshipContextManagerLogic.js\";\nimport { executeQuery } from \"../db.js\";\nimport { CONTEXT_DECAY_RATE } from \"../config.js\";\n\n/**\n * @typedef {Object} CodeEntity\n * @property {string} entity_id - Unique identifier for the code entity\n * @property {string} file_path - Path to the file containing the entity\n * @property {string} entity_type - Type of code entity (e.g., 'file', 'function', 'class')\n * @property {string} name - Name of the code entity\n * @property {string} [parent_entity_id] - ID of the parent entity (if any)\n * @property {string} [content_hash] - Hash of the entity content\n * @property {string} [raw_content] - Raw content of the entity\n * @property {number} [start_line] - Start line of the entity within the file\n * @property {number} [end_line] - End line of the entity within the file\n * @property {string} [language] - Programming language of the entity\n * @property {Date} [created_at] - Creation timestamp\n * @property {Date} [last_modified_at] - Last modification timestamp\n * @property {Date} [last_accessed_at] - Last access timestamp\n * @property {number} [importance_score] - Predefined importance score\n */\n\n/**\n * @typedef {Object} ContextSnippet\n * @property {CodeEntity} entity - The code entity\n * @property {number} baseRelevance - Base relevance score from initial search\n */\n\n/**\n * @typedef {Object} FocusArea\n * @property {string} focus_id - Unique identifier for the focus area\n * @property {string} focus_type - Type of focus (e.g., 'file', 'function', 'task')\n * @property {string} identifier - Human-readable identifier\n * @property {string} description - Description of the focus area\n * @property {string[]} related_entity_ids - IDs of entities related to this focus\n * @property {string[]} keywords - Keywords associated with this focus area\n */\n\n/**\n * @typedef {Object} RecencyInfo\n * @property {Date} lastAccessedThreshold - Threshold for considering entities as recently accessed\n * @property {Date} [lastModifiedThreshold] - Threshold for considering entities as recently modified\n * @property {number} [recencyBoostFactor] - Factor to boost score for recent entities (default: 1.25)\n */\n\n/**\n * Calculate an importance score for a code entity based on its characteristics.\n * This score is used for prioritizing which entities to include in context.\n *\n * @param {CodeEntity} entity - The code entity to score\n * @returns {Promise<number>} Importance score between 0 and 10\n */\nexport async function calculateImportanceScore(entity) {\n  if (!entity) return 1.0; // Default score if entity is invalid\n\n  try {\n    // 1. Base score by entity type\n    const typeScores = {\n      class: 8.0,\n      interface: 7.5,\n      function: 7.0,\n      method: 6.5,\n      file: 6.0,\n      variable: 5.0,\n      constant: 5.0,\n      comment_block: 4.0,\n    };\n\n    const entityType = (entity.entity_type || \"\").toLowerCase();\n    let score = typeScores[entityType] || 5.0; // Default to 5.0 if type unknown\n\n    // 2. Adjust based on content size/complexity\n    if (entity.raw_content) {\n      const contentLength = entity.raw_content.length;\n      const lineCount = entity.raw_content.split(\"\\n\").length;\n\n      // Small bonus for larger entities (but not too much)\n      // Logarithmic scale to prevent extremely large files from dominating\n      const sizeBonus = Math.min(2.0, Math.log10(contentLength / 100)) * 0.5;\n      score += sizeBonus;\n\n      // Bonus for complexity (rough approximation based on length and patterns)\n      if (\n        entity.raw_content.includes(\"if\") ||\n        entity.raw_content.includes(\"for\") ||\n        entity.raw_content.includes(\"while\") ||\n        entity.raw_content.includes(\"switch\")\n      ) {\n        score += 0.5; // Basic complexity bonus\n      }\n    }\n\n    // 3. Adjust based on references to this entity\n    try {\n      const referenceQuery = `\n        SELECT COUNT(*) as ref_count \n        FROM code_relationships \n        WHERE target_entity_id = ? AND relationship_type = 'references'\n      `;\n\n      const references = await executeQuery(referenceQuery, [entity.entity_id]);\n\n      if (references && references.rows && references.rows.length > 0) {\n        const refCount = parseInt(references.rows[0].ref_count) || 0;\n        // Logarithmic scale to prevent highly referenced entities from completely dominating\n        const refBonus = Math.min(1.5, Math.log10(refCount + 1));\n        score += refBonus;\n      }\n    } catch (error) {\n      // Silently continue without reference bonus if query fails\n      console.warn(\n        `Error fetching references for entity ${entity.entity_id}:`,\n        error.message\n      );\n    }\n\n    // 4. Adjust based on recency\n    const now = new Date();\n    if (entity.last_modified_at) {\n      const lastModified = new Date(entity.last_modified_at);\n      const daysSinceModified = (now - lastModified) / (1000 * 60 * 60 * 24);\n\n      // Recently modified entities get a bonus that decays over time\n      // Full bonus for the first day, decaying to zero after 30 days\n      const recencyBonus = Math.max(0, 1.0 - daysSinceModified / 30);\n      score += recencyBonus;\n    }\n\n    if (entity.last_accessed_at) {\n      const lastAccessed = new Date(entity.last_accessed_at);\n      const daysSinceAccessed = (now - lastAccessed) / (1000 * 60 * 60 * 24);\n\n      // Recently accessed entities get a smaller bonus\n      // Full bonus for the first day, decaying to zero after 14 days\n      const accessBonus = Math.max(0, 0.5 - (daysSinceAccessed / 14) * 0.5);\n      score += accessBonus;\n    }\n\n    // 5. Bonus for top-level entities (not nested)\n    if (!entity.parent_entity_id) {\n      score += 0.5;\n    }\n\n    // 6. Special adjustments for certain entity characteristics\n\n    // Bonus for entities with a name that suggests importance\n    const importantNamePatterns = [\n      \"main\",\n      \"index\",\n      \"core\",\n      \"app\",\n      \"server\",\n      \"controller\",\n      \"service\",\n    ];\n    if (\n      entity.name &&\n      importantNamePatterns.some((pattern) =>\n        entity.name.toLowerCase().includes(pattern)\n      )\n    ) {\n      score += 0.5;\n    }\n\n    // Cap the score at 10\n    return Math.min(10.0, Math.max(0, score));\n  } catch (error) {\n    console.error(\n      `Error calculating importance score for entity ${entity.entity_id}:`,\n      error\n    );\n    return 1.0; // Default fallback score\n  }\n}\n\n/**\n * Score a context snippet based on multiple relevance factors\n *\n * @param {ContextSnippet} snippet - The context snippet to score\n * @param {string[]} queryKeywords - Keywords from the current query\n * @param {FocusArea} currentFocus - Current focus area\n * @param {RecencyInfo} recencyData - Information about recency thresholds\n * @returns {number} Final relevance score\n */\nexport async function scoreContextSnippet(\n  snippet,\n  queryKeywords,\n  currentFocus,\n  recencyData\n) {\n  try {\n    // Define weights for different scoring factors\n    const weights = {\n      baseRelevance: 0.2, // 20% weight for initial relevance\n      queryRelevance: 0.25, // 25% weight for query matching\n      focusAlignment: 0.25, // 25% weight for focus area alignment (reduced from 30%)\n      recency: 0.15, // 15% weight for recency\n      entityType: 0.05, // 5% weight for entity type priority\n      relationshipProximity: 0.1, // 10% weight for relationship proximity (increased from 5%)\n    };\n\n    // 1. Query Relevance\n    const queryRelevanceScore = nonVectorRelevanceScore(\n      snippet.entity,\n      queryKeywords,\n      currentFocus.keywords\n    );\n\n    // 2. Focus Alignment\n    const focusAlignmentScore = calculateFocusAlignmentScore(\n      snippet.entity,\n      currentFocus\n    );\n\n    // 3. Recency\n    const recencyScore = calculateRecencyScore(snippet.entity, recencyData);\n\n    // 4. Entity Type Priority\n    const entityTypePriorityScore = calculateEntityTypePriorityScore(\n      snippet.entity,\n      currentFocus.focus_type\n    );\n\n    // 5. Relationship Proximity (async)\n    const relationshipProximityScore =\n      await calculateRelationshipProximityScore(\n        snippet.entity,\n        currentFocus.related_entity_ids\n      );\n\n    // Combine all factors into a weighted score\n    const finalScore =\n      snippet.baseRelevance * weights.baseRelevance +\n      queryRelevanceScore * weights.queryRelevance +\n      focusAlignmentScore * weights.focusAlignment +\n      recencyScore * weights.recency +\n      entityTypePriorityScore * weights.entityType +\n      relationshipProximityScore * weights.relationshipProximity;\n\n    // Ensure score is between 0 and 1\n    return Math.max(0, Math.min(1, finalScore));\n  } catch (error) {\n    console.error(\"Error scoring context snippet:\", error);\n    // Fall back to base relevance in case of error\n    return snippet.baseRelevance;\n  }\n}\n\n/**\n * Calculate focus alignment score based on the relationship between\n * the entity and the current focus area\n *\n * @param {CodeEntity} entity - The code entity\n * @param {FocusArea} focus - Current focus area\n * @returns {number} Focus alignment score between 0 and 1\n */\nfunction calculateFocusAlignmentScore(entity, focus) {\n  // Highest score if the entity is directly in the focus area's related entities\n  if (focus.related_entity_ids.includes(entity.entity_id)) {\n    return 1.0;\n  }\n\n  // Check parent relationship - high score if parent is in focus\n  if (\n    entity.parent_entity_id &&\n    focus.related_entity_ids.includes(entity.parent_entity_id)\n  ) {\n    return 0.9;\n  }\n\n  // Check if the entity is from the same file as the focus\n  const focusEntityPaths = focus.related_entity_ids.map((id) => {\n    // This is a simplified approach - in practice, you would look up the entity\n    // path from the database or another data structure\n    return id.split(\":\")[0]; // Assuming ID format includes file path\n  });\n\n  if (\n    entity.file_path &&\n    focusEntityPaths.some((path) => entity.file_path.startsWith(path))\n  ) {\n    return 0.7;\n  }\n\n  // Check keyword overlap\n  if (focus.keywords && focus.keywords.length > 0) {\n    const entityText = [entity.name || \"\", entity.raw_content || \"\"]\n      .join(\" \")\n      .toLowerCase();\n\n    const matchingKeywords = focus.keywords.filter((keyword) =>\n      entityText.includes(keyword.toLowerCase())\n    );\n\n    if (matchingKeywords.length > 0) {\n      return 0.5 * (matchingKeywords.length / focus.keywords.length);\n    }\n  }\n\n  // Minimal focus alignment\n  return 0.1;\n}\n\n/**\n * Calculate recency score based on when the entity was last accessed or modified\n *\n * @param {CodeEntity} entity - The code entity\n * @param {RecencyInfo} recencyData - Information about recency thresholds\n * @returns {number} Recency score between 0 and 1\n */\nfunction calculateRecencyScore(entity, recencyData) {\n  const {\n    lastAccessedThreshold,\n    lastModifiedThreshold,\n    recencyBoostFactor = 1.25,\n  } = recencyData;\n  let recencyScore = 0.5; // Default medium score\n\n  // Check if the entity has been accessed recently\n  if (entity.last_accessed_at) {\n    const lastAccessed = new Date(entity.last_accessed_at);\n    if (lastAccessed >= lastAccessedThreshold) {\n      recencyScore = 0.8; // High score for recently accessed entities\n    }\n  }\n\n  // Check if the entity has been modified recently (this takes precedence)\n  if (entity.last_modified_at && lastModifiedThreshold) {\n    const lastModified = new Date(entity.last_modified_at);\n    if (lastModified >= lastModifiedThreshold) {\n      recencyScore = 1.0; // Maximum score for recently modified entities\n    }\n  }\n\n  // Apply recency decay based on time since last access/modification\n  if (entity.last_accessed_at || entity.last_modified_at) {\n    const lastTimepoint = entity.last_modified_at || entity.last_accessed_at;\n    const lastTime = new Date(lastTimepoint);\n    const now = new Date();\n    const daysSince = (now - lastTime) / (1000 * 60 * 60 * 24);\n\n    // Exponential decay: score = baseScore * e^(-daysSince/60)\n    // This gives a decay to ~37% of original value after 60 days\n    const decayFactor = Math.exp(-daysSince / 60);\n    recencyScore *= decayFactor;\n  }\n\n  return recencyScore;\n}\n\n/**\n * Calculate entity type priority score based on entity type and current focus\n *\n * @param {CodeEntity} entity - The code entity\n * @param {string} focusType - Type of the current focus\n * @returns {number} Entity type priority score between 0 and 1\n */\nfunction calculateEntityTypePriorityScore(entity, focusType) {\n  // Base priorities for different entity types\n  const typePriorities = {\n    function: 0.9,\n    class: 0.9,\n    method: 0.85,\n    file: 0.8,\n    variable: 0.7,\n    comment: 0.5,\n    default: 0.6,\n  };\n\n  // Get base priority for this entity type\n  const entityType = (entity.entity_type || \"\").toLowerCase();\n  let typePriority = typePriorities[entityType] || typePriorities.default;\n\n  // Boost priority if the entity type matches the focus type\n  if (entityType === focusType.toLowerCase()) {\n    typePriority = Math.min(1.0, typePriority * 1.2);\n  }\n\n  // Additional context-based adjustments could be added here\n  // For example, if working on a bug fix, error handling code might get a boost\n\n  return typePriority;\n}\n\n/**\n * Calculate relationship proximity score based on relationship to focus entities\n *\n * @param {CodeEntity} entity - The code entity\n * @param {string[]} focusEntityIds - IDs of entities in the current focus\n * @returns {number} Relationship proximity score between 0 and 1\n */\nasync function calculateRelationshipProximityScore(entity, focusEntityIds) {\n  // Return default score if no entity ID or no focus entities\n  if (!entity.entity_id || !focusEntityIds || focusEntityIds.length === 0) {\n    return 0.5; // Default score if there are no focus entities\n  }\n\n  try {\n    // Import necessary modules\n    const { getRelationships, findCodePaths } = await import(\n      \"./RelationshipContextManagerLogic.js\"\n    );\n    const LRUCache = (await import(\"../utils/lru-cache.js\")).default;\n\n    // Create or get the relationship cache (static cache shared across function calls)\n    if (!calculateRelationshipProximityScore.cache) {\n      calculateRelationshipProximityScore.cache = new LRUCache(100); // Cache up to 100 relationship lookups\n    }\n    const cache = calculateRelationshipProximityScore.cache;\n\n    // Check if we have this relationship calculation cached\n    const cacheKey = `${entity.entity_id}:${focusEntityIds.join(\",\")}`;\n    const cachedScore = cache.get(cacheKey);\n    if (cachedScore !== null) {\n      return cachedScore;\n    }\n\n    // Define weights for different relationship types\n    const relationshipTypeWeights = {\n      calls: 1.0, // Direct function calls are very relevant\n      extends: 0.9, // Class inheritance is highly relevant\n      implements: 0.9, // Interface implementation is highly relevant\n      imports: 0.8, // Import relationship is fairly relevant\n      references: 0.7, // References relationship is somewhat relevant\n      depends_on: 0.7, // Dependencies are somewhat relevant\n      contains: 0.6, // Containment is moderately relevant\n      references_variable: 0.5, // Variable references are less relevant\n      default: 0.5, // Default weight for other types\n    };\n\n    // Collect metrics to calculate the final score\n    let totalScore = 0;\n    let relationshipCount = 0;\n    let hasDirectRelationship = false;\n    let hasSecondDegreeRelationship = false;\n\n    // Check for direct (1st-degree) relationships\n    const firstDegreeRelationships = await getRelationships(\n      entity.entity_id,\n      \"both\", // Get both incoming and outgoing relationships\n      [] // All relationship types\n    );\n\n    if (firstDegreeRelationships.length === 0) {\n      // Store in cache and return slightly below default if no relationships exist\n      const score = 0.4;\n      cache.put(cacheKey, score);\n      return score;\n    }\n\n    // Process direct relationships with focus entities\n    const directRelationshipsWithFocus = firstDegreeRelationships.filter(\n      (rel) => {\n        const otherEntityId =\n          rel.source_entity_id === entity.entity_id\n            ? rel.target_entity_id\n            : rel.source_entity_id;\n        return focusEntityIds.includes(otherEntityId);\n      }\n    );\n\n    if (directRelationshipsWithFocus.length > 0) {\n      hasDirectRelationship = true;\n\n      // Calculate score based on relationship types and weights\n      for (const rel of directRelationshipsWithFocus) {\n        const relType = rel.relationship_type;\n        const weight =\n          relationshipTypeWeights[relType] || relationshipTypeWeights.default;\n\n        // Direction matters - outgoing relationships (entity calls/uses focus) are slightly more relevant\n        const directionMultiplier =\n          rel.source_entity_id === entity.entity_id ? 1.0 : 0.9;\n\n        totalScore += weight * directionMultiplier;\n        relationshipCount++;\n      }\n    }\n\n    // Check for 2nd-degree relationships (only if we don't have strong direct relationships)\n    // This is more expensive, so we limit it\n    if (\n      !hasDirectRelationship ||\n      (hasDirectRelationship && directRelationshipsWithFocus.length < 2)\n    ) {\n      // Get all entities related to our entity (1st degree connections)\n      const connectedEntityIds = firstDegreeRelationships.map((rel) =>\n        rel.source_entity_id === entity.entity_id\n          ? rel.target_entity_id\n          : rel.source_entity_id\n      );\n\n      // Check if any focus entity is connected to any of our 1st degree connections\n      // We're limiting this to 5 entities to avoid expensive queries\n      const focusEntitiesToCheck = focusEntityIds.slice(0, 5);\n      const secondDegreeConnectionPromises = [];\n\n      // For each focus entity, check if it has connections to any of our 1st degree connections\n      for (const focusEntityId of focusEntitiesToCheck) {\n        // Skip focus entities that already have direct connections\n        if (\n          directRelationshipsWithFocus.some(\n            (rel) =>\n              rel.source_entity_id === focusEntityId ||\n              rel.target_entity_id === focusEntityId\n          )\n        ) {\n          continue;\n        }\n\n        const promise = getRelationships(focusEntityId, \"both\", []).then(\n          (focusRelationships) => {\n            const secondDegreeConnections = focusRelationships.filter((rel) => {\n              const otherEntityId =\n                rel.source_entity_id === focusEntityId\n                  ? rel.target_entity_id\n                  : rel.source_entity_id;\n              return connectedEntityIds.includes(otherEntityId);\n            });\n\n            if (secondDegreeConnections.length > 0) {\n              hasSecondDegreeRelationship = true;\n\n              // Second-degree relationships are less valuable, so we apply a discount\n              for (const rel of secondDegreeConnections) {\n                const relType = rel.relationship_type;\n                const weight =\n                  relationshipTypeWeights[relType] ||\n                  relationshipTypeWeights.default;\n\n                // Second-degree connections are worth less\n                totalScore += weight * 0.5;\n                relationshipCount++;\n              }\n            }\n          }\n        );\n\n        secondDegreeConnectionPromises.push(promise);\n      }\n\n      // Wait for all second-degree connection checks to complete\n      await Promise.all(secondDegreeConnectionPromises);\n    }\n\n    // For exceptional cases, try to find paths between the entity and important focus entities\n    // This is expensive, so we only do it for a limited number of focus entities and when we don't have many direct relationships\n    if (\n      (!hasDirectRelationship && !hasSecondDegreeRelationship) ||\n      relationshipCount < 2\n    ) {\n      // Only consider the first 2 focus entities for this expensive operation\n      const importantFocusEntities = focusEntityIds.slice(0, 2);\n\n      for (const focusEntityId of importantFocusEntities) {\n        // Try to find paths up to 3 hops away (this can be expensive)\n        try {\n          // Look for important relationship types\n          for (const relType of [\"calls\", \"extends\", \"implements\", \"imports\"]) {\n            const paths = await findCodePaths(\n              entity.entity_id,\n              focusEntityId,\n              relType\n            );\n\n            if (paths.length > 0) {\n              hasSecondDegreeRelationship = true;\n\n              // For each path, calculate a score based on path length\n              for (const path of paths) {\n                const pathLength = path.length;\n                if (pathLength <= 4) {\n                  // Only consider relatively short paths\n                  const pathScore =\n                    relationshipTypeWeights[relType] * (1 / pathLength);\n                  totalScore += pathScore;\n                  relationshipCount++;\n                }\n              }\n\n              // If we found paths, no need to check other relationship types\n              break;\n            }\n          }\n        } catch (error) {\n          console.error(\n            `Error finding code paths for entity ${entity.entity_id}:`,\n            error\n          );\n          // Continue processing other focus entities\n        }\n      }\n    }\n\n    // Calculate final score\n    let finalScore;\n\n    if (relationshipCount === 0) {\n      // No relationships found, return below default\n      finalScore = 0.45;\n    } else {\n      // Normalize the score\n      let normalizedScore = totalScore / relationshipCount;\n\n      // Apply bonuses for direct and indirect relationships\n      if (hasDirectRelationship) {\n        normalizedScore *= 1.2; // 20% boost for direct relationships\n      }\n      if (hasSecondDegreeRelationship) {\n        normalizedScore *= 1.1; // 10% boost for second-degree relationships\n      }\n\n      // Ensure score is between 0 and 1\n      finalScore = Math.min(1.0, normalizedScore);\n    }\n\n    // Cache the result\n    cache.put(cacheKey, finalScore);\n\n    return finalScore;\n  } catch (error) {\n    console.error(\"Error calculating relationship proximity:\", error);\n    return 0.5; // Default score in case of error\n  }\n}\n\n/**\n * Prioritize context snippets based on relevance to query and current focus\n *\n * @param {ContextSnippet[]} contexts - Array of context snippets to prioritize\n * @param {string[]} queryKeywords - Keywords from the current query\n * @param {FocusArea} currentFocus - Current focus area\n * @param {number} maxResults - Maximum number of results to return\n * @returns {Promise<ContextSnippet[]>} Prioritized context snippets\n */\nexport async function prioritizeContexts(\n  contexts,\n  queryKeywords,\n  currentFocus,\n  maxResults\n) {\n  // Create recencyData with default thresholds\n  const recencyData = {\n    lastAccessedThreshold: new Date(Date.now() - 24 * 60 * 60 * 1000), // 24 hours ago\n    lastModifiedThreshold: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // 7 days ago\n    recencyBoostFactor: 1.25,\n  };\n\n  // Score each context snippet\n  const scoredContexts = [];\n\n  for (const snippet of contexts) {\n    try {\n      // Score the snippet\n      const finalScore = await scoreContextSnippet(\n        snippet,\n        queryKeywords,\n        currentFocus,\n        recencyData\n      );\n\n      // Add the score to the snippet object\n      scoredContexts.push({\n        ...snippet,\n        finalScore,\n      });\n    } catch (error) {\n      console.error(`Error scoring context snippet: ${error.message}`);\n      // Include the snippet with its base relevance as fallback\n      scoredContexts.push({\n        ...snippet,\n        finalScore: snippet.baseRelevance || 0,\n      });\n    }\n  }\n\n  // Sort contexts by finalScore in descending order\n  scoredContexts.sort((a, b) => b.finalScore - a.finalScore);\n\n  // Return top maxResults\n  return scoredContexts.slice(0, maxResults);\n}\n\n/**\n * Apply decay to importance scores of all entities that haven't been\n * accessed recently to reflect diminishing relevance over time\n *\n * @returns {Promise<void>}\n */\nexport async function applyDecayToAll() {\n  try {\n    // Define the minimum threshold to prevent scores from becoming too small\n    const MIN_IMPORTANCE_THRESHOLD = 0.1;\n\n    // Define the access threshold (entities not accessed in the last 30 days)\n    const accessThreshold = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n\n    // Construct and execute the SQL query to apply decay\n    const query = `\n      UPDATE code_entities \n      SET importance_score = importance_score * ? \n      WHERE last_accessed_at < ? \n      AND importance_score > ?\n    `;\n\n    const params = [\n      CONTEXT_DECAY_RATE,\n      accessThreshold.toISOString(),\n      MIN_IMPORTANCE_THRESHOLD,\n    ];\n\n    // Execute the query\n    const result = await executeQuery(query, params);\n\n    console.log(`Applied decay to ${result.changes || 0} entities`);\n  } catch (error) {\n    console.error(\"Error applying decay to importance scores:\", error);\n    throw error;\n  }\n}\n", "/**\n * ConversationSegmenter.js\n *\n * Provides functionality to detect topic shifts and segment conversations\n * into coherent topics for better context management.\n */\n\nimport * as TextTokenizerLogic from \"./TextTokenizerLogic.js\";\nimport { executeQuery } from \"../db.js\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport * as ContextCompressorLogic from \"./ContextCompressorLogic.js\";\n\n/**\n * @typedef {Object} Message\n * @property {string} content - The content of the message\n * @property {string} role - The role of the sender (e.g., 'user', 'assistant')\n * @property {Date} [timestamp] - Optional timestamp of the message\n * @property {string[]} [entity_ids] - Optional array of referenced entity IDs\n */\n\n// Conversational shift marker phrases\nconst TOPIC_SHIFT_MARKERS = [\n  \"anyway\",\n  \"moving on\",\n  \"changing subject\",\n  \"regarding\",\n  \"switching to\",\n  \"on another note\",\n  \"back to\",\n  \"speaking of\",\n  \"about\",\n  \"let's talk about\",\n  \"with respect to\",\n  \"turning to\",\n  \"shifting to\",\n  \"let's discuss\",\n  \"instead\",\n];\n\n// Question starters that might indicate new topics\nconst QUESTION_STARTERS = [\n  \"what\",\n  \"how\",\n  \"why\",\n  \"can\",\n  \"could\",\n  \"would\",\n  \"should\",\n  \"is\",\n  \"are\",\n  \"do\",\n  \"does\",\n  \"did\",\n  \"have\",\n  \"has\",\n  \"will\",\n];\n\n/**\n * Detects if a new message represents a significant topic shift\n * compared to the conversation history\n *\n * @param {Message} newMessage - The new message to evaluate\n * @param {Message[]} conversationHistory - Previous messages in the conversation\n * @returns {Promise<boolean>} True if a topic shift is detected, false otherwise\n */\nexport async function detectTopicShift(newMessage, conversationHistory) {\n  try {\n    if (\n      !newMessage?.content ||\n      !conversationHistory ||\n      conversationHistory.length === 0\n    ) {\n      return false;\n    }\n\n    // Only look at recent history (last 5 messages) for comparison\n    const recentHistory = conversationHistory.slice(-5);\n\n    // 1. Keyword novelty detection\n    const keywordNoveltyScore = calculateKeywordNovelty(\n      newMessage,\n      recentHistory\n    );\n\n    // 2. Entity reference shift detection\n    const entityShiftScore = calculateEntityShift(newMessage, recentHistory);\n\n    // 3. Conversational markers detection\n    const hasConversationalMarkers = detectConversationalMarkers(\n      newMessage.content\n    );\n\n    // 4. Question-answer completion detection\n    const questionShiftScore = detectQuestionAnswerShift(\n      newMessage,\n      recentHistory\n    );\n\n    // Combine heuristics with appropriate weights\n    const topicShiftScore =\n      keywordNoveltyScore * 0.4 +\n      entityShiftScore * 0.3 +\n      (hasConversationalMarkers ? 0.8 : 0) * 0.2 +\n      questionShiftScore * 0.1;\n\n    // Return true if the combined score exceeds a threshold\n    return topicShiftScore > 0.45;\n  } catch (error) {\n    console.error(\"Error detecting topic shift:\", error);\n    return false; // Default to no shift on error\n  }\n}\n\n/**\n * Calculates keyword novelty by comparing tokens in new message with recent history\n *\n * @param {Message} newMessage - The new message\n * @param {Message[]} recentHistory - Recent conversation messages\n * @returns {number} Novelty score between 0 and 1\n */\nfunction calculateKeywordNovelty(newMessage, recentHistory) {\n  // Tokenize the new message\n  const newTokens = TextTokenizerLogic.tokenize(newMessage.content);\n\n  // Extract significant keywords from the new message\n  const newKeywords = TextTokenizerLogic.extractKeywords(newTokens, 10);\n  const newKeywordSet = new Set(newKeywords);\n\n  if (newKeywordSet.size === 0) {\n    return 0; // No significant keywords to compare\n  }\n\n  // Build a set of all keywords from recent history\n  const historyKeywordSet = new Set();\n  for (const message of recentHistory) {\n    const historyTokens = TextTokenizerLogic.tokenize(message.content);\n    const historyKeywords = TextTokenizerLogic.extractKeywords(\n      historyTokens,\n      10\n    );\n    historyKeywords.forEach((keyword) => historyKeywordSet.add(keyword));\n  }\n\n  // Count how many new keywords are novel (not in history)\n  let novelKeywordCount = 0;\n  for (const keyword of newKeywordSet) {\n    if (!historyKeywordSet.has(keyword)) {\n      novelKeywordCount++;\n    }\n  }\n\n  // Calculate novelty ratio: novel keywords / total keywords\n  return novelKeywordCount / newKeywordSet.size;\n}\n\n/**\n * Calculates entity reference shift by comparing entity IDs mentioned\n * in new message vs. recent history\n *\n * @param {Message} newMessage - The new message\n * @param {Message[]} recentHistory - Recent conversation messages\n * @returns {number} Entity shift score between 0 and 1\n */\nfunction calculateEntityShift(newMessage, recentHistory) {\n  // If entity_ids are not available, return 0\n  if (\n    !newMessage.entity_ids ||\n    !Array.isArray(newMessage.entity_ids) ||\n    newMessage.entity_ids.length === 0\n  ) {\n    return 0;\n  }\n\n  // Build a set of all entity IDs from recent history\n  const historyEntitySet = new Set();\n  for (const message of recentHistory) {\n    if (message.entity_ids && Array.isArray(message.entity_ids)) {\n      message.entity_ids.forEach((id) => historyEntitySet.add(id));\n    }\n  }\n\n  // If no entities in history, any entity in new message is a shift\n  if (historyEntitySet.size === 0) {\n    return newMessage.entity_ids.length > 0 ? 1 : 0;\n  }\n\n  // Count new entities not present in history\n  let newEntityCount = 0;\n  for (const entityId of newMessage.entity_ids) {\n    if (!historyEntitySet.has(entityId)) {\n      newEntityCount++;\n    }\n  }\n\n  // Calculate entity shift ratio: new entities / total entities\n  return newEntityCount / newMessage.entity_ids.length;\n}\n\n/**\n * Detects conversational markers indicating topic shifts\n *\n * @param {string} messageContent - The content of the message\n * @returns {boolean} True if shift markers are found\n */\nfunction detectConversationalMarkers(messageContent) {\n  if (!messageContent) return false;\n\n  const lowerContent = messageContent.toLowerCase();\n\n  // Check for topic shift marker phrases\n  for (const marker of TOPIC_SHIFT_MARKERS) {\n    // Look for the marker as a whole word\n    const regex = new RegExp(`\\\\b${marker}\\\\b`, \"i\");\n    if (regex.test(lowerContent)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Detects if there's a shift in question patterns, indicating topic change\n *\n * @param {Message} newMessage - The new message\n * @param {Message[]} recentHistory - Recent conversation messages\n * @returns {number} Question shift score between 0 and 1\n */\nfunction detectQuestionAnswerShift(newMessage, recentHistory) {\n  // Check if new message is a question\n  const isNewMessageQuestion = isQuestion(newMessage.content);\n\n  if (!isNewMessageQuestion) {\n    return 0; // Not a question, so no question shift\n  }\n\n  // Check recent conversation flow\n  let previousQuestionCount = 0;\n  let questionAnswerPairCount = 0;\n\n  // Evaluate if we have a sequence of Q&A pairs\n  for (let i = 0; i < recentHistory.length - 1; i++) {\n    if (\n      recentHistory[i].role === \"user\" &&\n      isQuestion(recentHistory[i].content)\n    ) {\n      previousQuestionCount++;\n\n      // Check if next message is an answer (from assistant)\n      if (\n        i + 1 < recentHistory.length &&\n        recentHistory[i + 1].role === \"assistant\"\n      ) {\n        questionAnswerPairCount++;\n      }\n    }\n  }\n\n  // If we've had a series of Q&A exchanges and a new question appears,\n  // it's more likely to be a topic shift\n  if (previousQuestionCount > 0 && questionAnswerPairCount > 0) {\n    // Compare the question type/subject of the new question vs. previous questions\n    const lastUserQuestionIndex = findLastIndex(\n      recentHistory,\n      (msg) => msg.role === \"user\" && isQuestion(msg.content)\n    );\n\n    if (lastUserQuestionIndex >= 0) {\n      const lastUserQuestion = recentHistory[lastUserQuestionIndex].content;\n      return calculateQuestionDifference(newMessage.content, lastUserQuestion);\n    }\n  }\n\n  return 0.2; // Default modest score if it's a new question\n}\n\n/**\n * Determines if a message is a question\n *\n * @param {string} content - Message content\n * @returns {boolean} True if it appears to be a question\n */\nfunction isQuestion(content) {\n  if (!content) return false;\n\n  // Check for question marks\n  if (content.includes(\"?\")) {\n    return true;\n  }\n\n  // Check for question starter words\n  const lowerContent = content.toLowerCase().trim();\n  for (const starter of QUESTION_STARTERS) {\n    if (lowerContent.startsWith(starter + \" \")) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Calculates the difference between two questions to detect topic shift\n *\n * @param {string} newQuestion - The new question\n * @param {string} previousQuestion - A previous question from history\n * @returns {number} Difference score between 0 and 1\n */\nfunction calculateQuestionDifference(newQuestion, previousQuestion) {\n  const newTokens = TextTokenizerLogic.tokenize(newQuestion);\n  const prevTokens = TextTokenizerLogic.tokenize(previousQuestion);\n\n  // Use Jaccard similarity to compare question content\n  const newSet = new Set(newTokens);\n  const prevSet = new Set(prevTokens);\n\n  // Calculate intersection size\n  let intersectionSize = 0;\n  for (const token of newSet) {\n    if (prevSet.has(token)) {\n      intersectionSize++;\n    }\n  }\n\n  // Calculate union size\n  const unionSize = newSet.size + prevSet.size - intersectionSize;\n\n  // Jaccard similarity: intersection size / union size\n  const similarity = unionSize > 0 ? intersectionSize / unionSize : 0;\n\n  // Return difference (1 - similarity)\n  return 1 - similarity;\n}\n\n/**\n * Custom implementation of findLastIndex for compatibility\n *\n * @param {Array} array - The array to search\n * @param {Function} predicate - The predicate function\n * @returns {number} The last matching index or -1 if not found\n */\nfunction findLastIndex(array, predicate) {\n  for (let i = array.length - 1; i >= 0; i--) {\n    if (predicate(array[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Creates a new topic segment in the conversation\n *\n * @param {string} conversationId - ID of the conversation\n * @param {string} startMessageId - ID of the message where the topic starts\n * @param {Object} topicInfo - Information about the topic\n * @param {string} [topicInfo.name] - Optional name for the topic\n * @param {string} [topicInfo.description] - Optional description of the topic\n * @param {string[]} [topicInfo.primaryEntities] - Optional list of primary entity IDs for this topic\n * @param {string[]} [topicInfo.keywords] - Optional list of keywords characterizing this topic\n * @returns {Promise<string>} The ID of the newly created topic segment\n */\nexport async function createNewTopicSegment(\n  conversationId,\n  startMessageId,\n  topicInfo = {}\n) {\n  try {\n    // 1. Generate UUID for the topic\n    const topic_id = uuidv4();\n\n    // 2. Determine topic name\n    let topic_name = topicInfo.name;\n    if (!topic_name) {\n      // If no name provided, use a timestamp-based placeholder\n      // In a real implementation, we'd call generateTopicName() here\n      topic_name = `New Topic ${new Date().toISOString()}`;\n\n      // Alternatively, try to extract from the start message content\n      try {\n        const messageQuery =\n          \"SELECT content FROM conversation_history WHERE message_id = ?\";\n        const messageResult = await executeQuery(messageQuery, [\n          startMessageId,\n        ]);\n\n        if (messageResult && messageResult.length > 0) {\n          const content = messageResult[0].content;\n          // Use first few words (up to 5) as a generic name\n          const words = content.split(/\\s+/).slice(0, 5).join(\" \");\n          if (words.length > 3) {\n            topic_name = `Topic: ${words}${\n              words.length < content.length ? \"...\" : \"\"\n            }`;\n          }\n        }\n      } catch (error) {\n        console.warn(\n          \"Could not fetch message content for topic naming:\",\n          error\n        );\n        // Fall back to the timestamp-based name already set\n      }\n    }\n\n    // 3. Prepare entities and keywords as JSON strings\n    const primary_entities = topicInfo.primaryEntities\n      ? JSON.stringify(topicInfo.primaryEntities)\n      : \"[]\";\n\n    const keywords = topicInfo.keywords\n      ? JSON.stringify(topicInfo.keywords)\n      : \"[]\";\n\n    // 4. Get current timestamp for start_timestamp\n    const start_timestamp = new Date().toISOString();\n\n    // 5. Insert the new topic into the database\n    // Try to disable foreign key constraints temporarily\n    await executeQuery(\"PRAGMA foreign_keys = OFF;\");\n\n    const insertQuery = `\n      INSERT INTO conversation_topics (\n        topic_id,\n        conversation_id,\n        topic_name,\n        description,\n        start_message_id,\n        start_timestamp,\n        primary_entities,\n        keywords\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n    `;\n\n    const params = [\n      topic_id,\n      conversationId,\n      topic_name,\n      topicInfo.description || \"\",\n      startMessageId,\n      start_timestamp,\n      primary_entities,\n      keywords,\n    ];\n\n    await executeQuery(insertQuery, params);\n\n    // Re-enable foreign key constraints\n    await executeQuery(\"PRAGMA foreign_keys = ON;\");\n\n    console.log(`Created new topic segment: ${topic_name} (${topic_id})`);\n\n    // 6. Return the topic_id\n    return topic_id;\n  } catch (error) {\n    console.error(\"Error creating new topic segment:\", error);\n    throw new Error(`Failed to create new topic segment: ${error.message}`);\n  }\n}\n\n/**\n * Closes a topic segment by setting its end message and timestamp\n *\n * @param {string} topicId - ID of the topic segment to close\n * @param {string} endMessageId - ID of the message where the topic ends\n * @returns {Promise<void>}\n */\nexport async function closeTopicSegment(topicId, endMessageId) {\n  try {\n    // 1. Get current timestamp for end_timestamp\n    const end_timestamp = new Date().toISOString();\n\n    // 2. Try to get message timestamp if available\n    let messageTimestamp = end_timestamp;\n    try {\n      const messageQuery =\n        \"SELECT timestamp FROM conversation_history WHERE message_id = ?\";\n      const messageResult = await executeQuery(messageQuery, [endMessageId]);\n\n      if (\n        messageResult &&\n        messageResult.length > 0 &&\n        messageResult[0].timestamp\n      ) {\n        messageTimestamp = messageResult[0].timestamp;\n      }\n    } catch (error) {\n      console.warn(\n        \"Could not fetch message timestamp, using current timestamp:\",\n        error\n      );\n      // Continue with the current timestamp that we've already set\n    }\n\n    // 3. Update the topic record in the database\n    const updateQuery = `\n      UPDATE conversation_topics\n      SET end_message_id = ?,\n          end_timestamp = ?\n      WHERE topic_id = ?\n    `;\n\n    const params = [endMessageId, messageTimestamp, topicId];\n\n    await executeQuery(updateQuery, params);\n\n    console.log(\n      `Closed topic segment: ${topicId} with end message: ${endMessageId}`\n    );\n\n    // 4. Generate topic summary (Note: Implementation not provided yet)\n    // This would be a good place to call a function like:\n    // await summarizeTopicSegment(topicId);\n  } catch (error) {\n    console.error(`Error closing topic segment ${topicId}:`, error);\n    throw new Error(`Failed to close topic segment: ${error.message}`);\n  }\n}\n\n/**\n * @typedef {Object} Topic\n * @property {string} topic_id - Unique identifier for the topic\n * @property {string} conversation_id - ID of the conversation this topic belongs to\n * @property {string} topic_name - Name of the topic\n * @property {string} description - Description of the topic\n * @property {string} start_message_id - ID of the message where the topic starts\n * @property {string} start_timestamp - Timestamp when the topic started\n * @property {string|null} end_message_id - ID of the message where the topic ends (null if active)\n * @property {string|null} end_timestamp - Timestamp when the topic ended (null if active)\n * @property {string[]} primary_entities - List of primary entity IDs for this topic\n * @property {string[]} keywords - List of keywords characterizing this topic\n */\n\n/**\n * Gets the active (most recent, non-ended) topic segment for a conversation\n *\n * @param {string} conversationId - Conversation ID\n * @returns {Promise<object|null>} The active topic segment or null\n */\nexport async function getActiveTopicForConversation(conversationId) {\n  try {\n    // Get the active topic\n    const query = `\n      SELECT * FROM conversation_topics\n      WHERE conversation_id = ?\n        AND end_message_id IS NULL\n      ORDER BY start_timestamp DESC\n      LIMIT 1\n    `;\n\n    const result = await executeQuery(query, [conversationId]);\n\n    if (!result.rows || result.rows.length === 0) {\n      return null;\n    }\n\n    // Convert the JSON fields back to objects\n    const topic = result.rows[0];\n\n    try {\n      // Create a new object for parsed fields to avoid modifying read-only properties\n      const parsedTopic = { ...topic };\n\n      // Parse JSON fields if they exist and are strings\n      if (topic.keywords && typeof topic.keywords === \"string\") {\n        parsedTopic.keywords = JSON.parse(topic.keywords);\n      }\n\n      if (\n        topic.related_entities &&\n        typeof topic.related_entities === \"string\"\n      ) {\n        parsedTopic.related_entities = JSON.parse(topic.related_entities);\n      }\n\n      if (\n        topic.primary_entities &&\n        typeof topic.primary_entities === \"string\"\n      ) {\n        parsedTopic.primary_entities = JSON.parse(topic.primary_entities);\n      }\n\n      return parsedTopic;\n    } catch (parseError) {\n      console.error(\n        `Error parsing JSON fields for topic ${topic.topic_id}:`,\n        parseError\n      );\n      // Return the original topic without attempting to parse JSON fields\n      return topic;\n    }\n  } catch (error) {\n    console.error(\n      `Error getting active topic for conversation ${conversationId}:`,\n      error\n    );\n    throw error;\n  }\n}\n\n/**\n * Generates a summary for a topic segment and updates the topic record\n *\n * @param {string} topicId - ID of the topic to summarize\n * @returns {Promise<string>} The generated summary\n */\nexport async function summarizeTopicSegment(topicId) {\n  try {\n    // 1. Get all messages belonging to this topic\n    const messages = await getTopicSegmentMessages(topicId);\n\n    if (!messages || messages.length === 0) {\n      const noMessagesWarning = \"No messages found for topic summarization\";\n      console.warn(noMessagesWarning);\n      return noMessagesWarning;\n    }\n\n    // 2. Concatenate the content of these messages\n    const concatenatedContent = messages\n      .map((msg) => {\n        // Format each message with role information\n        return `${msg.role}: ${msg.content}`;\n      })\n      .join(\"\\n\\n\");\n\n    // 3. Use ContextCompressorLogic to generate a summary\n    const summary = await ContextCompressorLogic.summarizeText(\n      concatenatedContent,\n      {\n        targetLength: 150, // Target 150 characters for the summary\n        preserveKeyPoints: true,\n      }\n    );\n\n    // 4. Update the topic record with the summary\n    const updateQuery = `\n      UPDATE conversation_topics\n      SET summary = ?\n      WHERE topic_id = ?\n    `;\n\n    await executeQuery(updateQuery, [summary, topicId]);\n\n    console.log(\n      `Topic ${topicId} summary generated and stored: ${summary.substring(\n        0,\n        50\n      )}...`\n    );\n\n    // 5. Return the generated summary\n    return summary;\n  } catch (error) {\n    console.error(`Error summarizing topic segment ${topicId}:`, error);\n    throw new Error(`Failed to summarize topic segment: ${error.message}`);\n  }\n}\n\n/**\n * Gets all messages belonging to a topic segment\n *\n * @param {string} topicId - ID of the topic\n * @returns {Promise<Array<Message>>} Array of messages with parsed JSON fields\n */\nexport async function getTopicSegmentMessages(topicId) {\n  try {\n    // Query conversation_history table directly using topic_segment_id\n    const messagesQuery = `\n      SELECT * FROM conversation_history \n      WHERE topic_segment_id = ? \n      ORDER BY timestamp ASC\n    `;\n\n    const messages = await executeQuery(messagesQuery, [topicId]);\n\n    if (!messages || messages.length === 0) {\n      return [];\n    }\n\n    // Parse JSON fields for each message\n    return messages.map((message) => {\n      try {\n        // Parse related_context_entity_ids JSON field\n        if (message.related_context_entity_ids) {\n          message.related_context_entity_ids = JSON.parse(\n            message.related_context_entity_ids\n          );\n        } else {\n          message.related_context_entity_ids = [];\n        }\n\n        // Parse semantic_markers JSON field\n        if (message.semantic_markers) {\n          message.semantic_markers = JSON.parse(message.semantic_markers);\n        } else {\n          message.semantic_markers = [];\n        }\n\n        // Parse sentiment_indicators JSON field\n        if (message.sentiment_indicators) {\n          message.sentiment_indicators = JSON.parse(\n            message.sentiment_indicators\n          );\n        } else {\n          message.sentiment_indicators = {};\n        }\n\n        return message;\n      } catch (jsonError) {\n        console.warn(\n          `Error parsing JSON fields for message ${message.message_id}:`,\n          jsonError\n        );\n        // Return message with default empty values for JSON fields\n        return {\n          ...message,\n          related_context_entity_ids: message.related_context_entity_ids || [],\n          semantic_markers: message.semantic_markers || [],\n          sentiment_indicators: message.sentiment_indicators || {},\n        };\n      }\n    });\n  } catch (error) {\n    console.error(`Error getting messages for topic ${topicId}:`, error);\n    throw new Error(`Failed to get topic messages: ${error.message}`);\n  }\n}\n\n/**\n * Generates a concise, descriptive topic name from a set of messages\n *\n * @param {string[]} messageIds - Array of message IDs to generate a topic name from\n * @returns {Promise<string>} A concise topic name\n */\nexport async function generateTopicName(messageIds) {\n  try {\n    if (!messageIds || messageIds.length === 0) {\n      return \"Untitled Topic\";\n    }\n\n    // 1. Fetch the content of messages\n    const placeholders = messageIds.map(() => \"?\").join(\",\");\n    const messagesQuery = `\n      SELECT content, related_context_entity_ids\n      FROM conversation_history \n      WHERE message_id IN (${placeholders})\n      ORDER BY timestamp ASC\n    `;\n\n    const messages = await executeQuery(messagesQuery, messageIds);\n\n    if (!messages || messages.length === 0) {\n      return \"Untitled Topic\";\n    }\n\n    // 2. Concatenate message contents\n    const concatenatedContent = messages.map((msg) => msg.content).join(\" \");\n\n    // 3. Tokenize the content\n    const tokens = TextTokenizerLogic.tokenize(concatenatedContent);\n\n    // 4. Extract keywords from the content\n    const keywords = TextTokenizerLogic.extractKeywords(tokens, 3);\n\n    // 5. Check for entity references in the messages\n    const entityReferences = new Set();\n    for (const message of messages) {\n      if (message.related_context_entity_ids) {\n        let entityIds;\n        try {\n          entityIds =\n            typeof message.related_context_entity_ids === \"string\"\n              ? JSON.parse(message.related_context_entity_ids)\n              : message.related_context_entity_ids;\n\n          if (Array.isArray(entityIds) && entityIds.length > 0) {\n            // Get entity names for up to 2 entities\n            const entityIds = entityIds.slice(0, 2);\n            const entityQuery = `\n              SELECT name FROM code_entities WHERE id IN (${entityIds\n                .map(() => \"?\")\n                .join(\",\")})\n            `;\n\n            const entities = await executeQuery(entityQuery, entityIds);\n            if (entities && entities.length > 0) {\n              entities.forEach((entity) => entityReferences.add(entity.name));\n            }\n          }\n        } catch (err) {\n          console.warn(\"Error parsing entity IDs\", err);\n        }\n      }\n    }\n\n    // 6. Formulate a topic name\n    let topicName;\n\n    // If we have entity references, prioritize those\n    if (entityReferences.size > 0) {\n      const entityNames = Array.from(entityReferences).slice(0, 2);\n      topicName = `Discussion about ${entityNames.join(\" and \")}`;\n    }\n    // Otherwise use the keywords\n    else if (keywords.length > 0) {\n      topicName = `Topic: ${keywords.join(\", \")}`;\n    }\n    // Fallback to using the first message\n    else {\n      // Get first few significant words from the initial message\n      const firstMsg = messages[0].content;\n      const firstFewWords = firstMsg.split(/\\s+/).slice(0, 5).join(\" \");\n      topicName = `Topic: ${firstFewWords}${\n        firstMsg.length > firstFewWords.length ? \"...\" : \"\"\n      }`;\n    }\n\n    // 7. Ensure topic name is not too long\n    if (topicName.length > 50) {\n      topicName = topicName.substring(0, 47) + \"...\";\n    }\n\n    return topicName;\n  } catch (error) {\n    console.error(`Error generating topic name:`, error);\n    return \"Untitled Topic\";\n  }\n}\n\n/**\n * Builds a hierarchical representation of topics in a conversation\n *\n * @param {string} conversationId - ID of the conversation\n * @returns {Promise<{rootTopics: Topic[], topicMap: Record<string, Topic>}>} Hierarchical topic structure\n */\nexport async function buildTopicHierarchy(conversationId) {\n  try {\n    // 1. Fetch all topics for the conversation, ordered by start_timestamp\n    const query = `\n      SELECT * FROM conversation_topics\n      WHERE conversation_id = ?\n      ORDER BY start_timestamp ASC\n    `;\n\n    const topics = await executeQuery(query, [conversationId]);\n\n    if (!topics || topics.length === 0) {\n      return { rootTopics: [], topicMap: {} };\n    }\n\n    // 2. Create the topic map and parse JSON fields\n    const topicMap = {};\n\n    for (const topic of topics) {\n      // Parse JSON fields\n      try {\n        // Parse primary_entities JSON string to array\n        topic.primary_entities = topic.primary_entities\n          ? JSON.parse(topic.primary_entities)\n          : [];\n\n        // Parse keywords JSON string to array\n        topic.keywords = topic.keywords ? JSON.parse(topic.keywords) : [];\n\n        // Add children array to each topic\n        topic.children = [];\n\n        // Add to topic map\n        topicMap[topic.topic_id] = topic;\n      } catch (jsonError) {\n        console.warn(\n          `Error parsing JSON fields for topic ${topic.topic_id}:`,\n          jsonError\n        );\n        // Provide default empty arrays if JSON parsing fails\n        topic.primary_entities = [];\n        topic.keywords = [];\n        topic.children = [];\n\n        // Still add to map even with parse error\n        topicMap[topic.topic_id] = topic;\n      }\n    }\n\n    // 3. Build the hierarchy by connecting parents and children\n    const rootTopics = [];\n\n    for (const topic of topics) {\n      if (topic.parent_topic_id && topicMap[topic.parent_topic_id]) {\n        // Add this topic as a child of its parent\n        topicMap[topic.parent_topic_id].children.push(topic);\n      } else {\n        // This is a root topic (no parent or parent not in the map)\n        rootTopics.push(topic);\n      }\n    }\n\n    return { rootTopics, topicMap };\n  } catch (error) {\n    console.error(\n      `Error building topic hierarchy for conversation ${conversationId}:`,\n      error\n    );\n    throw new Error(`Failed to build topic hierarchy: ${error.message}`);\n  }\n}\n\n/**\n * Gets all topics for a specific conversation\n *\n * @param {string} conversationId - ID of the conversation\n * @param {boolean} [activeOnly=false] - If true, only return active (not closed) topics\n * @returns {Promise<Array<Topic>>} Array of topic objects\n */\nexport async function getTopicsForConversation(\n  conversationId,\n  activeOnly = false\n) {\n  try {\n    // Build the query with optional filter for active topics\n    let query = `\n      SELECT * FROM conversation_topics\n      WHERE conversation_id = ?\n    `;\n\n    if (activeOnly) {\n      query += ` AND end_message_id IS NULL`;\n    }\n\n    query += ` ORDER BY start_timestamp ASC`;\n\n    const result = await executeQuery(query, [conversationId]);\n\n    // If no topics found, return empty array\n    if (\n      !result ||\n      !result.rows ||\n      !Array.isArray(result.rows) ||\n      result.rows.length === 0\n    ) {\n      return [];\n    }\n\n    // Parse JSON fields for each topic\n    return result.rows.map((topic) => {\n      try {\n        // Parse JSON string fields\n        return {\n          ...topic,\n          primary_entities: topic.primary_entities\n            ? JSON.parse(topic.primary_entities)\n            : [],\n          keywords: topic.keywords ? JSON.parse(topic.keywords) : [],\n        };\n      } catch (jsonError) {\n        console.warn(\n          `Error parsing JSON fields for topic ${topic.topic_id}:`,\n          jsonError\n        );\n        // Return topic with default empty arrays for JSON fields\n        return {\n          ...topic,\n          primary_entities: [],\n          keywords: [],\n        };\n      }\n    });\n  } catch (error) {\n    console.error(\n      `Error getting topics for conversation ${conversationId}:`,\n      error\n    );\n    throw new Error(`Failed to get conversation topics: ${error.message}`);\n  }\n}\n", "/**\n * ConversationPurposeDetector.js\n *\n * Provides functionality to detect the purpose or intent of a conversation\n * by analyzing message content and patterns.\n */\n\nimport * as TextTokenizerLogic from \"./TextTokenizerLogic.js\";\nimport { executeQuery } from \"../db.js\";\nimport { v4 as uuidv4 } from \"uuid\";\n\n/**\n * @typedef {Object} Message\n * @property {string} content - The content of the message\n * @property {string} role - The role of the sender (e.g., 'user', 'assistant')\n * @property {Date} [timestamp] - Optional timestamp of the message\n * @property {string[]} [entity_ids] - Optional array of referenced entity IDs\n */\n\n/**\n * Purpose types with associated keywords and patterns\n */\nconst PURPOSE_TYPES = {\n  debugging: {\n    keywords: [\n      \"error\",\n      \"stacktrace\",\n      \"bug\",\n      \"fix\",\n      \"not working\",\n      \"exception\",\n      \"issue\",\n      \"failed\",\n      \"failing\",\n      \"crash\",\n      \"debug\",\n      \"broken\",\n      \"incorrect\",\n      \"problem\",\n      \"trouble\",\n      \"unexpected\",\n      \"diagnose\",\n      \"investigate\",\n    ],\n    patterns: [\n      /TypeError:/i,\n      /Error:/i,\n      /Exception:/i,\n      /failed with/i,\n      /doesn't work/i,\n      /not working/i,\n      /unexpected behavior/i,\n    ],\n    weight: 1.0,\n  },\n\n  feature_planning: {\n    keywords: [\n      \"requirement\",\n      \"design\",\n      \"new feature\",\n      \"implement\",\n      \"proposal\",\n      \"roadmap\",\n      \"spec\",\n      \"specification\",\n      \"plan\",\n      \"architecture\",\n      \"blueprint\",\n      \"feature\",\n      \"enhancement\",\n      \"improvement\",\n      \"add\",\n      \"create\",\n      \"develop\",\n      \"extend\",\n    ],\n    patterns: [\n      /could we add/i,\n      /we need to implement/i,\n      /design for/i,\n      /planning to/i,\n      /we should build/i,\n      /requirement is to/i,\n    ],\n    weight: 0.9,\n  },\n\n  code_review: {\n    keywords: [\n      \"PR\",\n      \"pull request\",\n      \"LGTM\",\n      \"suggestion\",\n      \"change request\",\n      \"review\",\n      \"approve\",\n      \"feedback\",\n      \"comment\",\n      \"revision\",\n      \"looks good\",\n      \"merge\",\n      \"style\",\n      \"convention\",\n      \"readability\",\n      \"clarity\",\n    ],\n    patterns: [\n      /pull request #\\d+/i,\n      /PR #\\d+/i,\n      /please review/i,\n      /looks good to me/i,\n      /suggested changes/i,\n      /can you review/i,\n    ],\n    weight: 0.85,\n  },\n\n  learning: {\n    keywords: [\n      \"learn\",\n      \"understand\",\n      \"explanation\",\n      \"tutorial\",\n      \"example\",\n      \"how does\",\n      \"what is\",\n      \"meaning\",\n      \"concept\",\n      \"definition\",\n      \"help me understand\",\n      \"documentation\",\n      \"guide\",\n      \"explain\",\n      \"clarify\",\n      \"teach\",\n    ],\n    patterns: [\n      /how does (it|this) work/i,\n      /what (is|does|are)/i,\n      /could you explain/i,\n      /I'm trying to understand/i,\n      /explain how/i,\n    ],\n    weight: 0.8,\n  },\n\n  code_generation: {\n    keywords: [\n      \"generate\",\n      \"create\",\n      \"build\",\n      \"write\",\n      \"implement\",\n      \"code for\",\n      \"function\",\n      \"class\",\n      \"method\",\n      \"module\",\n      \"script\",\n      \"algorithm\",\n      \"solution\",\n    ],\n    patterns: [\n      /can you (write|create|generate)/i,\n      /implement a/i,\n      /create a function/i,\n      /generate code for/i,\n      /need code to/i,\n    ],\n    weight: 0.9,\n  },\n\n  optimization: {\n    keywords: [\n      \"optimize\",\n      \"performance\",\n      \"efficiency\",\n      \"slow\",\n      \"faster\",\n      \"speed up\",\n      \"reduce\",\n      \"improve\",\n      \"bottleneck\",\n      \"memory\",\n      \"CPU\",\n      \"utilization\",\n      \"profiling\",\n      \"benchmark\",\n    ],\n    patterns: [\n      /too slow/i,\n      /needs to be faster/i,\n      /performance issue/i,\n      /optimize for/i,\n      /reduce (memory|time|usage)/i,\n    ],\n    weight: 0.85,\n  },\n\n  refactoring: {\n    keywords: [\n      \"refactor\",\n      \"restructure\",\n      \"rewrite\",\n      \"reorganize\",\n      \"clean up\",\n      \"improve\",\n      \"modernize\",\n      \"update\",\n      \"simplify\",\n      \"decouple\",\n      \"modularity\",\n      \"readability\",\n    ],\n    patterns: [\n      /need to refactor/i,\n      /code smells/i,\n      /technical debt/i,\n      /simplify the code/i,\n      /make it more maintainable/i,\n    ],\n    weight: 0.8,\n  },\n\n  general_query: {\n    keywords: [\n      \"question\",\n      \"ask\",\n      \"wondering\",\n      \"curious\",\n      \"thoughts\",\n      \"opinion\",\n      \"advice\",\n      \"suggestion\",\n      \"recommend\",\n      \"help\",\n      \"guidance\",\n    ],\n    patterns: [\n      /I have a question/i,\n      /can you help/i,\n      /what do you think/i,\n      /do you have any advice/i,\n    ],\n    weight: 0.7, // Lower weight as this is the default fallback\n  },\n};\n\n/**\n * Detects the primary purpose of a conversation by analyzing message content\n *\n * @param {Message|Message[]} messages - Message or array of conversation messages to analyze\n * @returns {Promise<{purposeType: string, confidence: number}>} The detected purpose and confidence score\n */\nexport async function detectConversationPurpose(messages) {\n  try {\n    if (!messages) {\n      return { purposeType: \"general_query\", confidence: 0.5 };\n    }\n\n    // Normalize input to always be an array\n    const messageArray = Array.isArray(messages) ? messages : [messages];\n\n    if (messageArray.length === 0) {\n      return { purposeType: \"general_query\", confidence: 0.5 };\n    }\n\n    // 1. Concatenate the content of messages, giving priority to user messages\n    let concatenatedContent = \"\";\n    // Convert message format if it's from database (with messageId vs id)\n    const normalizedMessages = messageArray.map((msg) => ({\n      role: msg.role || (msg.messageId ? \"user\" : \"user\"), // Default to user if role is missing\n      content: msg.content || \"\",\n    }));\n\n    const userMessages = normalizedMessages.filter(\n      (msg) => msg.role === \"user\"\n    );\n\n    if (userMessages.length > 0) {\n      // If we have user messages, prioritize those\n      concatenatedContent = userMessages.map((msg) => msg.content).join(\" \");\n    } else {\n      // Otherwise use all messages\n      concatenatedContent = normalizedMessages\n        .map((msg) => msg.content)\n        .join(\" \");\n    }\n\n    // 2. Tokenize and extract keywords\n    const tokens = TextTokenizerLogic.tokenize(concatenatedContent);\n    const extractedKeywords = TextTokenizerLogic.extractKeywords(tokens, 20);\n\n    // 3. Score each purpose type\n    const purposeScores = {};\n\n    for (const [purposeType, purposeData] of Object.entries(PURPOSE_TYPES)) {\n      let score = 0;\n\n      // Score based on keyword matches\n      for (const keyword of purposeData.keywords) {\n        if (concatenatedContent.toLowerCase().includes(keyword.toLowerCase())) {\n          score += 1;\n        }\n\n        // Check for keyword in extracted keywords (stronger signal)\n        if (\n          extractedKeywords.some(\n            (k) =>\n              typeof k === \"string\" && k.toLowerCase() === keyword.toLowerCase()\n          )\n        ) {\n          score += 2;\n        }\n      }\n\n      // Score based on pattern matches\n      for (const pattern of purposeData.patterns) {\n        if (pattern.test(concatenatedContent)) {\n          score += 3; // Patterns are stronger signals\n        }\n      }\n\n      // Apply purpose-specific weight\n      score *= purposeData.weight;\n\n      // Store the score\n      purposeScores[purposeType] = score;\n    }\n\n    // 4. Find the purpose with the highest score\n    let highestScore = 0;\n    let detectedPurpose = \"general_query\"; // Default\n\n    for (const [purposeType, score] of Object.entries(purposeScores)) {\n      if (score > highestScore) {\n        highestScore = score;\n        detectedPurpose = purposeType;\n      }\n    }\n\n    // 5. Calculate confidence (normalize score)\n    // Find max possible score for the detected purpose type\n    const maxPossibleScore =\n      PURPOSE_TYPES[detectedPurpose].keywords.length * 3 + // Max keyword match score\n      PURPOSE_TYPES[detectedPurpose].patterns.length * 3; // Max pattern match score\n\n    // Normalize the confidence between 0 and 1\n    // Add a base confidence of 0.3 so it's never too low\n    let confidence =\n      0.3 +\n      0.7 *\n        (highestScore /\n          (maxPossibleScore * PURPOSE_TYPES[detectedPurpose].weight));\n\n    // Cap confidence at 1.0\n    confidence = Math.min(confidence, 1.0);\n\n    // If the highest score is very low, default to general_query with moderate confidence\n    if (highestScore < 3 && detectedPurpose !== \"general_query\") {\n      return { purposeType: \"general_query\", confidence: 0.6 };\n    }\n\n    return { purposeType: detectedPurpose, confidence };\n  } catch (error) {\n    console.error(\"Error detecting conversation purpose:\", error);\n    // Fallback to general query with low confidence\n    return { purposeType: \"general_query\", confidence: 0.5 };\n  }\n}\n\n/**\n * @typedef {Object} ConversationPurpose\n * @property {string} purpose_id - Unique identifier for the purpose record\n * @property {string} conversation_id - ID of the conversation\n * @property {string} purpose_type - Type of purpose (e.g., 'debugging', 'feature_planning')\n * @property {number} confidence - Confidence score for this purpose (0-1)\n * @property {string} start_timestamp - ISO timestamp when this purpose was detected\n * @property {string|null} end_timestamp - ISO timestamp when this purpose ended, or null if active\n */\n\n/**\n * Gets the currently active purpose for a conversation\n *\n * @param {string} conversationId - ID of the conversation\n * @returns {Promise<ConversationPurpose|null>} The active purpose or null if none\n */\nexport async function getActivePurpose(conversationId) {\n  try {\n    // Query for active purpose (where end_timestamp is NULL)\n    const query = `\n      SELECT * FROM conversation_purposes\n      WHERE conversation_id = ?\n        AND end_timestamp IS NULL\n      ORDER BY start_timestamp DESC\n      LIMIT 1\n    `;\n\n    const result = await executeQuery(query, [conversationId]);\n\n    // Check if result has a rows property and it's an array\n    const rows =\n      result && result.rows && Array.isArray(result.rows)\n        ? result.rows\n        : Array.isArray(result)\n        ? result\n        : [];\n\n    // If no valid results, return null\n    if (rows.length === 0) {\n      return null;\n    }\n\n    // Return the active purpose (the most recent one if multiple exist)\n    return rows[0];\n  } catch (error) {\n    console.error(\n      `Error getting active purpose for conversation ${conversationId}:`,\n      error\n    );\n    throw new Error(`Failed to get active purpose: ${error.message}`);\n  }\n}\n\n/**\n * Records a transition to a new conversation purpose\n *\n * @param {string} conversationId - ID of the conversation\n * @param {string} previousPurposeType - The previously active purpose type (if any)\n * @param {string} newPurposeType - The new detected purpose type\n * @param {string} [triggerMessageId] - ID of the message that triggered this transition\n * @param {number} [confidence=0.7] - Confidence score for this purpose detection (0-1)\n * @returns {Promise<string>} The ID of the newly created purpose record\n */\nexport async function trackPurposeTransition(\n  conversationId,\n  previousPurposeType,\n  newPurposeType,\n  triggerMessageId,\n  confidence = 0.7\n) {\n  try {\n    // 1. Get current active purpose for the conversation\n    const activePurpose = await getActivePurpose(conversationId);\n\n    // 2. If there's an active purpose and it's different from the new one, close it\n    if (activePurpose && activePurpose.purpose_type !== newPurposeType) {\n      const currentTime = new Date().toISOString();\n\n      const updateQuery = `\n        UPDATE conversation_purposes\n        SET end_timestamp = ?\n        WHERE purpose_id = ?\n      `;\n\n      await executeQuery(updateQuery, [currentTime, activePurpose.purpose_id]);\n\n      console.log(\n        `Closed purpose ${activePurpose.purpose_type} for conversation ${conversationId}`\n      );\n    } else if (activePurpose && activePurpose.purpose_type === newPurposeType) {\n      // If the same purpose is already active, just return its ID\n      return activePurpose.purpose_id;\n    }\n\n    // 3. Generate a new purpose_id\n    const purpose_id = uuidv4();\n\n    // 4. Get current timestamp for start_timestamp\n    const start_timestamp = new Date().toISOString();\n\n    // 5. Prepare metadata with trigger message ID if provided\n    const metadata = triggerMessageId\n      ? JSON.stringify({ trigger_message_id: triggerMessageId })\n      : null;\n\n    // 6. Insert the new purpose record\n    const insertQuery = `\n      INSERT INTO conversation_purposes (\n        purpose_id,\n        conversation_id,\n        purpose_type,\n        confidence,\n        start_timestamp,\n        metadata\n      ) VALUES (?, ?, ?, ?, ?, ?)\n    `;\n\n    const params = [\n      purpose_id,\n      conversationId,\n      newPurposeType,\n      confidence,\n      start_timestamp,\n      metadata,\n    ];\n\n    await executeQuery(insertQuery, params);\n\n    console.log(\n      `Created new purpose record: ${newPurposeType} (${purpose_id}) for conversation ${conversationId}`\n    );\n\n    // 7. Return the purpose_id\n    return purpose_id;\n  } catch (error) {\n    console.error(\n      `Error tracking purpose transition for conversation ${conversationId}:`,\n      error\n    );\n    throw new Error(`Failed to track purpose transition: ${error.message}`);\n  }\n}\n\n/**\n * Gets the full history of purposes for a conversation\n *\n * @param {string} conversationId - ID of the conversation\n * @returns {Promise<ConversationPurpose[]>} Array of purpose records in chronological order\n */\nexport async function getPurposeHistory(conversationId) {\n  try {\n    // Query for all purposes for this conversation, ordered chronologically\n    const query = `\n      SELECT * FROM conversation_purposes\n      WHERE conversation_id = ?\n      ORDER BY start_timestamp ASC\n    `;\n\n    const result = await executeQuery(query, [conversationId]);\n\n    // Return the array of purpose objects (empty array if none found)\n    return result || [];\n  } catch (error) {\n    console.error(\n      `Error getting purpose history for conversation ${conversationId}:`,\n      error\n    );\n    throw new Error(`Failed to get purpose history: ${error.message}`);\n  }\n}\n\n/**\n * Purpose-specific prompt configurations\n */\nconst PURPOSE_PROMPTS = {\n  debugging: {\n    systemPrompt:\n      \"You are a debugging assistant. Focus on identifying errors and suggesting fixes for code issues. Analyze stack traces, error messages, and code snippets to help resolve problems efficiently.\",\n    modelBehavior:\n      \"Ask clarifying questions about error messages and code snippets. Provide step-by-step solutions. Be methodical in your approach. Look for common error patterns and suggest targeted debugging techniques.\",\n  },\n\n  feature_planning: {\n    systemPrompt:\n      \"You are a feature planning assistant. Help outline requirements, define scope, and create implementation tasks for new features. Consider architecture implications and integration points.\",\n    modelBehavior:\n      \"Break down complex features into manageable components. Discuss pros and cons of different design choices. Ask about constraints, requirements, and priorities. Suggest testing strategies and potential edge cases to consider.\",\n  },\n\n  code_review: {\n    systemPrompt:\n      \"You are a code review assistant. Help identify issues, suggest improvements, and ensure code quality. Focus on readability, performance, security, and maintainability.\",\n    modelBehavior:\n      \"Examine code thoroughly for bugs, edge cases, and potential improvements. Suggest more elegant or efficient approaches when appropriate. Reference best practices and design patterns. Be constructive and specific in feedback.\",\n  },\n\n  learning: {\n    systemPrompt:\n      \"You are a programming tutor. Focus on explaining concepts, providing clear examples, and building understanding. Adapt explanations to different knowledge levels.\",\n    modelBehavior:\n      \"Provide concise but thorough explanations. Use analogies and examples to illustrate complex concepts. Check understanding with questions. Encourage experimentation and hands-on learning. Break down complex topics into smaller chunks.\",\n  },\n\n  code_generation: {\n    systemPrompt:\n      \"You are a code generation assistant. Create high-quality, functional code that meets requirements while following best practices and project conventions.\",\n    modelBehavior:\n      \"Ask clarifying questions about requirements. Generate well-structured, well-documented, and tested code. Explain key design decisions. Suggest alternative implementations when appropriate. Follow idiomatic patterns for the language.\",\n  },\n\n  optimization: {\n    systemPrompt:\n      \"You are a performance optimization assistant. Help identify bottlenecks and suggest improvements to make code more efficient in terms of speed, memory usage, and resource utilization.\",\n    modelBehavior:\n      \"Ask for profiling data when available. Suggest specific optimization techniques. Explain tradeoffs between different approaches. Focus on high-impact changes first. Recommend measurement techniques to verify improvements.\",\n  },\n\n  refactoring: {\n    systemPrompt:\n      \"You are a code refactoring assistant. Help improve code structure, readability, and maintainability without changing functionality. Suggest cleaner, more modular designs.\",\n    modelBehavior:\n      \"Analyze code for code smells and improvement opportunities. Suggest refactoring in small, testable steps. Explain the benefits of each change. Follow established design principles and patterns. Consider readability and future maintenance.\",\n  },\n\n  general_query: {\n    systemPrompt:\n      \"You are a helpful programming assistant. Provide accurate and relevant information to help with coding tasks, questions, and challenges.\",\n    modelBehavior:\n      \"Answer questions clearly and concisely. Provide context-relevant code examples when appropriate. Ask clarifying questions if the request is ambiguous. Be factual and admit when you don't know something.\",\n  },\n};\n\n/**\n * Returns optimized prompts based on the detected conversation purpose\n *\n * @param {string} purposeType - The type of conversation purpose\n * @returns {{systemPrompt: string, modelBehavior: string}} Object containing prompts optimized for the purpose\n */\nexport function getPurposeSpecificPrompts(purposeType) {\n  // Look up the purpose type in our predefined prompts\n  if (PURPOSE_PROMPTS[purposeType]) {\n    return PURPOSE_PROMPTS[purposeType];\n  }\n\n  // Default to general_query for unknown purpose types\n  return PURPOSE_PROMPTS.general_query;\n}\n\n/**\n * Purpose-specific actionable request patterns\n */\nconst PURPOSE_ACTION_PATTERNS = {\n  debugging: {\n    keywords: [\n      \"fix\",\n      \"debug\",\n      \"solve\",\n      \"troubleshoot\",\n      \"resolve\",\n      \"diagnose\",\n      \"analyze\",\n      \"investigate\",\n      \"find the bug\",\n      \"identify the issue\",\n      \"fix this error\",\n      \"help me understand\",\n      \"what's wrong\",\n      \"why is this failing\",\n    ],\n    patterns: [\n      /how (do|can|should) I fix/i,\n      /what('s| is) causing/i,\n      /why (am I|is it) getting/i,\n      /can you (help me|assist|fix|debug|solve)/i,\n      /suggest a (fix|solution)/i,\n    ],\n  },\n\n  feature_planning: {\n    keywords: [\n      \"design\",\n      \"plan\",\n      \"create\",\n      \"implement\",\n      \"develop\",\n      \"architect\",\n      \"draft\",\n      \"outline\",\n      \"structure\",\n      \"requirements\",\n      \"specification\",\n      \"roadmap\",\n    ],\n    patterns: [\n      /how (do|can|should) I (design|implement|structure)/i,\n      /what('s| is) the best way to (design|implement)/i,\n      /help me (plan|design|create|outline)/i,\n      /can you (draft|create|help with)/i,\n      /suggest an? (architecture|approach|design)/i,\n    ],\n  },\n\n  code_review: {\n    keywords: [\n      \"review\",\n      \"evaluate\",\n      \"assess\",\n      \"improve\",\n      \"feedback\",\n      \"suggestion\",\n      \"better way\",\n      \"optimize\",\n      \"refactor\",\n      \"check\",\n    ],\n    patterns: [\n      /can you (review|look at|check)/i,\n      /what do you think (of|about)/i,\n      /how (can|could|would) (I|this|we) improve/i,\n      /is there a (better|cleaner|more efficient) way/i,\n      /please (review|evaluate|assess)/i,\n    ],\n  },\n\n  code_generation: {\n    keywords: [\n      \"generate\",\n      \"write\",\n      \"create\",\n      \"implement\",\n      \"code\",\n      \"script\",\n      \"function\",\n      \"class\",\n      \"method\",\n      \"program\",\n      \"example\",\n      \"show me how\",\n    ],\n    patterns: [\n      /can you (write|create|generate|implement|show me)/i,\n      /how (do|would) I (write|create|implement)/i,\n      /write a (function|class|method|program)/i,\n      /generate (code|a script|an example)/i,\n      /implement a (solution|feature|function)/i,\n    ],\n  },\n\n  learning: {\n    keywords: [\n      \"explain\",\n      \"teach\",\n      \"help me understand\",\n      \"clarify\",\n      \"what is\",\n      \"how does\",\n      \"why\",\n      \"concept\",\n      \"tutorial\",\n      \"example\",\n      \"guidance\",\n    ],\n    patterns: [\n      /can you (explain|clarify|teach me)/i,\n      /what (is|are|does)/i,\n      /how does (it|this|that) work/i,\n      /why (is|does|do)/i,\n      /I don't understand/i,\n      /help me understand/i,\n    ],\n  },\n\n  optimization: {\n    keywords: [\n      \"optimize\",\n      \"improve\",\n      \"speed up\",\n      \"performance\",\n      \"efficiency\",\n      \"faster\",\n      \"memory\",\n      \"resource\",\n      \"bottleneck\",\n      \"profile\",\n      \"benchmark\",\n    ],\n    patterns: [\n      /how (can|do) I (optimize|improve|speed up)/i,\n      /can you help (optimize|improve)/i,\n      /make (it|this) (faster|more efficient)/i,\n      /reduce (memory|CPU|resource) usage/i,\n      /find the (bottleneck|performance issue)/i,\n    ],\n  },\n\n  refactoring: {\n    keywords: [\n      \"refactor\",\n      \"restructure\",\n      \"reorganize\",\n      \"clean up\",\n      \"improve readability\",\n      \"simplify\",\n      \"modernize\",\n      \"update\",\n      \"better structure\",\n      \"clean code\",\n    ],\n    patterns: [\n      /how (can|do) I (refactor|restructure|improve)/i,\n      /can you (help|assist with) refactoring/i,\n      /make (it|this) (cleaner|more readable|more maintainable)/i,\n      /improve (the structure|readability|maintainability)/i,\n      /simplify this (code|implementation|approach)/i,\n    ],\n  },\n\n  general_query: {\n    keywords: [\n      \"how to\",\n      \"can you\",\n      \"please\",\n      \"show me\",\n      \"find\",\n      \"search\",\n      \"where is\",\n      \"display\",\n      \"tell me\",\n    ],\n    patterns: [\n      /can you (help|show|find|tell)/i,\n      /how (do|can|would) I/i,\n      /please (show|find|tell|help)/i,\n      /I need to/i,\n      /where (can|do) I/i,\n    ],\n  },\n};\n\n// General actionable request patterns that apply across all purpose types\nconst GENERAL_ACTION_PATTERNS = {\n  keywords: [\n    \"create\",\n    \"generate\",\n    \"build\",\n    \"write\",\n    \"implement\",\n    \"show\",\n    \"display\",\n    \"list\",\n    \"find\",\n    \"search\",\n    \"analyze\",\n    \"compare\",\n    \"calculate\",\n    \"run\",\n    \"execute\",\n    \"update\",\n    \"modify\",\n    \"change\",\n    \"add\",\n    \"remove\",\n    \"delete\",\n  ],\n  patterns: [\n    /can you/i,\n    /please/i,\n    /I need/i,\n    /could you/i,\n    /would you/i,\n    /show me/i,\n    /help me/i,\n    /let's/i,\n    /how (do|can|should) I/i,\n    /what (is|are) the/i,\n  ],\n  // Common question structures that often indicate actionable requests\n  questionPatterns: [\n    /\\?$/, // Ends with question mark\n    /^(what|how|where|when|who|why|can|could|would|should|is|are|do|does)/i, // Starts with question word\n  ],\n};\n\n/**\n * Determines if a message contains an actionable request based on its content and purpose\n *\n * @param {string} messageContent - The content of the message to analyze\n * @param {string} purposeType - The type of conversation purpose\n * @returns {boolean} True if the message contains an actionable request, false otherwise\n */\nexport function isActionableRequest(messageContent, purposeType) {\n  if (!messageContent || typeof messageContent !== \"string\") {\n    return false;\n  }\n\n  // Normalize message content\n  const content = messageContent.toLowerCase().trim();\n\n  // Very short messages are less likely to be actionable\n  if (content.length < 5) {\n    return false;\n  }\n\n  // Get purpose-specific patterns\n  const purposePatterns =\n    PURPOSE_ACTION_PATTERNS[purposeType] ||\n    PURPOSE_ACTION_PATTERNS.general_query;\n\n  // Check against purpose-specific keywords\n  for (const keyword of purposePatterns.keywords) {\n    if (content.includes(keyword.toLowerCase())) {\n      return true;\n    }\n  }\n\n  // Check against purpose-specific patterns\n  for (const pattern of purposePatterns.patterns) {\n    if (pattern.test(content)) {\n      return true;\n    }\n  }\n\n  // Check against general action keywords\n  for (const keyword of GENERAL_ACTION_PATTERNS.keywords) {\n    // Look for complete words by using word boundaries\n    const regex = new RegExp(`\\\\b${keyword}\\\\b`, \"i\");\n    if (regex.test(content)) {\n      return true;\n    }\n  }\n\n  // Check against general action patterns\n  for (const pattern of GENERAL_ACTION_PATTERNS.patterns) {\n    if (pattern.test(content)) {\n      // For general patterns, require a bit more confidence\n      // Either the message must be relatively long or it must contain a clear directive\n      if (\n        content.length > 15 ||\n        /^(please|can you|could you|would you|help me)/i.test(content)\n      ) {\n        return true;\n      }\n    }\n  }\n\n  // Check if it's a question (questions are often actionable)\n  for (const pattern of GENERAL_ACTION_PATTERNS.questionPatterns) {\n    if (pattern.test(content) && content.length > 10) {\n      return true;\n    }\n  }\n\n  // If none of the patterns matched, it's likely not an actionable request\n  return false;\n}\n\n/**\n * @typedef {Object} Pattern\n * @property {string} pattern_id - Unique identifier for the pattern\n * @property {string} name - Name of the pattern\n * @property {string} description - Description of the pattern\n * @property {string} pattern_type - Type/category of the pattern\n * @property {string} pattern_data - JSON string containing the pattern data\n * @property {boolean} is_global - Whether this is a global pattern\n * @property {number} utility_score - Score indicating the utility of the pattern\n * @property {number} confidence_score - Score indicating confidence in the pattern\n * @property {string} created_at - Timestamp when the pattern was created\n * @property {string} last_used - Timestamp when the pattern was last used\n * @property {number} use_count - Number of times the pattern has been used\n */\n\n/**\n * Purpose to pattern type mapping and relevant keywords\n */\nconst PURPOSE_PATTERN_MAPPING = {\n  debugging: {\n    patternTypes: [\n      \"debugging_common_error_fix\",\n      \"error_handling\",\n      \"bug_fix\",\n      \"troubleshooting\",\n      \"error_pattern\",\n    ],\n    keywords: [\n      \"debug\",\n      \"error\",\n      \"exception\",\n      \"fix\",\n      \"bug\",\n      \"issue\",\n      \"resolve\",\n      \"problem\",\n      \"crash\",\n      \"failure\",\n      \"unexpected\",\n    ],\n  },\n\n  feature_planning: {\n    patternTypes: [\n      \"feature_template\",\n      \"design_pattern\",\n      \"architecture\",\n      \"planning\",\n      \"requirements\",\n    ],\n    keywords: [\n      \"feature\",\n      \"design\",\n      \"plan\",\n      \"architecture\",\n      \"structure\",\n      \"requirement\",\n      \"specification\",\n      \"implementation\",\n      \"organize\",\n    ],\n  },\n\n  code_review: {\n    patternTypes: [\n      \"code_review\",\n      \"quality_check\",\n      \"best_practice\",\n      \"code_standard\",\n      \"linter_rule\",\n    ],\n    keywords: [\n      \"review\",\n      \"quality\",\n      \"standard\",\n      \"convention\",\n      \"best practice\",\n      \"style\",\n      \"formatting\",\n      \"consistency\",\n      \"readability\",\n      \"maintainability\",\n    ],\n  },\n\n  learning: {\n    patternTypes: [\n      \"tutorial\",\n      \"learning_example\",\n      \"concept_explanation\",\n      \"educational_pattern\",\n      \"learning_path\",\n    ],\n    keywords: [\n      \"learn\",\n      \"tutorial\",\n      \"example\",\n      \"explanation\",\n      \"concept\",\n      \"guide\",\n      \"understand\",\n      \"teach\",\n      \"educational\",\n      \"introduction\",\n    ],\n  },\n\n  code_generation: {\n    patternTypes: [\n      \"code_template\",\n      \"code_generation\",\n      \"boilerplate\",\n      \"snippet\",\n      \"example_implementation\",\n    ],\n    keywords: [\n      \"generate\",\n      \"create\",\n      \"template\",\n      \"boilerplate\",\n      \"skeleton\",\n      \"sample\",\n      \"example\",\n      \"implementation\",\n      \"snippet\",\n      \"scaffold\",\n    ],\n  },\n\n  optimization: {\n    patternTypes: [\n      \"performance_optimization\",\n      \"efficiency_pattern\",\n      \"resource_usage\",\n      \"optimization_technique\",\n      \"bottleneck_fix\",\n    ],\n    keywords: [\n      \"optimize\",\n      \"performance\",\n      \"efficiency\",\n      \"speed\",\n      \"memory\",\n      \"resource\",\n      \"bottleneck\",\n      \"fast\",\n      \"slow\",\n      \"improve\",\n    ],\n  },\n\n  refactoring: {\n    patternTypes: [\n      \"refactoring_pattern\",\n      \"code_cleanup\",\n      \"restructuring\",\n      \"code_improvement\",\n      \"modernization\",\n    ],\n    keywords: [\n      \"refactor\",\n      \"cleanup\",\n      \"improve\",\n      \"restructure\",\n      \"simplify\",\n      \"readability\",\n      \"maintainability\",\n      \"technical debt\",\n      \"modernize\",\n    ],\n  },\n\n  general_query: {\n    patternTypes: [\n      \"general_pattern\",\n      \"utility\",\n      \"common_solution\",\n      \"frequently_used\",\n      \"general_purpose\",\n    ],\n    keywords: [\n      \"common\",\n      \"general\",\n      \"utility\",\n      \"helper\",\n      \"frequently\",\n      \"standard\",\n      \"basic\",\n      \"typical\",\n      \"regular\",\n      \"normal\",\n    ],\n  },\n};\n\n/**\n * Retrieves patterns relevant to a specific conversation purpose\n *\n * @param {string} purposeType - The type of conversation purpose\n * @returns {Promise<Pattern[]>} Array of patterns relevant to the specified purpose\n */\nexport async function getPurposeCorrelatedPatterns(purposeType) {\n  try {\n    // 1. Get the pattern types and keywords relevant to this purpose\n    const purposeMapping =\n      PURPOSE_PATTERN_MAPPING[purposeType] ||\n      PURPOSE_PATTERN_MAPPING.general_query;\n    const { patternTypes, keywords } = purposeMapping;\n\n    // 2. Build pattern type condition for SQL\n    const patternTypeCondition = patternTypes\n      .map(() => \"pattern_type = ?\")\n      .join(\" OR \");\n\n    // 3. Build keyword LIKE conditions for description search\n    const keywordConditions = keywords\n      .map(() => \"description LIKE ?\")\n      .join(\" OR \");\n\n    // 4. Combine the conditions with an OR\n    const combinedCondition = `(${patternTypeCondition}) OR (${keywordConditions})`;\n\n    // 5. Prepare the complete query with ordering by priority\n    const query = `\n      SELECT * FROM project_patterns\n      WHERE ${combinedCondition}\n      ORDER BY \n        is_global DESC,\n        utility_score DESC,\n        confidence_score DESC,\n        use_count DESC\n      LIMIT 20\n    `;\n\n    // 6. Prepare the parameters array\n    const params = [\n      ...patternTypes,\n      ...keywords.map((keyword) => `%${keyword}%`),\n    ];\n\n    // 7. Execute the query\n    const patterns = await executeQuery(query, params);\n\n    // 8. Process and return the results\n    return patterns || [];\n  } catch (error) {\n    console.error(\n      `Error retrieving purpose correlated patterns for ${purposeType}:`,\n      error\n    );\n    throw new Error(\n      `Failed to get purpose correlated patterns: ${error.message}`\n    );\n  }\n}\n\n/**\n * Detects the initial purpose of a conversation based on the first query\n *\n * @param {string} conversationId - The ID of the conversation\n * @param {string} initialQuery - The initial query that started the conversation\n * @returns {Promise<{purposeType: string, confidence: number}>} The detected purpose and confidence\n */\nexport async function detectInitialPurpose(conversationId, initialQuery) {\n  try {\n    // Create a mock message from the initial query\n    const message = {\n      content: initialQuery,\n      role: \"user\",\n    };\n\n    // Use the existing detection logic\n    const result = await detectConversationPurpose([message]);\n\n    if (!result || !result.purposeType) {\n      // Default to general_query if no purpose is detected\n      result.purposeType = \"general_query\";\n      result.confidence = 0.5;\n    }\n\n    // Try to track this as the first purpose in the purpose history,\n    // but don't block initialization if this fails (could be a foreign key constraint)\n    try {\n      await trackPurposeTransition(\n        conversationId,\n        result.purposeType,\n        result.purposeType,\n        null,\n        result.confidence\n      );\n\n      console.log(\n        `Initial purpose for conversation ${conversationId}: ${result.purposeType} (${result.confidence})`\n      );\n    } catch (trackingError) {\n      console.error(\"Error tracking purpose transition:\", trackingError);\n      console.log(\n        \"Continuing with initialization despite purpose tracking error\"\n      );\n    }\n\n    return result;\n  } catch (error) {\n    console.error(\"Error detecting initial purpose:\", error);\n\n    // Default to general_query in case of error\n    return {\n      purposeType: \"general_query\",\n      confidence: 0.5,\n    };\n  }\n}\n\n/**\n * Sets the active purpose for a conversation\n *\n * @param {string} conversationId - The ID of the conversation\n * @param {string} purposeType - The type of purpose to set\n * @param {number} confidence - Confidence score for the purpose (0-1)\n * @returns {Promise<void>}\n */\nexport async function setActivePurpose(\n  conversationId,\n  purposeType,\n  confidence\n) {\n  try {\n    if (!conversationId) {\n      throw new Error(\"Conversation ID is required\");\n    }\n\n    if (!purposeType) {\n      throw new Error(\"Purpose type is required\");\n    }\n\n    // Validate confidence score\n    confidence = Math.max(0, Math.min(1, confidence));\n\n    // First, close any existing active purpose\n    const query1 = `\n      UPDATE conversation_purposes\n      SET end_timestamp = ?\n      WHERE conversation_id = ? AND end_timestamp IS NULL\n    `;\n    await executeQuery(query1, [new Date().toISOString(), conversationId]);\n\n    // Then create the new purpose record\n    const purposeId = uuidv4();\n    const startTimestamp = new Date().toISOString();\n\n    const query2 = `\n      INSERT INTO conversation_purposes (\n        purpose_id,\n        conversation_id,\n        purpose_type,\n        confidence,\n        start_timestamp,\n        end_timestamp\n      ) VALUES (?, ?, ?, ?, ?, NULL)\n    `;\n\n    await executeQuery(query2, [\n      purposeId,\n      conversationId,\n      purposeType,\n      confidence,\n      startTimestamp,\n    ]);\n\n    console.log(\n      `Set active purpose for conversation ${conversationId} to ${purposeType} (${confidence})`\n    );\n  } catch (error) {\n    console.error(\"Error setting active purpose:\", error);\n    throw new Error(\"Failed to set active purpose: \" + error.message);\n  }\n}\n", "/**\n * IntentPredictorLogic.js\n *\n * Provides functions for predicting user intent from queries and conversation history.\n */\n\nimport * as TextTokenizerLogic from \"./TextTokenizerLogic.js\";\nimport { executeQuery } from \"../db.js\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport * as TimelineManagerLogic from \"./TimelineManagerLogic.js\";\n\n/**\n * @typedef {Object} Message\n * @property {string} content - The content of the message\n * @property {string} role - The role of the message sender (user or assistant)\n */\n\n/**\n * @typedef {Object} TimelineEvent\n * @property {string} event_id - Unique identifier for the event\n * @property {string} event_type - Type of event\n * @property {number} timestamp - Timestamp when the event occurred\n * @property {Object} data - Event data parsed from JSON\n * @property {string[]} associated_entity_ids - IDs of entities associated with this event\n * @property {string|null} conversation_id - Optional conversation ID this event belongs to\n * @property {string} created_at - Timestamp when the event was created in the database\n */\n\n/**\n * @typedef {Object} CodeChangeInfo\n * @property {string} path - Path to the file being edited\n * @property {string} [content] - Optional content of the file\n */\n\n/**\n * @typedef {Object} FocusArea\n * @property {string} focus_id - Unique identifier for the focus area\n * @property {string} focus_type - Type of focus area ('file', 'directory', 'task_type')\n * @property {string} identifier - Primary identifier for the focus area (e.g., file path)\n * @property {string} description - Human-readable description of the focus area\n * @property {string} related_entity_ids - JSON string of related entity IDs\n * @property {string} keywords - JSON string of keywords related to this focus area\n * @property {number} last_activated_at - Timestamp when this focus area was last active\n * @property {boolean} is_active - Whether this focus area is currently active\n */\n\n/**\n * @typedef {Object} IntentInfo\n * @property {string} intent - The inferred intent type\n * @property {number} [confidence] - Confidence score for the intent (0-1)\n * @property {string[]} [keywords] - Array of extracted keywords\n * @property {FocusArea} [focusArea] - The currently active focus area, if available\n */\n\n/**\n * @typedef {Object} IntentUpdateResult\n * @property {IntentInfo} [newIntent] - The newly inferred intent, if available\n * @property {boolean} [focusUpdated] - Whether the focus area was updated\n * @property {FocusArea} [currentFocus] - The current focus area after update\n */\n\n/**\n * Infers the user's intent from a query and conversation history\n *\n * @param {string} query - The user's query\n * @param {Message[]} [conversationHistory=[]] - The recent conversation history\n * @returns {Object} Object containing intent and keywords\n * @returns {string} .intent - The inferred intent\n * @returns {string[]} .keywords - Array of extracted keywords\n */\nexport function inferIntentFromQuery(query, conversationHistory = []) {\n  // Define possible intents\n  const intents = {\n    GENERAL_QUERY: \"general_query\",\n    CODE_SEARCH: \"code_search\",\n    EXPLANATION_REQUEST: \"explanation_request\",\n    DEBUGGING_ASSIST: \"debugging_assist\",\n    REFACTORING_SUGGESTION: \"refactoring_suggestion\",\n    IMPLEMENTATION_REQUEST: \"implementation_request\",\n    DOCUMENTATION_REQUEST: \"documentation_request\",\n  };\n\n  // Initialize scores for each intent\n  const intentScores = {\n    [intents.GENERAL_QUERY]: 0.1, // Base score\n    [intents.CODE_SEARCH]: 0,\n    [intents.EXPLANATION_REQUEST]: 0,\n    [intents.DEBUGGING_ASSIST]: 0,\n    [intents.REFACTORING_SUGGESTION]: 0,\n    [intents.IMPLEMENTATION_REQUEST]: 0,\n    [intents.DOCUMENTATION_REQUEST]: 0,\n  };\n\n  // Normalize the query\n  const normalizedQuery = query.toLowerCase();\n\n  // Extract keywords using TextTokenizerLogic\n  const tokens = TextTokenizerLogic.tokenize(query);\n  const keywords = TextTokenizerLogic.extractKeywords(tokens);\n\n  // Check for question marks (indicates question/explanation request)\n  if (normalizedQuery.includes(\"?\")) {\n    intentScores[intents.EXPLANATION_REQUEST] += 0.3;\n  }\n\n  // Check for code snippets (code blocks, function names, variable declarations)\n  const codePatterns = [\n    /```[\\s\\S]*?```/, // Code blocks\n    /function\\s+\\w+\\s*\\(.*?\\)/, // Function declarations\n    /const|let|var\\s+\\w+\\s*=/, // Variable declarations\n    /class\\s+\\w+/, // Class declarations\n    /import\\s+.*?from/, // Import statements\n  ];\n\n  for (const pattern of codePatterns) {\n    if (pattern.test(query)) {\n      intentScores[intents.CODE_SEARCH] += 0.2;\n      intentScores[intents.DEBUGGING_ASSIST] += 0.2;\n      break;\n    }\n  }\n\n  // Check for specific keywords\n  const keywordPatterns = [\n    // Search related\n    {\n      patterns: [\"find\", \"search\", \"where is\", \"locate\", \"look for\"],\n      intent: intents.CODE_SEARCH,\n      score: 0.6,\n    },\n    // Explanation related\n    {\n      patterns: [\n        \"explain\",\n        \"how does\",\n        \"what is\",\n        \"why\",\n        \"how to\",\n        \"tell me about\",\n      ],\n      intent: intents.EXPLANATION_REQUEST,\n      score: 0.6,\n    },\n    // Debugging related\n    {\n      patterns: [\n        \"error\",\n        \"bug\",\n        \"issue\",\n        \"problem\",\n        \"fix\",\n        \"debug\",\n        \"not working\",\n        \"exception\",\n        \"fail\",\n      ],\n      intent: intents.DEBUGGING_ASSIST,\n      score: 0.7,\n    },\n    // Refactoring related\n    {\n      patterns: [\n        \"refactor\",\n        \"improve\",\n        \"optimize\",\n        \"clean\",\n        \"better way\",\n        \"restructure\",\n        \"revise\",\n      ],\n      intent: intents.REFACTORING_SUGGESTION,\n      score: 0.65,\n    },\n    // Implementation related\n    {\n      patterns: [\n        \"implement\",\n        \"create\",\n        \"make\",\n        \"build\",\n        \"develop\",\n        \"code\",\n        \"add\",\n        \"new feature\",\n      ],\n      intent: intents.IMPLEMENTATION_REQUEST,\n      score: 0.6,\n    },\n    // Documentation related\n    {\n      patterns: [\n        \"document\",\n        \"comment\",\n        \"describe\",\n        \"explain code\",\n        \"documentation\",\n      ],\n      intent: intents.DOCUMENTATION_REQUEST,\n      score: 0.55,\n    },\n  ];\n\n  for (const { patterns, intent, score } of keywordPatterns) {\n    for (const pattern of patterns) {\n      if (normalizedQuery.includes(pattern)) {\n        intentScores[intent] += score;\n        break; // Only add the score once per pattern group\n      }\n    }\n  }\n\n  // Analyze conversation history for context\n  if (conversationHistory && conversationHistory.length > 0) {\n    // Get last few messages, focusing on user messages\n    const recentMessages = conversationHistory\n      .slice(-3) // Last 3 messages\n      .filter((msg) => msg.content);\n\n    for (const message of recentMessages) {\n      const normalizedContent = message.content.toLowerCase();\n\n      // If previous messages contained errors or debug terms, boost debugging intent\n      if (\n        /error|bug|issue|problem|fix|debug|not working|exception|fail/.test(\n          normalizedContent\n        )\n      ) {\n        intentScores[intents.DEBUGGING_ASSIST] += 0.2;\n      }\n\n      // If previous messages discussed code structure, boost refactoring intent\n      if (\n        /refactor|improve|optimize|clean|better|restructure|architecture/.test(\n          normalizedContent\n        )\n      ) {\n        intentScores[intents.REFACTORING_SUGGESTION] += 0.2;\n      }\n\n      // If previous messages were about explaining, boost explanation intent\n      if (\n        /explain|how does|what is|why|how to|understand/.test(normalizedContent)\n      ) {\n        intentScores[intents.EXPLANATION_REQUEST] += 0.15;\n      }\n    }\n  }\n\n  // Determine the winning intent\n  let maxScore = 0;\n  let inferredIntent = intents.GENERAL_QUERY; // Default\n\n  for (const [intent, score] of Object.entries(intentScores)) {\n    if (score > maxScore) {\n      maxScore = score;\n      inferredIntent = intent;\n    }\n  }\n\n  return {\n    intent: inferredIntent,\n    keywords,\n  };\n}\n\n/**\n * Predicts the current focus area based on recent activity and code edits\n *\n * @param {TimelineEvent[]} recentActivity - Recent events from the timeline\n * @param {CodeChangeInfo[]} currentCodeEdits - Information about currently edited files\n * @returns {Promise<FocusArea|null>} The predicted focus area or null if no clear focus\n */\nexport async function predictFocusArea(\n  recentActivity = [],\n  currentCodeEdits = []\n) {\n  try {\n    // Track file/path frequencies to determine most common focus areas\n    const pathFrequency = new Map();\n    const entityFrequency = new Map();\n    const activityTypes = new Map();\n    let keywordsSet = new Set();\n\n    // Process recent activity from timeline events\n    for (const event of recentActivity) {\n      // Count event types\n      activityTypes.set(\n        event.event_type,\n        (activityTypes.get(event.event_type) || 0) + 1\n      );\n\n      // Track file paths from event data\n      if (event.data && event.data.path) {\n        const path = event.data.path;\n        pathFrequency.set(path, (pathFrequency.get(path) || 0) + 1);\n\n        // Add depth to different path segments (directories, etc)\n        const segments = path.split(\"/\");\n        for (let i = 1; i < segments.length; i++) {\n          const dirPath = segments.slice(0, i).join(\"/\");\n          if (dirPath) {\n            pathFrequency.set(dirPath, (pathFrequency.get(dirPath) || 0) + 0.3);\n          }\n        }\n      }\n\n      // Track related entities\n      if (\n        event.associated_entity_ids &&\n        event.associated_entity_ids.length > 0\n      ) {\n        for (const entityId of event.associated_entity_ids) {\n          entityFrequency.set(\n            entityId,\n            (entityFrequency.get(entityId) || 0) + 1\n          );\n        }\n      }\n\n      // Extract keywords from event data\n      if (event.data && typeof event.data === \"object\") {\n        // Extract keywords from any descriptive fields\n        const textFields = [\n          event.data.description,\n          event.data.message,\n          event.data.content,\n          event.data.query,\n        ].filter(Boolean);\n\n        for (const text of textFields) {\n          if (text && typeof text === \"string\") {\n            const tokens = TextTokenizerLogic.tokenize(text);\n            const extractedKeywords =\n              TextTokenizerLogic.extractKeywords(tokens);\n            extractedKeywords.forEach((keyword) => keywordsSet.add(keyword));\n          }\n        }\n      }\n    }\n\n    // Process current code edits (these should get more weight as they represent current focus)\n    for (const edit of currentCodeEdits) {\n      const path = edit.path;\n      // Give higher weight to current edits\n      pathFrequency.set(path, (pathFrequency.get(path) || 0) + 3);\n\n      // Add depth to different path segments (directories, etc)\n      const segments = path.split(\"/\");\n      for (let i = 1; i < segments.length; i++) {\n        const dirPath = segments.slice(0, i).join(\"/\");\n        if (dirPath) {\n          pathFrequency.set(dirPath, (pathFrequency.get(dirPath) || 0) + 0.5);\n        }\n      }\n\n      // Extract keywords from content if available\n      if (edit.content) {\n        const tokens = TextTokenizerLogic.tokenize(edit.content);\n        const extractedKeywords = TextTokenizerLogic.extractKeywords(tokens);\n        extractedKeywords.forEach((keyword) => keywordsSet.add(keyword));\n      }\n    }\n\n    // Find the most frequent paths and entities\n    let primaryFocusPath = \"\";\n    let maxFrequency = 0;\n    let focusType = \"file\";\n\n    for (const [path, frequency] of pathFrequency.entries()) {\n      if (frequency > maxFrequency) {\n        maxFrequency = frequency;\n        primaryFocusPath = path;\n\n        // Determine if it's a file or directory\n        focusType =\n          path.includes(\".\") && !path.endsWith(\"/\") ? \"file\" : \"directory\";\n      }\n    }\n\n    // If we couldn't determine a clear focus from paths, try to determine from activity types\n    if (!primaryFocusPath && activityTypes.size > 0) {\n      let primaryActivityType = \"\";\n      maxFrequency = 0;\n\n      for (const [type, frequency] of activityTypes.entries()) {\n        if (frequency > maxFrequency) {\n          maxFrequency = frequency;\n          primaryActivityType = type;\n        }\n      }\n\n      if (primaryActivityType) {\n        primaryFocusPath = `activity:${primaryActivityType}`;\n        focusType = \"task_type\";\n      }\n    }\n\n    // If we still have no clear focus, return null\n    if (!primaryFocusPath) {\n      return null;\n    }\n\n    // Create a human-readable description\n    let description = \"\";\n    if (focusType === \"file\") {\n      description = `Working on file ${primaryFocusPath}`;\n    } else if (focusType === \"directory\") {\n      description = `Working in directory ${primaryFocusPath}`;\n    } else {\n      description = `${primaryFocusPath.replace(\"activity:\", \"\")} activity`;\n    }\n\n    // Collect related entity IDs (most frequent ones)\n    const relatedEntityIds = Array.from(entityFrequency.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 10)\n      .map(([entityId]) => entityId);\n\n    // Collect keywords (convert Set to Array)\n    const keywords = Array.from(keywordsSet).slice(0, 20);\n\n    // Create the focus area object\n    const focusArea = {\n      focus_id: uuidv4(),\n      focus_type: focusType,\n      identifier: primaryFocusPath,\n      description,\n      related_entity_ids: JSON.stringify(relatedEntityIds),\n      keywords: JSON.stringify(keywords),\n      last_activated_at: Date.now(),\n      is_active: true,\n    };\n\n    // Call updateFocusAreaInDb to persist the focus area\n    // Note: This function will be implemented in another task\n    try {\n      await updateFocusAreaInDb(focusArea);\n    } catch (error) {\n      // Log the error but don't fail - we still want to return the computed focus area\n      console.error(\"Error updating focus area in database:\", error);\n    }\n\n    return focusArea;\n  } catch (error) {\n    console.error(\"Error predicting focus area:\", error);\n    return null;\n  }\n}\n\n/**\n * Updates or creates a focus area in the database\n *\n * @param {FocusArea} focus - The focus area to update or create\n * @returns {Promise<void>}\n */\nexport async function updateFocusAreaInDb(focus) {\n  try {\n    // Ensure that related_entity_ids and keywords are JSON strings\n    const relatedEntityIds =\n      typeof focus.related_entity_ids === \"string\"\n        ? focus.related_entity_ids\n        : JSON.stringify(focus.related_entity_ids || []);\n\n    const keywords =\n      typeof focus.keywords === \"string\"\n        ? focus.keywords\n        : JSON.stringify(focus.keywords || []);\n\n    // Ensure last_activated_at is set to current time if not provided\n    const lastActivated = focus.last_activated_at || Date.now();\n\n    // Begin transaction - execute a series of queries that should complete together\n    await executeQuery(\"BEGIN TRANSACTION\");\n\n    try {\n      // Step 1: Set all existing focus areas to inactive\n      await executeQuery(\n        \"UPDATE focus_areas SET is_active = FALSE WHERE is_active = TRUE\"\n      );\n\n      // Step 2: Check if the focus area already exists\n      const existingFocus = await executeQuery(\n        \"SELECT focus_id FROM focus_areas WHERE identifier = ?\",\n        [focus.identifier]\n      );\n\n      if (existingFocus && existingFocus.length > 0) {\n        // Update existing focus area\n        await executeQuery(\n          `UPDATE focus_areas SET \n            focus_type = ?,\n            description = ?,\n            related_entity_ids = ?,\n            keywords = ?,\n            last_activated_at = ?,\n            is_active = TRUE\n          WHERE focus_id = ?`,\n          [\n            focus.focus_type,\n            focus.description,\n            relatedEntityIds,\n            keywords,\n            lastActivated,\n            existingFocus[0].focus_id,\n          ]\n        );\n      } else {\n        // Insert new focus area\n        await executeQuery(\n          `INSERT INTO focus_areas (\n            focus_id,\n            focus_type,\n            identifier,\n            description,\n            related_entity_ids,\n            keywords,\n            last_activated_at,\n            is_active\n          ) VALUES (?, ?, ?, ?, ?, ?, ?, TRUE)`,\n          [\n            focus.focus_id,\n            focus.focus_type,\n            focus.identifier,\n            focus.description,\n            relatedEntityIds,\n            keywords,\n            lastActivated,\n          ]\n        );\n      }\n\n      // Commit the transaction\n      await executeQuery(\"COMMIT\");\n    } catch (error) {\n      // If any query fails, roll back the transaction\n      await executeQuery(\"ROLLBACK\");\n      throw error;\n    }\n  } catch (error) {\n    console.error(\"Error updating focus area in database:\", error);\n    throw error;\n  }\n}\n\n/**\n * Retrieves and analyzes the current intent for a conversation\n *\n * @param {string} conversationId - The ID of the conversation to analyze\n * @returns {Promise<IntentInfo|null>} The intent information or null if no clear intent\n */\nexport async function getIntent(conversationId) {\n  try {\n    // 1. Retrieve the most recent messages for the given conversationId\n    const recentMessages = await executeQuery(\n      `SELECT content, role, timestamp \n       FROM conversation_history \n       WHERE conversation_id = ? \n       ORDER BY timestamp DESC \n       LIMIT 5`,\n      [conversationId]\n    );\n\n    if (!recentMessages || recentMessages.length === 0) {\n      return null; // No messages found for this conversation\n    }\n\n    // Convert to the Message format expected by inferIntentFromQuery\n    const messages = recentMessages.map((msg) => ({\n      content: msg.content,\n      role: msg.role,\n    }));\n\n    // Get the most recent user message\n    const lastUserMessage = messages.find((msg) => msg.role === \"user\");\n\n    if (!lastUserMessage) {\n      return null; // No user messages found\n    }\n\n    // 2. Analyze the messages using inferIntentFromQuery\n    const { intent, keywords } = inferIntentFromQuery(\n      lastUserMessage.content,\n      messages\n    );\n\n    // 3. Get the currently active focus area\n    const activeFocusAreas = await executeQuery(\n      \"SELECT * FROM focus_areas WHERE is_active = TRUE LIMIT 1\"\n    );\n\n    let focusArea = null;\n    if (activeFocusAreas && activeFocusAreas.length > 0) {\n      const rawFocusArea = activeFocusAreas[0];\n\n      // Parse JSON fields\n      focusArea = {\n        ...rawFocusArea,\n        related_entity_ids: JSON.parse(rawFocusArea.related_entity_ids || \"[]\"),\n        keywords: JSON.parse(rawFocusArea.keywords || \"[]\"),\n      };\n    }\n\n    // 4. Calculate a confidence score based on the clarity of intent\n    // This is simplified - a real implementation might use more sophisticated scoring\n    let confidence = 0.5; // Default medium confidence\n\n    // Increase confidence if we have both clear intent and matching focus area\n    if (intent !== \"general_query\" && focusArea) {\n      confidence = 0.7;\n\n      // Check if any keywords match the focus area keywords\n      if (focusArea.keywords && keywords) {\n        const matchingKeywords = keywords.filter((k) =>\n          focusArea.keywords.includes(k)\n        );\n\n        if (matchingKeywords.length > 0) {\n          confidence += Math.min(0.3, matchingKeywords.length * 0.05);\n        }\n      }\n    }\n\n    // 5. Combine the information into an IntentInfo object\n    const intentInfo = {\n      intent,\n      confidence,\n      keywords,\n      focusArea,\n    };\n\n    return intentInfo;\n  } catch (error) {\n    console.error(\"Error getting intent for conversation:\", error);\n    return null;\n  }\n}\n\n/**\n * Updates the intent and focus area based on new activity signals\n *\n * @param {Object} params - Parameters containing activity signals\n * @param {string} params.conversationId - ID of the conversation to update\n * @param {string} [params.newMessage] - New message content, if any\n * @param {boolean} [params.isUser=false] - Whether the new message is from the user\n * @param {string} [params.activeFile] - Currently active file path, if any\n * @param {CodeChangeInfo[]} [params.codeChanges] - Information about code changes\n * @returns {Promise<IntentUpdateResult>} Result indicating intent and focus updates\n */\nexport async function updateIntent(params) {\n  try {\n    const {\n      conversationId,\n      newMessage,\n      isUser = false,\n      activeFile,\n      codeChanges = [],\n    } = params;\n\n    let newIntent = null;\n    let focusUpdated = false;\n    let currentFocus = null;\n\n    // 1. If new message is present and from user, determine textual intent\n    if (newMessage && isUser) {\n      // Get recent conversation history\n      const recentMessages = await executeQuery(\n        `SELECT content, role, timestamp \n         FROM conversation_history \n         WHERE conversation_id = ? \n         ORDER BY timestamp DESC \n         LIMIT 5`,\n        [conversationId]\n      );\n\n      // Convert to Message format and add the new message\n      const messages = recentMessages.map((msg) => ({\n        content: msg.content,\n        role: msg.role,\n      }));\n\n      // Add the new message to the history\n      messages.unshift({\n        content: newMessage,\n        role: \"user\",\n      });\n\n      // Infer intent from the new message\n      const { intent, keywords } = inferIntentFromQuery(newMessage, messages);\n\n      // Get the current focus area\n      const activeFocusAreas = await executeQuery(\n        \"SELECT * FROM focus_areas WHERE is_active = TRUE LIMIT 1\"\n      );\n\n      let focusArea = null;\n      if (activeFocusAreas && activeFocusAreas.length > 0) {\n        const rawFocusArea = activeFocusAreas[0];\n\n        // Parse JSON fields\n        focusArea = {\n          ...rawFocusArea,\n          related_entity_ids: JSON.parse(\n            rawFocusArea.related_entity_ids || \"[]\"\n          ),\n          keywords: JSON.parse(rawFocusArea.keywords || \"[]\"),\n        };\n      }\n\n      // Calculate confidence\n      let confidence = 0.5; // Default medium confidence\n\n      if (intent !== \"general_query\" && focusArea) {\n        confidence = 0.7;\n\n        // Check if any keywords match the focus area keywords\n        if (focusArea.keywords && keywords) {\n          const matchingKeywords = keywords.filter((k) =>\n            focusArea.keywords.includes(k)\n          );\n\n          if (matchingKeywords.length > 0) {\n            confidence += Math.min(0.3, matchingKeywords.length * 0.05);\n          }\n        }\n      }\n\n      // Create IntentInfo object\n      newIntent = {\n        intent,\n        confidence,\n        keywords,\n        focusArea,\n      };\n    }\n\n    // 2. Determine if project-level focus has shifted based on code activity\n    // First, gather relevant activity information\n    const codeActivity = [];\n\n    // Add active file as a code activity if provided\n    if (activeFile) {\n      codeActivity.push({\n        path: activeFile,\n      });\n    }\n\n    // Add code changes\n    if (codeChanges && codeChanges.length > 0) {\n      codeActivity.push(...codeChanges);\n    }\n\n    // Get recent timeline events\n    const recentEvents = await TimelineManagerLogic.getEvents({\n      limit: 20,\n      types: [\"code_change\", \"file_open\", \"cursor_move\", \"navigation\"],\n    });\n\n    // If we have any code activity or recent events, check for focus shift\n    if (codeActivity.length > 0 || recentEvents.length > 0) {\n      // Predict focus area based on activity\n      const newFocusArea = await predictFocusArea(recentEvents, codeActivity);\n\n      if (newFocusArea) {\n        // Focus was updated by predictFocusArea\n        focusUpdated = true;\n        currentFocus = newFocusArea;\n      } else {\n        // No focus update, get current focus\n        const activeFocusAreas = await executeQuery(\n          \"SELECT * FROM focus_areas WHERE is_active = TRUE LIMIT 1\"\n        );\n\n        if (activeFocusAreas && activeFocusAreas.length > 0) {\n          const rawFocusArea = activeFocusAreas[0];\n\n          // Parse JSON fields\n          currentFocus = {\n            ...rawFocusArea,\n            related_entity_ids: JSON.parse(\n              rawFocusArea.related_entity_ids || \"[]\"\n            ),\n            keywords: JSON.parse(rawFocusArea.keywords || \"[]\"),\n          };\n        }\n      }\n    } else {\n      // No code activity, just get current focus\n      const activeFocusAreas = await executeQuery(\n        \"SELECT * FROM focus_areas WHERE is_active = TRUE LIMIT 1\"\n      );\n\n      if (activeFocusAreas && activeFocusAreas.length > 0) {\n        const rawFocusArea = activeFocusAreas[0];\n\n        // Parse JSON fields\n        currentFocus = {\n          ...rawFocusArea,\n          related_entity_ids: JSON.parse(\n            rawFocusArea.related_entity_ids || \"[]\"\n          ),\n          keywords: JSON.parse(rawFocusArea.keywords || \"[]\"),\n        };\n      }\n    }\n\n    // If we have a new intent but no focus area in it, add the current focus\n    if (newIntent && !newIntent.focusArea && currentFocus) {\n      newIntent.focusArea = currentFocus;\n    }\n\n    // Return the IntentUpdateResult\n    return {\n      newIntent,\n      focusUpdated,\n      currentFocus,\n    };\n  } catch (error) {\n    console.error(\"Error updating intent:\", error);\n    // Return minimal information in case of error\n    return {\n      focusUpdated: false,\n    };\n  }\n}\n", "/**\n * TimelineManagerLogic.js\n *\n * Provides functions for managing and recording timeline events.\n */\n\nimport { v4 as uuidv4 } from \"uuid\";\nimport { executeQuery } from \"../db.js\";\n\n/**\n * @typedef {Object} TimelineEvent\n * @property {string} event_id - Unique identifier for the event\n * @property {string} event_type - Type of event\n * @property {number} timestamp - Timestamp when the event occurred\n * @property {Object} data - Event data parsed from JSON\n * @property {string[]} associated_entity_ids - IDs of entities associated with this event\n * @property {string|null} conversation_id - Optional conversation ID this event belongs to\n * @property {string} created_at - Timestamp when the event was created in the database\n */\n\n/**\n * @typedef {Object} Snapshot\n * @property {string} snapshot_id - Unique identifier for the snapshot\n * @property {string|null} name - Optional name of the snapshot\n * @property {string|null} description - Optional description of the snapshot\n * @property {Object} snapshot_data - Parsed snapshot data from JSON\n * @property {string|null} timeline_event_id - Optional ID of the associated timeline event\n * @property {string} created_at - Timestamp when the snapshot was created in the database\n */\n\n/**\n * Records an event in the timeline\n *\n * @param {string} type - Type of event\n * @param {object} data - Event data object\n * @param {string[]} [associatedEntityIds=[]] - IDs of entities associated with this event\n * @param {string} [conversationId] - Optional conversation ID this event belongs to\n * @returns {Promise<string>} Generated event ID\n */\nexport async function recordEvent(\n  type,\n  data,\n  associatedEntityIds = [],\n  conversationId = null\n) {\n  try {\n    // Generate a unique event ID\n    const eventId = uuidv4();\n\n    // Convert data and associatedEntityIds to JSON strings\n    const dataJson = JSON.stringify(data);\n    const entityIdsJson = JSON.stringify(associatedEntityIds);\n\n    // Get current timestamp\n    const timestamp = Date.now();\n\n    // Construct the SQL query\n    const query = `\n      INSERT INTO timeline_events (\n        event_id, \n        event_type, \n        timestamp, \n        data, \n        associated_entity_ids,\n        conversation_id\n      ) VALUES (?, ?, ?, ?, ?, ?)\n    `;\n\n    // Execute the query with parameters\n    await executeQuery(query, [\n      eventId,\n      type,\n      timestamp,\n      dataJson,\n      entityIdsJson,\n      conversationId,\n    ]);\n\n    return eventId;\n  } catch (error) {\n    console.error(`Error recording timeline event (${type}):`, error);\n    throw error;\n  }\n}\n\n/**\n * Creates a snapshot of the active context data\n *\n * @param {object} activeContextData - Data to be snapshotted (active entity IDs, focus, etc.)\n * @param {string} [name] - Optional name for the snapshot\n * @param {string} [description] - Optional description of the snapshot\n * @param {string} [timeline_event_id] - Optional ID of an associated timeline event\n * @returns {Promise<string>} Generated snapshot ID\n */\nexport async function createSnapshot(\n  activeContextData,\n  name = null,\n  description = null,\n  timeline_event_id = null\n) {\n  try {\n    // Generate a unique snapshot ID\n    const snapshot_id = uuidv4();\n\n    // Convert activeContextData to a JSON string\n    const snapshot_data = JSON.stringify(activeContextData);\n\n    // Construct the SQL query\n    const query = `\n      INSERT INTO context_snapshots (\n        snapshot_id,\n        name,\n        description,\n        snapshot_data,\n        timeline_event_id\n      ) VALUES (?, ?, ?, ?, ?)\n    `;\n\n    // Execute the query with parameters\n    await executeQuery(query, [\n      snapshot_id,\n      name,\n      description,\n      snapshot_data,\n      timeline_event_id,\n    ]);\n\n    return snapshot_id;\n  } catch (error) {\n    console.error(\"Error creating context snapshot:\", error);\n    throw error;\n  }\n}\n\n/**\n * Manages the creation of implicit checkpoints based on activity thresholds\n * This function checks for substantial activity and creates automatic snapshots when appropriate\n *\n * @returns {Promise<void>}\n */\nexport async function manageImplicitCheckpoints() {\n  try {\n    // Define activity thresholds\n    const MIN_EVENTS_FOR_CHECKPOINT = 10;\n    const MIN_MINUTES_SINCE_LAST_CHECKPOINT = 15;\n    const SIGNIFICANT_EVENT_TYPES = [\n      \"code_change\",\n      \"conversation_end\",\n      \"focus_change\",\n    ];\n\n    // Get the timestamp of the last implicit checkpoint\n    const lastCheckpointQuery = `\n      SELECT cs.snapshot_id, te.timestamp\n      FROM context_snapshots cs\n      LEFT JOIN timeline_events te ON cs.timeline_event_id = te.event_id\n      WHERE (cs.name LIKE 'Implicit Checkpoint%' OR te.event_type = 'implicit_checkpoint_creation')\n      ORDER BY te.timestamp DESC\n      LIMIT 1\n    `;\n\n    const lastCheckpoint = await executeQuery(lastCheckpointQuery);\n    const lastCheckpointTime =\n      lastCheckpoint.rows && lastCheckpoint.rows.length > 0\n        ? lastCheckpoint.rows[0].timestamp\n        : 0;\n\n    // Calculate time threshold\n    const timeThreshold =\n      Date.now() - MIN_MINUTES_SINCE_LAST_CHECKPOINT * 60 * 1000;\n\n    // Check if enough time has passed since last checkpoint\n    if (lastCheckpointTime > timeThreshold) {\n      // Not enough time has passed\n      return;\n    }\n\n    // Count events since last checkpoint\n    const countEventsQuery = `\n      SELECT COUNT(*) as event_count\n      FROM timeline_events\n      WHERE timestamp > ?\n    `;\n\n    const eventCountResult = await executeQuery(countEventsQuery, [\n      lastCheckpointTime,\n    ]);\n    const eventCount =\n      eventCountResult.rows && eventCountResult.rows.length > 0\n        ? eventCountResult.rows[0].event_count || 0\n        : 0;\n\n    // Count significant events\n    const significantEventsQuery = `\n      SELECT COUNT(*) as significant_count\n      FROM timeline_events\n      WHERE timestamp > ? AND event_type IN (${SIGNIFICANT_EVENT_TYPES.map(\n        () => \"?\"\n      ).join(\",\")})\n    `;\n\n    const significantCountResult = await executeQuery(significantEventsQuery, [\n      lastCheckpointTime,\n      ...SIGNIFICANT_EVENT_TYPES,\n    ]);\n    const significantCount =\n      significantCountResult.rows && significantCountResult.rows.length > 0\n        ? significantCountResult.rows[0].significant_count || 0\n        : 0;\n\n    // Determine if we should create a checkpoint\n    const shouldCreateCheckpoint =\n      eventCount >= MIN_EVENTS_FOR_CHECKPOINT || significantCount > 0;\n\n    if (shouldCreateCheckpoint) {\n      // Get active context data\n      // In a real implementation, this would come from ActiveContextManager\n      // Since that's not available, we'll create mock data to demonstrate the function\n      const activeContextData = {\n        activeEntities: [], // This would be populated with actual entity IDs\n        activeFocus: null, // This would be the current focus area\n        timestamp: Date.now(),\n      };\n\n      // Try to get actual context data if available\n      try {\n        // This is a placeholder - in real implementation, we would check if\n        // ActiveContextManager is available and use it to get context data\n        const ActiveContextManager = global.ActiveContextManager;\n        if (\n          ActiveContextManager &&\n          typeof ActiveContextManager.getActiveContextAsEntities === \"function\"\n        ) {\n          const contextData =\n            await ActiveContextManager.getActiveContextAsEntities();\n          if (contextData) {\n            activeContextData.activeEntities = contextData.entities || [];\n            activeContextData.activeFocus = contextData.focus || null;\n          }\n        }\n      } catch (error) {\n        console.warn(\n          \"Could not retrieve data from ActiveContextManager:\",\n          error.message\n        );\n        // Continue with mock data\n      }\n\n      // Generate checkpoint name and description\n      const timestamp = new Date().toISOString();\n      const checkpointName = `Implicit Checkpoint [${timestamp}]`;\n      let description = \"Automatically created checkpoint due to \";\n\n      if (eventCount >= MIN_EVENTS_FOR_CHECKPOINT) {\n        description += `high activity (${eventCount} events)`;\n      } else if (significantCount > 0) {\n        description += `significant changes (${significantCount} significant events)`;\n      }\n\n      // Record the checkpoint creation event\n      const eventId = await recordEvent(\"implicit_checkpoint_creation\", {\n        reason: description,\n        eventCount,\n        significantCount,\n      });\n\n      // Create the snapshot\n      await createSnapshot(\n        activeContextData,\n        checkpointName,\n        description,\n        eventId\n      );\n    }\n  } catch (error) {\n    console.error(\"Error managing implicit checkpoints:\", error);\n    // Don't throw - this function should not crash the application\n  }\n}\n\n/**\n * Retrieves timeline events based on specified filters\n *\n * @param {Object} options - Query options\n * @param {string[]} [options.types] - Filter events by these event types\n * @param {number} [options.limit] - Maximum number of events to return\n * @param {string} [options.conversationId] - Filter events by this conversation ID\n * @param {boolean} [options.includeMilestones=true] - Whether to include milestone events\n * @param {string} [options.excludeConversationId] - Exclude events with this conversation ID\n * @returns {Promise<TimelineEvent[]>} Array of timeline events with parsed JSON fields\n */\nexport async function getEvents(options = {}) {\n  try {\n    const {\n      types,\n      limit,\n      conversationId,\n      includeMilestones = true,\n      excludeConversationId,\n    } = options;\n\n    // Build the base query\n    let query = \"SELECT * FROM timeline_events WHERE 1=1\";\n    const params = [];\n\n    // Apply filters based on options\n    if (types && types.length > 0) {\n      query += ` AND event_type IN (${types.map(() => \"?\").join(\",\")})`;\n      params.push(...types);\n    }\n\n    if (conversationId) {\n      query += \" AND conversation_id = ?\";\n      params.push(conversationId);\n    }\n\n    if (excludeConversationId) {\n      query += \" AND (conversation_id != ? OR conversation_id IS NULL)\";\n      params.push(excludeConversationId);\n    }\n\n    // Handle milestone events filtering\n    // Assuming milestone events have specific types like 'milestone_created' or are linked to snapshots\n    if (!includeMilestones) {\n      // Define the event types that are considered milestones\n      const milestoneEventTypes = [\n        \"milestone_created\",\n        \"implicit_checkpoint_creation\",\n        \"checkpoint_created\",\n      ];\n      query += ` AND event_type NOT IN (${milestoneEventTypes\n        .map(() => \"?\")\n        .join(\",\")})`;\n      params.push(...milestoneEventTypes);\n\n      // Additionally exclude events that have an associated snapshot\n      query += ` AND NOT EXISTS (\n        SELECT 1 FROM context_snapshots \n        WHERE context_snapshots.timeline_event_id = timeline_events.event_id\n      )`;\n    }\n\n    // Add ordering\n    query += \" ORDER BY timestamp DESC\";\n\n    // Apply limit if specified\n    if (limit && Number.isInteger(limit) && limit > 0) {\n      query += \" LIMIT ?\";\n      params.push(limit);\n    }\n\n    // Execute the query\n    const events = await executeQuery(query, params);\n\n    // Check if events has a rows property and it's an array\n    const rows =\n      events && events.rows && Array.isArray(events.rows)\n        ? events.rows\n        : Array.isArray(events)\n        ? events\n        : [];\n\n    // If no valid results, return empty array\n    if (rows.length === 0) {\n      console.warn(\"No valid timeline events found\");\n      return [];\n    }\n\n    // Parse JSON fields in each event\n    return rows.map((event) => ({\n      ...event,\n      data: JSON.parse(event.data || \"{}\"),\n      associated_entity_ids: JSON.parse(event.associated_entity_ids || \"[]\"),\n    }));\n  } catch (error) {\n    console.error(\"Error retrieving timeline events:\", error);\n    throw error;\n  }\n}\n\n/**\n * Retrieves context snapshots (milestones) based on specified filters\n *\n * @param {Object} options - Query options\n * @param {string[]} [options.types] - Filter snapshots by type-related keywords in name or description\n * @param {number} [options.limit] - Maximum number of snapshots to return\n * @returns {Promise<Snapshot[]>} Array of context snapshots with parsed snapshot_data field\n */\nexport async function getMilestones(options = {}) {\n  try {\n    const { types, limit } = options;\n\n    // Start building the query\n    let query = `\n      SELECT cs.*, te.event_type\n      FROM context_snapshots cs\n      LEFT JOIN timeline_events te ON cs.timeline_event_id = te.event_id\n      WHERE 1=1\n    `;\n\n    const params = [];\n\n    // Apply type filtering based on name, description or associated event type\n    if (types && types.length > 0) {\n      const typeConditions = [];\n\n      for (const type of types) {\n        // Create pattern for LIKE queries\n        const pattern = `%${type}%`;\n\n        // Add conditions for name, description and associated event type\n        typeConditions.push(\"cs.name LIKE ?\");\n        params.push(pattern);\n\n        typeConditions.push(\"cs.description LIKE ?\");\n        params.push(pattern);\n\n        typeConditions.push(\"te.event_type LIKE ?\");\n        params.push(pattern);\n\n        // Also search in event data if linked to a timeline event\n        typeConditions.push(`\n          EXISTS (\n            SELECT 1 FROM timeline_events\n            WHERE timeline_events.event_id = cs.timeline_event_id\n            AND timeline_events.data LIKE ?\n          )\n        `);\n        params.push(`%\"category\":\"${type}\"%`);\n      }\n\n      if (typeConditions.length > 0) {\n        query += ` AND (${typeConditions.join(\" OR \")})`;\n      }\n    }\n\n    // Add ordering by timestamp (assuming cs.timestamp exists)\n    query += \" ORDER BY timestamp DESC\";\n\n    // Apply limit if specified\n    if (limit && Number.isInteger(limit) && limit > 0) {\n      query += \" LIMIT ?\";\n      params.push(limit);\n    }\n\n    // Execute the query\n    const snapshots = await executeQuery(query, params);\n\n    // Check if snapshots has a rows property and it's an array\n    const rows =\n      snapshots && snapshots.rows && Array.isArray(snapshots.rows)\n        ? snapshots.rows\n        : Array.isArray(snapshots)\n        ? snapshots\n        : [];\n\n    // If no valid results, return empty array\n    if (rows.length === 0) {\n      console.warn(\"No valid snapshots found\");\n      return [];\n    }\n\n    // Parse snapshot_data from JSON for each result\n    return rows.map((snapshot) => ({\n      ...snapshot,\n      snapshot_data: JSON.parse(snapshot.snapshot_data || \"{}\"),\n    }));\n  } catch (error) {\n    console.error(\"Error retrieving milestones:\", error);\n    throw error;\n  }\n}\n\n/**\n * Gets recent events for a specific conversation\n *\n * @param {string} conversationId - The conversation ID\n * @param {number} [limit=10] - Maximum number of events to return\n * @param {string[]} [eventTypes] - Optional array of event types to filter by\n * @returns {Promise<TimelineEvent[]>} Array of timeline events\n */\nexport async function getRecentEventsForConversation(\n  conversationId,\n  limit = 10,\n  eventTypes = null\n) {\n  try {\n    if (!conversationId) {\n      throw new Error(\"Conversation ID is required\");\n    }\n\n    // Build the query\n    let query = `\n      SELECT \n        event_id,\n        event_type,\n        timestamp,\n        data,\n        associated_entity_ids,\n        conversation_id\n      FROM \n        timeline_events\n      WHERE \n        conversation_id = ?\n    `;\n\n    const params = [conversationId];\n\n    // Add event type filter if provided\n    if (eventTypes && Array.isArray(eventTypes) && eventTypes.length > 0) {\n      const placeholders = eventTypes.map(() => \"?\").join(\",\");\n      query += ` AND event_type IN (${placeholders})`;\n      params.push(...eventTypes);\n    }\n\n    // Add order and limit\n    query += `\n      ORDER BY \n        timestamp DESC\n      LIMIT ?\n    `;\n    params.push(limit);\n\n    // Execute the query\n    const results = await executeQuery(query, params);\n\n    // Check if results has a rows property and it's an array\n    const rows =\n      results && results.rows && Array.isArray(results.rows)\n        ? results.rows\n        : Array.isArray(results)\n        ? results\n        : [];\n\n    // If no valid results, return empty array\n    if (rows.length === 0) {\n      console.warn(\"No recent events found for conversation:\", conversationId);\n      return [];\n    }\n\n    // Parse the JSON fields\n    return rows.map((event) => ({\n      ...event,\n      data: JSON.parse(event.data || \"{}\"),\n      associated_entity_ids: JSON.parse(event.associated_entity_ids || \"[]\"),\n    }));\n  } catch (error) {\n    console.error(\n      `Error getting recent events for conversation ${conversationId}:`,\n      error\n    );\n    return [];\n  }\n}\n", "/**\n * ActiveContextManager.js\n *\n * Manages the \"Active Context\" in-memory for the current conversation.\n * Provides functions to get, set, and manipulate the entities and focus\n * that are currently active in the developer's context.\n */\n\nimport { executeQuery } from \"../db.js\";\nimport * as ContextPrioritizerLogic from \"./ContextPrioritizerLogic.js\";\nimport * as ContextCompressorLogic from \"./ContextCompressorLogic.js\";\n\n/**\n * @typedef {Object} FocusArea\n * @property {string} focus_id - Unique identifier for the focus area\n * @property {string} focus_type - Type of focus area ('file', 'directory', 'task_type')\n * @property {string} identifier - Primary identifier for the focus area (e.g., file path)\n * @property {string} description - Human-readable description of the focus area\n * @property {string[]} related_entity_ids - Array of related entity IDs\n * @property {string[]} keywords - Array of keywords related to this focus area\n * @property {number} last_activated_at - Timestamp when this focus area was last active\n * @property {boolean} is_active - Whether this focus area is currently active\n */\n\n/**\n * @typedef {Object} CodeEntity\n * @property {string} id - Unique identifier for the code entity\n * @property {string} path - File path of the code entity\n * @property {string} type - Type of code entity ('file', 'function', 'class', etc.)\n * @property {string} name - Name of the code entity\n * @property {string} content - Content of the code entity\n * @property {string} symbol_path - Full symbol path of the entity\n * @property {number} version - Version number of the entity\n * @property {string} parent_id - ID of the parent entity, if any\n * @property {string} created_at - Timestamp when entity was created\n * @property {string} updated_at - Timestamp when entity was last updated\n */\n\n/**\n * @typedef {Object} Snippet\n * @property {string} entity_id - ID of the entity\n * @property {string} summarizedContent - Compressed/summarized content\n * @property {number} originalScore - Original relevance score\n * @property {string} type - Type of snippet\n */\n\n// Module-scoped state variables\n/**\n * Set of entity IDs currently in active context\n * @type {Set<string>}\n */\nconst activeEntityIds = new Set();\n\n/**\n * Current focus area\n * @type {FocusArea|null}\n */\nlet activeFocus = null;\n\n/**\n * History of context changes for short-term memory\n * @type {Array<{timestamp: number, added?: string[], removed?: string[]}>}\n */\nconst contextHistory = [];\n\n/**\n * Returns the current active focus area\n *\n * @returns {FocusArea|null} The current focus area or null if no focus is set\n */\nexport function getActiveFocus() {\n  return activeFocus;\n}\n\n/**\n * Sets the active focus area and optionally adds related entity IDs to active context\n *\n * @param {FocusArea} focus - The focus area to set as active\n */\nexport function setActiveFocus(focus) {\n  activeFocus = focus;\n\n  // If focus has related entity IDs, add them to active context\n  if (focus && Array.isArray(focus.related_entity_ids)) {\n    updateActiveContext(focus.related_entity_ids, []);\n  }\n}\n\n/**\n * Updates the active context by adding and removing entity IDs\n *\n * @param {string[]} addEntityIds - Array of entity IDs to add to active context\n * @param {string[]} removeEntityIds - Array of entity IDs to remove from active context\n */\nexport function updateActiveContext(addEntityIds = [], removeEntityIds = []) {\n  const changeRecord = {\n    timestamp: Date.now(),\n  };\n\n  // Add entities to active context\n  if (addEntityIds.length > 0) {\n    addEntityIds.forEach((id) => activeEntityIds.add(id));\n    changeRecord.added = [...addEntityIds];\n  }\n\n  // Remove entities from active context\n  if (removeEntityIds.length > 0) {\n    removeEntityIds.forEach((id) => activeEntityIds.delete(id));\n    changeRecord.removed = [...removeEntityIds];\n  }\n\n  // Record this change in history if anything changed\n  if (addEntityIds.length > 0 || removeEntityIds.length > 0) {\n    contextHistory.push(changeRecord);\n\n    // Limit history size (keep last 50 changes)\n    if (contextHistory.length > 50) {\n      contextHistory.shift();\n    }\n  }\n}\n\n/**\n * Returns all entity IDs in the active context\n *\n * @returns {string[]} Array of active entity IDs\n */\nexport function getActiveContextEntityIds() {\n  return [...activeEntityIds];\n}\n\n/**\n * Clears the active context by resetting all state variables\n */\nexport function clearActiveContext() {\n  activeEntityIds.clear();\n  activeFocus = null;\n\n  // Record this change in history\n  contextHistory.push({\n    timestamp: Date.now(),\n    event: \"clear_context\",\n  });\n}\n\n/**\n * Returns the active context history\n * Used for debugging and analytics purposes\n *\n * @returns {Array} The context history array\n */\nexport function getContextHistory() {\n  return [...contextHistory];\n}\n\n/**\n * Retrieves full entity details for all active context items from the database\n *\n * @returns {Promise<CodeEntity[]>} Array of code entity objects\n */\nexport async function getActiveContextAsEntities() {\n  // Get current active entity IDs\n  const entityIds = getActiveContextEntityIds();\n\n  // If no active entities, return empty array\n  if (entityIds.length === 0) {\n    return [];\n  }\n\n  try {\n    // Construct placeholders for SQL query\n    const placeholders = entityIds.map(() => \"?\").join(\",\");\n\n    // Construct and execute SQL query\n    const query = `SELECT * FROM code_entities WHERE id IN (${placeholders})`;\n    const entities = await executeQuery(query, entityIds);\n\n    return entities;\n  } catch (error) {\n    console.error(\"Error retrieving active context entities:\", error);\n    // Return empty array in case of error\n    return [];\n  }\n}\n\n/**\n * Retrieves prioritized and compressed snippets of the active context\n *\n * @param {any} prioritizerLogic - Logic module for prioritizing context items\n * @param {any} compressorLogic - Logic module for compressing content\n * @param {any} db - Database access module\n * @param {number} tokenBudget - Maximum number of tokens to include\n * @param {string[]} [queryKeywords] - Optional keywords to prioritize content\n * @returns {Promise<Snippet[]>} Array of prioritized and compressed context snippets\n */\nexport async function getActiveContextAsSnippets(\n  prioritizerLogic = ContextPrioritizerLogic,\n  compressorLogic = ContextCompressorLogic,\n  db = { executeQuery },\n  tokenBudget = 2000,\n  queryKeywords = []\n) {\n  try {\n    // 1. Get active entities\n    const activeEntities = await getActiveContextAsEntities();\n\n    // 2. If no active entities, return empty array\n    if (!activeEntities || activeEntities.length === 0) {\n      return [];\n    }\n\n    // 3. Convert entities to ContextSnippet format for prioritization\n    const contextSnippets = activeEntities.map((entity) => {\n      // Get recency information from context history\n      const recencyFactor = _calculateRecencyFactor(entity.id);\n\n      return {\n        entity_id: entity.id,\n        content: entity.content,\n        type: entity.type,\n        path: entity.path,\n        name: entity.name,\n        baseRelevance: 0.5 + recencyFactor, // Base score plus recency boost\n        metadata: {\n          symbolPath: entity.symbol_path,\n          parentId: entity.parent_id,\n          version: entity.version,\n        },\n      };\n    });\n\n    // 4. Get current focus for prioritization\n    const currentFocus = getActiveFocus();\n\n    // 5. Prioritize the context snippets\n    const prioritizedSnippets = await prioritizerLogic.prioritizeContexts(\n      contextSnippets,\n      queryKeywords,\n      currentFocus,\n      Math.max(50, activeEntities.length * 2) // Higher limit to prioritize from\n    );\n\n    // 6. Compress the prioritized snippets to fit within token budget\n    const compressedSnippets = await compressorLogic.manageTokenBudget(\n      prioritizedSnippets,\n      tokenBudget,\n      queryKeywords\n    );\n\n    // 7. Map the compressed snippets to the expected Snippet format\n    return compressedSnippets.map((snippet) => ({\n      entity_id: snippet.entity_id,\n      summarizedContent: snippet.processedContent || snippet.content,\n      originalScore: snippet.relevanceScore || snippet.baseRelevance,\n      type: snippet.type,\n    }));\n  } catch (error) {\n    console.error(\"Error generating context snippets:\", error);\n    return [];\n  }\n}\n\n/**\n * Calculate a recency factor for an entity based on context history\n *\n * @private\n * @param {string} entityId - The entity ID to check\n * @returns {number} A recency factor between 0 and 0.5\n */\nfunction _calculateRecencyFactor(entityId) {\n  // Start from the most recent history entries\n  for (let i = contextHistory.length - 1; i >= 0; i--) {\n    const record = contextHistory[i];\n\n    // If this entity was recently added, give it a boost\n    if (record.added && record.added.includes(entityId)) {\n      // Calculate how recent this addition was (0 = newest, 1 = oldest)\n      const recencyIndex =\n        (contextHistory.length - 1 - i) / contextHistory.length;\n      // Convert to a score boost between 0.1 and 0.5 (newer = higher boost)\n      return 0.5 - recencyIndex * 0.4;\n    }\n  }\n\n  // Default recency factor if not found in history\n  return 0.1;\n}\n\n/**\n * Returns a complete snapshot of the current active context state\n *\n * @returns {Promise<Object>} Object containing the current active context state\n */\nexport async function getActiveContextState() {\n  try {\n    // Get current active entities\n    const entities = await getActiveContextAsEntities();\n\n    // Get current focus\n    const focus = getActiveFocus();\n\n    // Get recent context history (last 10 changes)\n    const recentHistory = contextHistory.slice(-10);\n\n    // Create and return the context state\n    return {\n      activeEntityIds: [...activeEntityIds],\n      activeFocus: focus,\n      entities,\n      recentChanges: recentHistory,\n      timestamp: Date.now(),\n    };\n  } catch (error) {\n    console.error(\"Error getting active context state:\", error);\n    // Return basic state in case of error\n    return {\n      activeEntityIds: [...activeEntityIds],\n      activeFocus: activeFocus,\n      entities: [],\n      recentChanges: [],\n      timestamp: Date.now(),\n      error: error.message,\n    };\n  }\n}\n\n/**\n * Updates the focus based on code changes\n *\n * @param {Array<{entityId: string, changeType: string, content: string}>} codeChanges - Array of code change objects\n * @returns {Promise<{updatedFocus: FocusArea|null, addedEntities: string[], removedEntities: string[]}>}\n */\nexport async function updateFocusWithCodeChanges(codeChanges) {\n  try {\n    if (\n      !codeChanges ||\n      !Array.isArray(codeChanges) ||\n      codeChanges.length === 0\n    ) {\n      return {\n        updatedFocus: activeFocus,\n        addedEntities: [],\n        removedEntities: [],\n      };\n    }\n\n    // Track entities to add and remove\n    const entitiesToAdd = new Set();\n    const entitiesToRemove = new Set();\n\n    // Process each code change\n    for (const change of codeChanges) {\n      const { entityId, changeType } = change;\n\n      if (changeType === \"delete\") {\n        // If entity is deleted, remove it from active context\n        entitiesToRemove.add(entityId);\n      } else {\n        // For additions or modifications, add to active context\n        entitiesToAdd.add(entityId);\n      }\n    }\n\n    // Handle focus changes based on the most significant code change\n    let updatedFocus = activeFocus;\n\n    // If there are significant changes, potentially update the focus\n    if (codeChanges.length > 0) {\n      // Use the first changed file as a potential new focus\n      // A more sophisticated implementation would analyze the changes\n      // to determine the most important one\n      const primaryChange = codeChanges[0];\n\n      if (primaryChange.changeType !== \"delete\") {\n        // Query for more info about this entity\n        const query = `SELECT * FROM code_entities WHERE id = ?`;\n        const entityResults = await executeQuery(query, [\n          primaryChange.entityId,\n        ]);\n\n        if (entityResults.length > 0) {\n          const entity = entityResults[0];\n\n          // Determine whether to update focus\n          const shouldUpdateFocus =\n            // If no current focus\n            !activeFocus ||\n            // Or current focus is less specific than this entity\n            (entity.type === \"function\" && activeFocus.focus_type === \"file\") ||\n            // Or significant changes to the current focus\n            (activeFocus.related_entity_ids &&\n              activeFocus.related_entity_ids.includes(primaryChange.entityId) &&\n              primaryChange.changeType === \"modify\");\n\n          if (shouldUpdateFocus) {\n            // Create a new focus area based on the changed entity\n            updatedFocus = {\n              focus_id: entity.id,\n              focus_type: entity.type,\n              identifier: entity.path || entity.name,\n              description: `Focus on ${entity.type}: ${entity.name}`,\n              related_entity_ids: [entity.id],\n              keywords: [], // Would be filled with keywords from the entity\n              last_activated_at: Date.now(),\n              is_active: true,\n            };\n\n            // Update the active focus\n            setActiveFocus(updatedFocus);\n          }\n        }\n      }\n    }\n\n    // Update active context with added and removed entities\n    const addedEntities = [...entitiesToAdd];\n    const removedEntities = [...entitiesToRemove];\n\n    // Don't add entities that are being removed\n    const filteredAdded = addedEntities.filter(\n      (id) => !entitiesToRemove.has(id)\n    );\n\n    // Update the active context\n    updateActiveContext(filteredAdded, removedEntities);\n\n    return {\n      updatedFocus,\n      addedEntities: filteredAdded,\n      removedEntities,\n    };\n  } catch (error) {\n    console.error(\"Error updating focus with code changes:\", error);\n    return {\n      updatedFocus: activeFocus,\n      addedEntities: [],\n      removedEntities: [],\n      error: error.message,\n    };\n  }\n}\n", "/**\n * GlobalPatternRepository.js\n *\n * Manages global patterns that are available across all sessions.\n * Provides functionality to store, retrieve, and manage patterns in the global repository.\n */\n\nimport { executeQuery } from \"../db.js\";\nimport { v4 as uuidv4 } from \"uuid\";\n\n/**\n * @typedef {Object} PatternDefinition\n * @property {string} pattern_type - Type of the pattern\n * @property {string} [name] - Human-readable name for the pattern\n * @property {string} [description] - Description of what the pattern represents\n * @property {string} representation - Textual or structured representation of the pattern\n * @property {string|Object} [detection_rules] - Rules used to detect this pattern\n * @property {string} [language] - Programming language this pattern applies to (e.g., 'javascript', 'python', or 'any' for language-agnostic patterns)\n */\n\n/**\n * @typedef {Object} Pattern\n * @property {string} pattern_id - Unique identifier for the pattern\n * @property {string} pattern_type - Type of the pattern\n * @property {string} name - Human-readable name for the pattern\n * @property {string} description - Description of what the pattern represents\n * @property {string} representation - Textual or structured representation of the pattern\n * @property {string} detection_rules - JSON string of rules used to detect this pattern\n * @property {string} language - Programming language this pattern applies to (e.g., 'javascript', 'python', or 'any' for language-agnostic patterns)\n * @property {number} frequency - How often this pattern has been observed\n * @property {number} utility_score - How useful this pattern is rated\n * @property {number} confidence_score - Confidence in this pattern's correctness\n * @property {number} reinforcement_count - How many times this pattern has been reinforced\n * @property {boolean} is_global - Whether this pattern is global across sessions\n * @property {string} created_at - When this pattern was created\n * @property {string} updated_at - When this pattern was last updated\n */\n\n/**\n * Stores a pattern in the global pattern repository\n *\n * @param {PatternDefinition} patternDefinition - Definition of the pattern to store\n * @param {number} [confidenceScore=0.5] - Confidence score for this pattern (0-1)\n * @returns {Promise<string>} The ID of the newly stored global pattern\n */\nexport async function storeGlobalPattern(\n  patternDefinition,\n  confidenceScore = 0.5\n) {\n  try {\n    // 1. Generate a unique ID for the pattern\n    const pattern_id = uuidv4();\n\n    // 2. Extract and prepare pattern data with defaults\n    const {\n      pattern_type,\n      name = `Global_Pattern_${pattern_id.substring(0, 8)}`,\n      description = \"Globally recognized pattern\",\n      representation,\n      detection_rules = \"{}\",\n      language = \"any\",\n    } = patternDefinition;\n\n    // 3. Ensure representation and detection_rules are in string format for storage\n    const representationStr =\n      typeof representation === \"object\"\n        ? JSON.stringify(representation)\n        : representation;\n\n    const detectionRulesStr =\n      typeof detection_rules === \"object\"\n        ? JSON.stringify(detection_rules)\n        : detection_rules;\n\n    // 4. Set default scores and counters for a global pattern\n    const frequency = 0; // New global patterns start with zero frequency\n    const utility_score = 0.5; // Medium utility by default\n    const reinforcement_count = 1; // Initial reinforcement\n    const is_global = true; // Mark as global pattern\n    const created_at = new Date().toISOString();\n    const updated_at = created_at;\n\n    // 5. Insert the pattern into the database\n    const query = `\n      INSERT INTO project_patterns (\n        pattern_id, \n        pattern_type, \n        name, \n        description, \n        representation, \n        detection_rules,\n        language,\n        frequency,\n        utility_score,\n        confidence_score,\n        reinforcement_count,\n        is_global,\n        created_at,\n        updated_at\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `;\n\n    const params = [\n      pattern_id,\n      pattern_type,\n      name,\n      description,\n      representationStr,\n      detectionRulesStr,\n      language,\n      frequency,\n      utility_score,\n      confidenceScore,\n      reinforcement_count,\n      is_global,\n      created_at,\n      updated_at,\n    ];\n\n    await executeQuery(query, params);\n\n    console.log(\n      `Added new global pattern \"${name}\" (${pattern_id}) to repository`\n    );\n\n    // 6. Return the generated pattern ID\n    return pattern_id;\n  } catch (error) {\n    console.error(\"Error adding global pattern to repository:\", error);\n    throw new Error(`Failed to add global pattern: ${error.message}`);\n  }\n}\n\n/**\n * Retrieves global patterns from the repository with optional filtering\n *\n * @param {Object} filterOptions - Options to filter the global patterns\n * @param {string} [filterOptions.type] - Filter by pattern type\n * @param {number} [filterOptions.minConfidence] - Filter by minimum confidence score\n * @param {number} [filterOptions.limit] - Maximum number of patterns to return\n * @param {string} [filterOptions.language] - Filter by programming language\n * @returns {Promise<Pattern[]>} Array of global patterns matching the filters\n */\nexport async function retrieveGlobalPatterns(filterOptions = {}) {\n  try {\n    const { type, minConfidence, limit, language } = filterOptions;\n\n    // Build the query\n    let query = \"SELECT * FROM project_patterns WHERE is_global = TRUE\";\n    const params = [];\n\n    // Apply additional filters if provided\n    if (type) {\n      query += \" AND pattern_type = ?\";\n      params.push(type);\n    }\n\n    if (minConfidence !== undefined && !isNaN(minConfidence)) {\n      query += \" AND confidence_score >= ?\";\n      params.push(minConfidence);\n    }\n\n    // Apply language filter if provided\n    if (language) {\n      query += \" AND (language = ? OR language = ? OR language IS NULL)\";\n      params.push(language, \"any\"); // Include language-specific, universal, and legacy NULL patterns\n    }\n\n    // Order by confidence score and utility score\n    query += \" ORDER BY confidence_score DESC, utility_score DESC\";\n\n    // Apply limit if provided\n    if (limit !== undefined && !isNaN(limit) && limit > 0) {\n      query += \" LIMIT ?\";\n      params.push(limit);\n    }\n\n    // Execute the query\n    const patterns = await executeQuery(query, params);\n\n    // Check if patterns has a rows property and it's an array\n    const rows =\n      patterns && patterns.rows && Array.isArray(patterns.rows)\n        ? patterns.rows\n        : Array.isArray(patterns)\n        ? patterns\n        : [];\n\n    // If no valid results, return empty array\n    if (rows.length === 0) {\n      console.warn(\"No valid global patterns found\");\n      return [];\n    }\n\n    // Parse detection_rules JSON for each pattern\n    return rows.map((pattern) => ({\n      ...pattern,\n      detection_rules: JSON.parse(pattern.detection_rules || \"{}\"),\n      is_global: Boolean(pattern.is_global), // Ensure is_global is a boolean\n    }));\n  } catch (error) {\n    console.error(\"Error retrieving global patterns:\", error);\n    throw new Error(`Failed to retrieve global patterns: ${error.message}`);\n  }\n}\n\n/**\n * Promotes an existing pattern to global status\n *\n * @param {string} patternId - ID of the pattern to promote to global\n * @param {number} [newConfidence] - New confidence score to assign (optional)\n * @returns {Promise<boolean>} True if the pattern was successfully promoted, false otherwise\n */\nexport async function promotePatternToGlobal(patternId, newConfidence) {\n  try {\n    // Build the update query\n    let query = \"UPDATE project_patterns SET is_global = TRUE\";\n    const params = [];\n\n    // Update confidence score if provided\n    if (newConfidence !== undefined && !isNaN(newConfidence)) {\n      query += \", confidence_score = ?\";\n      params.push(newConfidence);\n    }\n\n    // Update the timestamp\n    const updated_at = new Date().toISOString();\n    query += \", updated_at = ?\";\n    params.push(updated_at);\n\n    // Add WHERE clause\n    query += \" WHERE pattern_id = ?\";\n    params.push(patternId);\n\n    // Execute the query\n    const result = await executeQuery(query, params);\n\n    // Check if a row was affected\n    const success = result.affectedRows > 0;\n\n    if (success) {\n      console.log(\n        `Pattern ${patternId} successfully promoted to global status`\n      );\n\n      if (newConfidence !== undefined) {\n        console.log(`Updated confidence score to ${newConfidence}`);\n      }\n    } else {\n      console.warn(`No pattern with ID ${patternId} found to promote`);\n    }\n\n    return success;\n  } catch (error) {\n    console.error(`Error promoting pattern ${patternId} to global:`, error);\n    throw new Error(`Failed to promote pattern: ${error.message}`);\n  }\n}\n\n/**\n * Records a pattern observation and updates its metrics\n *\n * @param {string} patternId - ID of the pattern to reinforce\n * @param {'usage'|'confirmation'|'rejection'} observationType - Type of the observation\n * @param {any} [contextData] - Additional context data for the observation\n * @returns {Promise<void>}\n */\nexport async function reinforcePattern(\n  patternId,\n  observationType,\n  contextData = {}\n) {\n  try {\n    // Create observation ID\n    const observation_id = uuidv4();\n    const timestamp = new Date().toISOString();\n\n    // Convert contextData to JSON string\n    const observation_data = JSON.stringify(contextData || {});\n\n    // Define adjustment values\n    const confidenceAdjustments = {\n      usage: 0.03, // Small increase for usage\n      confirmation: 0.05, // Moderate increase for explicit confirmation\n      rejection: -0.08, // Larger decrease for rejection\n    };\n\n    const utilityAdjustments = {\n      usage: 0.04, // Moderate increase for usage (indicates utility)\n      confirmation: 0.03, // Small increase for confirmation\n      rejection: -0.02, // Small decrease for rejection\n    };\n\n    // Begin transaction\n    await executeQuery(\"BEGIN TRANSACTION\");\n\n    try {\n      // 1. Insert observation record\n      const insertObservationQuery = `\n        INSERT INTO pattern_observations (\n          observation_id,\n          pattern_id,\n          observation_type,\n          observation_data,\n          timestamp\n        ) VALUES (?, ?, ?, ?, ?)\n      `;\n\n      await executeQuery(insertObservationQuery, [\n        observation_id,\n        patternId,\n        observationType,\n        observation_data,\n        timestamp,\n      ]);\n\n      // 2. Get current pattern data\n      const getPatternQuery =\n        \"SELECT confidence_score, utility_score, reinforcement_count FROM project_patterns WHERE pattern_id = ?\";\n      const patternResult = await executeQuery(getPatternQuery, [patternId]);\n\n      if (patternResult.length === 0) {\n        throw new Error(`Pattern with ID ${patternId} not found`);\n      }\n\n      const pattern = patternResult[0];\n\n      // 3. Calculate new scores\n      let newConfidenceScore =\n        pattern.confidence_score +\n        (confidenceAdjustments[observationType] || 0);\n      let newUtilityScore =\n        pattern.utility_score + (utilityAdjustments[observationType] || 0);\n\n      // Ensure scores stay within bounds\n      newConfidenceScore = Math.max(0, Math.min(1, newConfidenceScore));\n      newUtilityScore = Math.max(0, Math.min(1, newUtilityScore));\n\n      // 4. Update pattern metrics\n      const updatePatternQuery = `\n        UPDATE project_patterns SET\n          reinforcement_count = reinforcement_count + 1,\n          confidence_score = ?,\n          utility_score = ?,\n          updated_at = ?\n      `;\n\n      // Add last_detected_at update if observation is a usage\n      const updateLastDetected =\n        observationType === \"usage\" ? \", last_detected_at = ?\" : \"\";\n      const updatePatternParams = [\n        newConfidenceScore,\n        newUtilityScore,\n        timestamp,\n      ];\n\n      // Add timestamp parameter if updating last_detected_at\n      if (observationType === \"usage\") {\n        updatePatternParams.push(timestamp);\n      }\n\n      // Complete the query with WHERE clause\n      const finalUpdateQuery =\n        updatePatternQuery + updateLastDetected + \" WHERE pattern_id = ?\";\n      updatePatternParams.push(patternId);\n\n      await executeQuery(finalUpdateQuery, updatePatternParams);\n\n      // Commit transaction\n      await executeQuery(\"COMMIT\");\n\n      console.log(\n        `Pattern ${patternId} reinforced with '${observationType}' observation`\n      );\n    } catch (error) {\n      // Rollback transaction in case of error\n      await executeQuery(\"ROLLBACK\");\n      throw error;\n    }\n  } catch (error) {\n    console.error(`Error reinforcing pattern ${patternId}:`, error);\n    throw new Error(`Failed to reinforce pattern: ${error.message}`);\n  }\n}\n\n/**\n * Calculate similarity between two patterns\n *\n * @param {Pattern} pattern1 - First pattern to compare\n * @param {Pattern} pattern2 - Second pattern to compare\n * @returns {number} Similarity score between 0 and 1\n */\nexport function calculatePatternSimilarity(pattern1, pattern2) {\n  // Initialize similarity scores for different components\n  let representationSimilarity = 0;\n  let rulesSimilarity = 0;\n  let typeSimilarity = 0;\n  let languageSimilarity = 1.0; // Default to full match for language\n\n  // 1. Base type similarity on pattern_type match\n  typeSimilarity = pattern1.pattern_type === pattern2.pattern_type ? 1.0 : 0.3;\n\n  // 2. Check language similarity\n  if (pattern1.language && pattern2.language) {\n    // If both patterns have specific languages defined\n    if (pattern1.language === \"any\" || pattern2.language === \"any\") {\n      // If either is language-agnostic, still a good match but slightly penalized\n      languageSimilarity = 0.9;\n    } else if (pattern1.language !== pattern2.language) {\n      // Different specific languages - significant penalty\n      languageSimilarity = 0.2; // Significantly different patterns\n    }\n  } else if (pattern1.language || pattern2.language) {\n    // One has a language, the other doesn't (might be a legacy pattern or NULL)\n    // This is a reasonable match but less confident\n    languageSimilarity = 0.7;\n  }\n\n  // 3. Compare representations using Jaccard similarity\n  representationSimilarity = calculateJaccardSimilarity(\n    extractTokensFromField(pattern1.representation),\n    extractTokensFromField(pattern2.representation)\n  );\n\n  // 4. Compare detection_rules using Jaccard similarity\n  rulesSimilarity = calculateJaccardSimilarity(\n    extractTokensFromField(pattern1.detection_rules),\n    extractTokensFromField(pattern2.detection_rules)\n  );\n\n  // 5. Combine the similarities with weights\n  // Representation is the most important, followed by rules, then language and type\n  const combinedSimilarity =\n    representationSimilarity * 0.5 +\n    rulesSimilarity * 0.3 +\n    languageSimilarity * 0.15 +\n    typeSimilarity * 0.05;\n\n  // Ensure the result is within [0,1]\n  return Math.max(0, Math.min(1, combinedSimilarity));\n}\n\n/**\n * Extract tokens from a pattern field which could be a JSON string or regular text\n *\n * @param {string} field - The field to extract tokens from\n * @returns {string[]} Array of normalized tokens\n */\nfunction extractTokensFromField(field) {\n  if (!field) return [];\n\n  let content = field;\n\n  // If the field is a JSON string, try to parse it to get its content\n  if (\n    typeof field === \"string\" &&\n    (field.startsWith(\"{\") || field.startsWith(\"[\"))\n  ) {\n    try {\n      const parsed = JSON.parse(field);\n      // Convert the parsed object back to a string for tokenization\n      content = JSON.stringify(parsed, null, 0).toLowerCase();\n    } catch (e) {\n      // If parsing fails, use the original string\n      content = field.toLowerCase();\n    }\n  } else if (typeof field === \"object\") {\n    // If it's already an object, stringify it\n    content = JSON.stringify(field, null, 0).toLowerCase();\n  } else {\n    // For plain strings, just use as is\n    content = String(field).toLowerCase();\n  }\n\n  // Simple tokenization: split by non-alphanumeric chars and filter empty tokens\n  // In a real implementation, we would use TextTokenizerLogic.tokenize and stem\n  return content\n    .split(/[^a-z0-9_]+/)\n    .filter((token) => token.length > 1)\n    .map((token) => token.trim());\n}\n\n/**\n * Calculate Jaccard similarity index between two sets of tokens\n *\n * @param {string[]} tokens1 - First set of tokens\n * @param {string[]} tokens2 - Second set of tokens\n * @returns {number} Jaccard similarity index (0-1)\n */\nfunction calculateJaccardSimilarity(tokens1, tokens2) {\n  if (!tokens1.length && !tokens2.length) return 1.0; // Both empty means identical\n  if (!tokens1.length || !tokens2.length) return 0.0; // One empty means no similarity\n\n  // Create sets from the token arrays to eliminate duplicates\n  const set1 = new Set(tokens1);\n  const set2 = new Set(tokens2);\n\n  // Calculate intersection size\n  let intersectionSize = 0;\n  for (const token of set1) {\n    if (set2.has(token)) {\n      intersectionSize++;\n    }\n  }\n\n  // Calculate union size\n  const unionSize = set1.size + set2.size - intersectionSize;\n\n  // Jaccard similarity = size of intersection / size of union\n  return intersectionSize / unionSize;\n}\n\n/**\n * Consolidates session patterns by promoting or merging them with global patterns\n *\n * @param {Object} options - Options for consolidation\n * @param {number} [options.minReinforcementCount=3] - Minimum reinforcement count for promotion\n * @param {number} [options.minConfidence=0.6] - Minimum confidence score for promotion\n * @param {number} [options.similarityThreshold=0.8] - Threshold for pattern similarity to consider merging\n * @returns {Promise<{promoted: number, merged: number}>} Count of promoted and merged patterns\n */\nexport async function consolidateSessionPatterns(options = {}) {\n  try {\n    // Set default options\n    const {\n      minReinforcementCount = 3,\n      minConfidence = 0.6,\n      similarityThreshold = 0.8,\n    } = options;\n\n    console.log(\n      `Starting pattern consolidation process (minReinforcementCount=${minReinforcementCount}, minConfidence=${minConfidence})`\n    );\n\n    // Track counts\n    let promotedCount = 0;\n    let mergedCount = 0;\n\n    // 1. Find non-global patterns that meet the criteria\n    const query = `\n      SELECT * FROM project_patterns \n      WHERE is_global = FALSE \n      AND reinforcement_count >= ? \n      AND confidence_score >= ?\n    `;\n\n    const sessionPatterns = await executeQuery(query, [\n      minReinforcementCount,\n      minConfidence,\n    ]);\n\n    console.log(\n      `Found ${sessionPatterns.length} session patterns that qualify for promotion or merging`\n    );\n\n    if (sessionPatterns.length === 0) {\n      return { promoted: 0, merged: 0 };\n    }\n\n    // 2. Get existing global patterns for potential merging\n    const globalPatterns = await retrieveGlobalPatterns();\n\n    // 3. Process each qualifying session pattern\n    for (const sessionPattern of sessionPatterns) {\n      const patternId = sessionPattern.pattern_id;\n\n      // Try to find a similar global pattern for merging\n      let shouldPromote = true;\n      let similarGlobalPattern = null;\n\n      for (const globalPattern of globalPatterns) {\n        const similarity = calculatePatternSimilarity(\n          sessionPattern,\n          globalPattern\n        );\n\n        if (similarity >= similarityThreshold) {\n          shouldPromote = false;\n          similarGlobalPattern = globalPattern;\n          break;\n        }\n      }\n\n      if (shouldPromote) {\n        // Promote the pattern to global status\n        console.log(`Promoting session pattern ${patternId} to global status`);\n        const promoted = await promotePatternToGlobal(\n          patternId,\n          sessionPattern.confidence_score\n        );\n\n        if (promoted) {\n          promotedCount++;\n          console.log(`Successfully promoted pattern ${patternId}`);\n        }\n      } else if (similarGlobalPattern) {\n        // Placeholder for merging logic\n        console.log(\n          `Merge attempt for pattern ${patternId} with ${similarGlobalPattern.pattern_id}`\n        );\n\n        // In a real implementation, the merging would:\n        // 1. Update the global pattern with some attributes from the session pattern\n        // 2. Maybe increase confidence/utility/reinforcement_count of the global pattern\n        // 3. Delete the session pattern or mark it as merged\n\n        // For now, just log and count\n        mergedCount++;\n      }\n    }\n\n    console.log(\n      `Pattern consolidation complete. Promoted: ${promotedCount}, Merged: ${mergedCount}`\n    );\n\n    return {\n      promoted: promotedCount,\n      merged: mergedCount,\n    };\n  } catch (error) {\n    console.error(\"Error consolidating session patterns:\", error);\n    throw new Error(`Failed to consolidate session patterns: ${error.message}`);\n  }\n}\n\n/**\n * Schedules a periodic background process for pattern consolidation\n *\n * @param {number} [intervalMinutes=60] - The interval in minutes to run the consolidation\n * @returns {number} The interval ID that can be used to clear the interval if needed\n */\nexport function scheduleConsolidation(intervalMinutes = 60) {\n  // Convert intervalMinutes to milliseconds\n  const intervalMs = intervalMinutes * 60 * 1000;\n\n  console.log(\n    `Scheduling pattern consolidation to run every ${intervalMinutes} minutes`\n  );\n\n  // Set up the interval\n  const intervalId = setInterval(async () => {\n    console.log(\n      `Running scheduled pattern consolidation (interval: ${intervalMinutes} minutes)`\n    );\n\n    try {\n      // Call consolidateSessionPatterns with sensible defaults\n      const result = await consolidateSessionPatterns({\n        minReinforcementCount: 5,\n        minConfidence: 0.7,\n      });\n\n      console.log(\n        `Pattern consolidation completed: ${result.promoted} patterns promoted, ${result.merged} patterns merged`\n      );\n    } catch (error) {\n      console.error(`Error during scheduled pattern consolidation:`, error);\n    }\n  }, intervalMs);\n\n  return intervalId;\n}\n\n/**\n * Retrieves usage statistics for a specific pattern\n *\n * @param {string} patternId - The ID of the pattern to get statistics for\n * @returns {Promise<{usageCount: number, successRate: number, avgConfidence: number}>} Usage statistics\n */\nexport async function getPatternUsageStats(patternId) {\n  try {\n    // Get observation counts from pattern_observations table\n    const observationsQuery = `\n      SELECT \n        COUNT(*) as total_observations,\n        SUM(CASE WHEN observation_type IN ('usage', 'confirmation') THEN 1 ELSE 0 END) as successful_uses,\n        SUM(CASE WHEN observation_type = 'rejection' THEN 1 ELSE 0 END) as failed_uses\n      FROM pattern_observations\n      WHERE pattern_id = ?\n    `;\n\n    const observationsResult = await executeQuery(observationsQuery, [\n      patternId,\n    ]);\n\n    if (!observationsResult || observationsResult.length === 0) {\n      return {\n        usageCount: 0,\n        successRate: 0,\n        avgConfidence: 0,\n      };\n    }\n\n    const stats = observationsResult[0];\n    const usageCount = stats.total_observations || 0;\n\n    // Calculate success rate: (successful uses) / (successful uses + failed uses)\n    // Avoid division by zero if there are no success/failure observations\n    const successPlusFailed =\n      (stats.successful_uses || 0) + (stats.failed_uses || 0);\n    const successRate =\n      successPlusFailed > 0\n        ? (stats.successful_uses || 0) / successPlusFailed\n        : 0;\n\n    // Get current confidence score from project_patterns table\n    const patternQuery = `\n      SELECT confidence_score\n      FROM project_patterns\n      WHERE pattern_id = ?\n    `;\n\n    const patternResult = await executeQuery(patternQuery, [patternId]);\n\n    // If pattern not found, return zero confidence\n    const avgConfidence =\n      patternResult && patternResult.length > 0\n        ? patternResult[0].confidence_score\n        : 0;\n\n    return {\n      usageCount,\n      successRate,\n      avgConfidence,\n    };\n  } catch (error) {\n    console.error(`Error getting pattern usage stats for ${patternId}:`, error);\n    throw new Error(`Failed to get pattern usage statistics: ${error.message}`);\n  }\n}\n", "/**\n * Schema definitions for MCP tool inputs and outputs\n * Using Zod for schema validation\n */\n\nimport { z } from \"zod\";\nimport { DEFAULT_TOKEN_BUDGET } from \"../config.js\";\n\n/**\n * Schema for initialize_conversation_context tool input\n * Note: projectId field is explicitly removed as the server operates\n * with a database instance dedicated to a single project\n */\nexport const initializeConversationContextInputSchema = {\n  // No projectId field as per the blueprint\n  initialQuery: z.string().optional(),\n  focusHint: z\n    .object({\n      type: z.string(),\n      identifier: z.string(),\n    })\n    .optional(),\n  includeArchitecture: z.boolean().optional().default(true),\n  includeRecentConversations: z.boolean().optional().default(true),\n  maxCodeContextItems: z.number().optional().default(5),\n  maxRecentChanges: z.number().optional().default(5),\n  contextDepth: z\n    .enum([\"minimal\", \"standard\", \"comprehensive\"])\n    .optional()\n    .default(\"standard\"),\n  tokenBudget: z.number().optional().default(DEFAULT_TOKEN_BUDGET),\n};\n\n/**\n * Schema for initialize_conversation_context tool output\n * Includes comprehensive context object\n */\nexport const initializeConversationContextOutputSchema = {\n  conversationId: z.string(),\n  initialContextSummary: z.string(),\n  predictedIntent: z.string().optional(),\n  comprehensiveContext: z\n    .object({\n      codeContext: z.array(z.any()).optional(),\n      architectureContext: z\n        .object({\n          summary: z.string(),\n          sources: z.array(\n            z.object({\n              name: z.string(),\n              path: z.string(),\n            })\n          ),\n        })\n        .nullable(),\n      recentConversations: z\n        .array(\n          z.object({\n            timestamp: z.number(),\n            summary: z.string(),\n            purpose: z.string(),\n          })\n        )\n        .optional(),\n      activeWorkflows: z\n        .array(\n          z.object({\n            name: z.string(),\n            description: z.string(),\n            timestamp: z.number(),\n          })\n        )\n        .optional(),\n      projectStructure: z.any().nullable(),\n      recentChanges: z\n        .array(\n          z.object({\n            timestamp: z.number(),\n            files: z.array(z.string()),\n            summary: z.string(),\n          })\n        )\n        .optional(),\n      globalPatterns: z\n        .array(\n          z.object({\n            name: z.string(),\n            type: z.string(),\n            description: z.string(),\n            confidence: z.number(),\n          })\n        )\n        .optional(),\n    })\n    .optional(),\n};\n\n/**\n * Schema for update_conversation_context tool input\n * Note: projectId field is explicitly removed as the server operates\n * with a database instance dedicated to a single project\n */\nexport const updateConversationContextInputSchema = {\n  // No projectId field as per the blueprint\n  conversationId: z.string(),\n  newMessages: z\n    .array(\n      z.object({\n        role: z.enum([\"user\", \"assistant\", \"system\"]),\n        content: z.string(),\n      })\n    )\n    .optional()\n    .default([]),\n  codeChanges: z\n    .array(\n      z.object({\n        filePath: z.string(),\n        newContent: z.string(),\n        languageHint: z.string().optional(),\n      })\n    )\n    .optional()\n    .default([]),\n  preserveContextOnTopicShift: z.boolean().optional().default(true),\n  contextIntegrationLevel: z\n    .enum([\"minimal\", \"balanced\", \"aggressive\"])\n    .optional()\n    .default(\"balanced\"),\n  trackIntentTransitions: z.boolean().optional().default(true),\n  tokenBudget: z.number().optional().default(DEFAULT_TOKEN_BUDGET),\n};\n\n/**\n * Schema for update_conversation_context tool output\n * Includes continuity tracking, context synthesis, and intent transition detection\n */\nexport const updateConversationContextOutputSchema = {\n  status: z.enum([\"success\", \"partial\", \"failure\"]),\n  updatedFocus: z\n    .object({\n      type: z.string(),\n      identifier: z.string(),\n    })\n    .optional(),\n  contextContinuity: z.object({\n    preserved: z.boolean(),\n    topicShift: z.boolean(),\n    intentTransition: z.boolean(),\n  }),\n  contextSynthesis: z\n    .object({\n      summary: z.string(),\n      topPriorities: z.array(z.string()).optional(),\n    })\n    .optional(),\n  intentTransition: z\n    .object({\n      from: z.string().nullable(),\n      to: z.string().nullable(),\n      confidence: z.number(),\n    })\n    .optional(),\n};\n\n/**\n * Schema for retrieve_relevant_context tool input\n * Note: projectId field is explicitly removed as the server operates\n * with a database instance dedicated to a single project\n */\nexport const retrieveRelevantContextInputSchema = {\n  // No projectId field as per the blueprint\n  conversationId: z.string(),\n  query: z.string(),\n  tokenBudget: z.number().optional().default(DEFAULT_TOKEN_BUDGET),\n  constraints: z\n    .object({\n      entityTypes: z.array(z.string()).optional(),\n      filePaths: z.array(z.string()).optional(),\n      includeConversation: z.boolean().optional().default(true),\n      crossTopicSearch: z.boolean().optional().default(false),\n      focusOverride: z\n        .object({ type: z.string(), identifier: z.string() })\n        .optional(),\n    })\n    .optional()\n    .default({}),\n  contextFilters: z\n    .object({\n      minRelevanceScore: z.number().optional().default(0.3),\n      excludeTypes: z.array(z.string()).optional(),\n      preferredLanguages: z.array(z.string()).optional(),\n      timeframe: z\n        .object({\n          from: z.number().optional(),\n          to: z.number().optional(),\n        })\n        .optional(),\n    })\n    .optional()\n    .default({}),\n  weightingStrategy: z\n    .enum([\"relevance\", \"recency\", \"hierarchy\", \"balanced\"])\n    .optional()\n    .default(\"balanced\"),\n  balanceStrategy: z\n    .enum([\"proportional\", \"equal_representation\", \"priority_based\"])\n    .optional()\n    .default(\"proportional\"),\n  contextBalance: z\n    .union([\n      z.enum([\"auto\", \"code_heavy\", \"balanced\", \"documentation_focused\"]),\n      z.object({\n        code: z.number().optional(),\n        conversation: z.number().optional(),\n        documentation: z.number().optional(),\n        patterns: z.number().optional(),\n      }),\n    ])\n    .optional()\n    .default(\"auto\"),\n  sourceTypePreferences: z\n    .object({\n      includePatterns: z.boolean().optional().default(true),\n      includeDocumentation: z.boolean().optional().default(true),\n      prioritizeTestCases: z.boolean().optional().default(false),\n      prioritizeExamples: z.boolean().optional().default(false),\n    })\n    .optional()\n    .default({}),\n};\n\n/**\n * Schema for retrieve_relevant_context tool output\n * Includes enhanced context snippets with confidence scoring,\n * source attribution, and relevance explanations\n */\nexport const retrieveRelevantContextOutputSchema = {\n  contextSnippets: z.array(\n    z.object({\n      type: z.string(), // 'code', 'conversation', 'documentation', 'pattern'\n      content: z.string(),\n      entity_id: z.string(),\n      relevanceScore: z.number(),\n      confidenceScore: z.number(),\n      metadata: z.any(), // Flexible metadata based on type\n      sourceAttribution: z.string(),\n      relevanceExplanation: z.string(),\n    })\n  ),\n  retrievalSummary: z.string(),\n  contextMetrics: z\n    .object({\n      totalFound: z.number(),\n      selected: z.number(),\n      averageConfidence: z.number(),\n      typeDistribution: z.object({\n        code: z.number(),\n        conversation: z.number(),\n        documentation: z.number(),\n        pattern: z.number(),\n      }),\n    })\n    .optional(),\n};\n\n/**\n * Schema for record_milestone_context tool input\n * Includes milestone categorization and impact assessment control\n */\nexport const recordMilestoneContextInputSchema = {\n  conversationId: z.string(),\n  name: z.string(),\n  description: z.string().optional(),\n  customData: z.any().optional(),\n  milestoneCategory: z\n    .enum([\n      \"bug_fix\",\n      \"feature_completion\",\n      \"refactoring\",\n      \"documentation\",\n      \"test\",\n      \"configuration\",\n      \"uncategorized\",\n    ])\n    .optional()\n    .default(\"uncategorized\"),\n  assessImpact: z.boolean().optional().default(true),\n};\n\n/**\n * Schema for record_milestone_context tool output\n * Includes milestone category, related entities count, and detailed impact assessment\n */\nexport const recordMilestoneContextOutputSchema = {\n  milestoneId: z.string(),\n  status: z.string(),\n  milestoneCategory: z.string(),\n  relatedEntitiesCount: z.number(),\n  impactAssessment: z\n    .object({\n      impactScore: z.number(),\n      impactLevel: z.string(),\n      impactSummary: z.string(),\n      scopeMetrics: z\n        .object({\n          directlyModifiedEntities: z.number(),\n          potentiallyImpactedEntities: z.number(),\n          impactedComponents: z.number(),\n          criticalPathsCount: z.number(),\n        })\n        .optional(),\n      stabilityRisk: z.number().optional(),\n      criticalPaths: z\n        .array(\n          z.object({\n            sourceId: z.string(),\n            path: z.string(),\n            dependencyCount: z.number(),\n          })\n        )\n        .optional(),\n      mostImpactedComponents: z\n        .array(\n          z.object({\n            name: z.string(),\n            count: z.number(),\n          })\n        )\n        .optional(),\n      error: z.string().optional(),\n    })\n    .nullable(),\n};\n\n/**\n * Schema for finalize_conversation_context tool input\n * Includes enhanced options for learning extraction, pattern promotion,\n * related topics synthesis, and next steps generation\n */\nexport const finalizeConversationContextInputSchema = {\n  conversationId: z.string(),\n  clearActiveContext: z.boolean().optional().default(false),\n  extractLearnings: z.boolean().optional().default(true),\n  promotePatterns: z.boolean().optional().default(true),\n  synthesizeRelatedTopics: z.boolean().optional().default(true),\n  generateNextSteps: z.boolean().optional().default(true),\n  outcome: z\n    .enum([\"completed\", \"abandoned\", \"paused\", \"reference_only\"])\n    .optional()\n    .default(\"completed\"),\n};\n\n/**\n * Schema for finalize_conversation_context tool output\n * Includes substantially richer output with extracted learnings, promoted patterns,\n * related conversations synthesis, and next steps suggestions\n */\nexport const finalizeConversationContextOutputSchema = {\n  status: z.string(),\n  summary: z.string(),\n  purpose: z.string(),\n\n  // Extracted learnings with confidence scores\n  extractedLearnings: z\n    .object({\n      learnings: z.array(\n        z.object({\n          type: z.string(),\n          content: z.string(),\n          confidence: z.number(),\n          // Other properties depend on learning type\n          patternId: z.string().optional(),\n          context: z.array(z.any()).optional(),\n          messageReference: z.string().optional(),\n          relatedIssues: z.array(z.any()).optional(),\n          alternatives: z.array(z.string()).optional(),\n          rationale: z.string().optional(),\n          codeReferences: z.array(z.any()).optional(),\n          applicability: z.number().optional(),\n        })\n      ),\n      count: z.number(),\n      byType: z.record(z.string(), z.number()),\n      averageConfidence: z.number(),\n      error: z.string().optional(),\n    })\n    .nullable(),\n\n  // Promoted patterns\n  promotedPatterns: z\n    .object({\n      promoted: z.number(),\n      patterns: z.array(\n        z.object({\n          patternId: z.string(),\n          name: z.string(),\n          type: z.string(),\n          promoted: z.boolean(),\n          confidence: z.number(),\n        })\n      ),\n      error: z.string().optional(),\n    })\n    .nullable(),\n\n  // Related conversations synthesis\n  relatedConversations: z\n    .object({\n      relatedCount: z.number(),\n      conversations: z.array(\n        z.object({\n          conversationId: z.string(),\n          summary: z.string(),\n          timestamp: z.number(),\n          similarityScore: z.number(),\n          commonTopics: z.array(z.string()),\n        })\n      ),\n      synthesizedInsights: z.array(\n        z.object({\n          topic: z.string(),\n          insight: z.string(),\n          conversationCount: z.number(),\n          sourceSummaries: z.array(\n            z.object({\n              conversationId: z.string(),\n              summary: z.string(),\n            })\n          ),\n        })\n      ),\n      error: z.string().optional(),\n    })\n    .nullable(),\n\n  // Next steps and follow-up suggestions\n  nextSteps: z\n    .object({\n      suggestedNextSteps: z.array(\n        z.object({\n          action: z.string(),\n          priority: z.enum([\"high\", \"medium\", \"low\"]),\n          rationale: z.string(),\n        })\n      ),\n      followUpTopics: z.array(\n        z.object({\n          topic: z.string(),\n          priority: z.enum([\"high\", \"medium\", \"low\"]),\n          rationale: z.string(),\n        })\n      ),\n      referenceMaterials: z.array(\n        z.object({\n          title: z.string(),\n          path: z.string(),\n          type: z.string(),\n          relevance: z.number(),\n        })\n      ),\n      error: z.string().optional(),\n    })\n    .nullable(),\n};\n", "/**\n * updateConversationContext.tool.js\n *\n * MCP tool implementation for updating an existing conversation context\n * This tool processes new messages and code changes, manages topic shifts,\n * and ensures context continuity throughout the conversation\n */\n\nimport { z } from \"zod\";\nimport { executeQuery } from \"../db.js\";\nimport * as ConversationIntelligence from \"../logic/ConversationIntelligence.js\";\nimport * as KnowledgeProcessor from \"../logic/KnowledgeProcessor.js\";\nimport * as TimelineManagerLogic from \"../logic/TimelineManagerLogic.js\";\nimport * as IntentPredictorLogic from \"../logic/IntentPredictorLogic.js\";\nimport * as ActiveContextManager from \"../logic/ActiveContextManager.js\";\nimport * as ConversationSegmenter from \"../logic/ConversationSegmenter.js\";\nimport * as ConversationPurposeDetector from \"../logic/ConversationPurposeDetector.js\";\nimport * as ContextCompressorLogic from \"../logic/ContextCompressorLogic.js\";\nimport { logMessage } from \"../utils/logger.js\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nimport {\n  updateConversationContextInputSchema,\n  updateConversationContextOutputSchema,\n} from \"../schemas/toolSchemas.js\";\n\n/**\n * Handler for update_conversation_context tool\n *\n * @param {object} input - Tool input parameters\n * @param {object} sdkContext - SDK context\n * @returns {Promise<object>} Tool output\n */\nasync function handler(input, sdkContext) {\n  try {\n    logMessage(\"INFO\", `update_conversation_context tool started`, {\n      conversationId: input.conversationId,\n      messageCount: input.newMessages?.length || 0,\n      codeChangeCount: input.codeChanges?.length || 0,\n    });\n\n    // 1. Extract input parameters with defaults\n    const {\n      conversationId,\n      newMessages = [],\n      codeChanges = [],\n      preserveContextOnTopicShift = true,\n      contextIntegrationLevel = \"balanced\",\n      trackIntentTransitions = true,\n      tokenBudget = 4000,\n    } = input;\n\n    // Validate conversation ID is provided\n    if (!conversationId) {\n      const error = new Error(\"conversationId is required\");\n      error.code = \"MISSING_CONVERSATION_ID\";\n      throw error;\n    }\n\n    logMessage(\"DEBUG\", `Processing update with parameters`, {\n      preserveContextOnTopicShift,\n      contextIntegrationLevel,\n      trackIntentTransitions,\n    });\n\n    // 2. Initialize tracking variables for context transitions\n    let topicShift = false;\n    let intentTransition = false;\n    let previousIntent = null;\n    let currentIntent = null;\n    let contextPreserved = true;\n    let currentFocus = null;\n\n    // 3. Get current context state before changes\n    try {\n      const previousContextState =\n        await ActiveContextManager.getActiveContextState();\n      logMessage(\"DEBUG\", `Retrieved previous context state`, {\n        hasPreviousContext: !!previousContextState,\n      });\n\n      if (trackIntentTransitions) {\n        previousIntent = await ConversationPurposeDetector.getActivePurpose(\n          conversationId\n        );\n        logMessage(\"DEBUG\", `Retrieved previous intent`, { previousIntent });\n      }\n    } catch (err) {\n      logMessage(\n        \"WARN\",\n        `Failed to retrieve previous context state, continuing with defaults`,\n        {\n          error: err.message,\n        }\n      );\n      // Continue with defaults already initialized\n    }\n\n    // 4. Process new messages if any\n    if (newMessages.length > 0) {\n      logMessage(\"INFO\", `Processing ${newMessages.length} new messages`);\n      try {\n        const processedMessages = await processNewMessages(\n          conversationId,\n          newMessages,\n          {\n            trackIntentTransitions,\n          }\n        );\n\n        topicShift = processedMessages.topicShift;\n        logMessage(\"DEBUG\", `Message processing completed`, {\n          topicShift: topicShift,\n        });\n\n        if (trackIntentTransitions) {\n          intentTransition = processedMessages.intentTransition;\n          currentIntent = processedMessages.currentIntent;\n\n          if (intentTransition) {\n            logMessage(\"INFO\", `Intent transition detected`, {\n              from: previousIntent,\n              to: currentIntent,\n            });\n          }\n        }\n      } catch (err) {\n        logMessage(\"ERROR\", `Failed to process new messages`, {\n          error: err.message,\n          conversationId,\n        });\n        // Continue with code changes processing despite message error\n      }\n    }\n\n    // 5. Process code changes if any\n    if (codeChanges.length > 0) {\n      logMessage(\"INFO\", `Processing ${codeChanges.length} code changes`);\n      try {\n        const processedChanges = await processCodeChanges(\n          conversationId,\n          codeChanges\n        );\n\n        // Update tracking variables with results from code changes\n        if (processedChanges.focusChanged) {\n          logMessage(\"INFO\", `Focus changed due to code changes`, {\n            newFocus: processedChanges.newFocus,\n          });\n\n          // Code changes can also affect focus and sometimes intent\n          if (trackIntentTransitions && !intentTransition) {\n            try {\n              // Only update if we haven't already detected a transition from messages\n              const intentResult = await IntentPredictorLogic.updateIntent({\n                conversationId,\n                codeChanges,\n              });\n\n              if (intentResult.intentChanged) {\n                intentTransition = true;\n                currentIntent = intentResult.newIntent;\n                logMessage(\"INFO\", `Intent changed due to code changes`, {\n                  newIntent: currentIntent,\n                });\n              }\n            } catch (intentErr) {\n              logMessage(\"WARN\", `Failed to update intent from code changes`, {\n                error: intentErr.message,\n              });\n              // Continue without updating intent\n            }\n          }\n        }\n      } catch (err) {\n        logMessage(\"ERROR\", `Failed to process code changes`, {\n          error: err.message,\n          conversationId,\n        });\n        // Continue with context management despite code change error\n      }\n    }\n\n    // 6. Manage context continuity based on topic shifts and transitions\n    if (topicShift || intentTransition) {\n      logMessage(\n        \"INFO\",\n        `Topic shift or intent transition detected, managing context continuity`,\n        {\n          topicShift,\n          intentTransition,\n          preserveContextOnTopicShift,\n        }\n      );\n\n      // Determine if and how to preserve context\n      if (!preserveContextOnTopicShift) {\n        try {\n          // Clear previous context if preservation not requested\n          await ActiveContextManager.clearActiveContext();\n          contextPreserved = false;\n          logMessage(\"INFO\", `Cleared previous context due to topic shift`);\n\n          // Initialize fresh context for new topic/intent\n          if (currentIntent) {\n            try {\n              const recentEvents =\n                await TimelineManagerLogic.getRecentEventsForConversation(\n                  conversationId,\n                  10\n                );\n\n              const focusResult = await IntentPredictorLogic.predictFocusArea(\n                recentEvents,\n                codeChanges\n              );\n\n              if (focusResult) {\n                await ActiveContextManager.setActiveFocus(\n                  focusResult.type,\n                  focusResult.identifier\n                );\n                currentFocus = focusResult;\n                logMessage(\"INFO\", `Set new focus area based on intent`, {\n                  type: focusResult.type,\n                  identifier: focusResult.identifier,\n                });\n              }\n            } catch (focusErr) {\n              logMessage(\"WARN\", `Failed to set new focus area`, {\n                error: focusErr.message,\n              });\n              // Continue without setting focus\n            }\n          }\n        } catch (clearErr) {\n          logMessage(\"ERROR\", `Failed to clear context`, {\n            error: clearErr.message,\n          });\n          // Continue with next steps despite error\n        }\n      } else {\n        try {\n          // Integrate previous and new context\n          const previousContextState =\n            (await ActiveContextManager.getActiveContextState()) || {};\n\n          const integratedContext = await _integrateContexts(\n            previousContextState,\n            {\n              topicShift,\n              intentTransition,\n              previousIntent,\n              currentIntent,\n              codeChanges,\n            },\n            contextIntegrationLevel\n          );\n\n          await ActiveContextManager.updateActiveContext(integratedContext);\n          contextPreserved = true;\n          logMessage(\"INFO\", `Integrated previous and new context`, {\n            contextIntegrationLevel,\n          });\n        } catch (integrateErr) {\n          logMessage(\"ERROR\", `Failed to integrate contexts`, {\n            error: integrateErr.message,\n          });\n          // Continue with next steps despite error\n        }\n      }\n    } else {\n      logMessage(\n        \"DEBUG\",\n        `No topic shift or intent transition detected, preserving context`\n      );\n    }\n\n    // 7. Get final focus and context state\n    if (!currentFocus) {\n      try {\n        currentFocus = await ActiveContextManager.getActiveFocus();\n        logMessage(\"DEBUG\", `Retrieved current focus`, {\n          focus: currentFocus\n            ? `${currentFocus.type}:${currentFocus.identifier}`\n            : \"none\",\n        });\n      } catch (focusErr) {\n        logMessage(\"WARN\", `Failed to get current focus`, {\n          error: focusErr.message,\n        });\n        // Continue without focus\n      }\n    }\n\n    // 8. Generate context synthesis\n    let contextSynthesis;\n    try {\n      contextSynthesis = await generateContextSynthesis(\n        conversationId,\n        currentIntent,\n        topicShift || intentTransition\n      );\n      logMessage(\"DEBUG\", `Generated context synthesis`, {\n        synthesisLength: contextSynthesis?.length || 0,\n      });\n    } catch (synthesisErr) {\n      logMessage(\"WARN\", `Failed to generate context synthesis`, {\n        error: synthesisErr.message,\n      });\n      contextSynthesis = null;\n    }\n\n    // 9. Update timeline with context update event\n    try {\n      await TimelineManagerLogic.recordEvent(\n        \"context_updated\",\n        {\n          newMessagesCount: newMessages.length,\n          codeChangesCount: codeChanges.length,\n          topicShift,\n          intentTransition: intentTransition\n            ? {\n                from: previousIntent,\n                to: currentIntent,\n              }\n            : null,\n          contextPreserved,\n          contextIntegrationLevel: contextPreserved\n            ? contextIntegrationLevel\n            : \"none\",\n        },\n        [], // No specific entity IDs\n        conversationId\n      );\n      logMessage(\"DEBUG\", `Recorded context update in timeline`);\n    } catch (timelineErr) {\n      logMessage(\"WARN\", `Failed to record context update in timeline`, {\n        error: timelineErr.message,\n      });\n      // Non-critical error, continue\n    }\n\n    // 10. Return the tool response\n    logMessage(\n      \"INFO\",\n      `update_conversation_context tool completed successfully`\n    );\n\n    const responseData = {\n      status: \"success\",\n      message: `Conversation context updated for ${conversationId}`,\n      updatedFocus: currentFocus\n        ? {\n            type: currentFocus.type,\n            identifier: currentFocus.identifier,\n          }\n        : undefined,\n      contextContinuity: {\n        topicShift,\n        intentTransition,\n        contextPreserved,\n      },\n      synthesis: contextSynthesis,\n    };\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify(responseData),\n        },\n      ],\n    };\n  } catch (error) {\n    // Log detailed error information\n    logMessage(\"ERROR\", `Error in update_conversation_context tool`, {\n      error: error.message,\n      stack: error.stack,\n      input: {\n        conversationId: input.conversationId,\n        messageCount: input.newMessages?.length || 0,\n        codeChangeCount: input.codeChanges?.length || 0,\n      },\n    });\n\n    // Return error response\n    const errorResponse = {\n      error: true,\n      errorCode: error.code || \"UPDATE_FAILED\",\n      errorDetails: error.message,\n    };\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify(errorResponse),\n        },\n      ],\n    };\n  }\n}\n\n/**\n * Process new messages and detect topic shifts or intent transitions\n *\n * @param {string} conversationId - Conversation ID\n * @param {Array} messages - New messages to process\n * @param {object} options - Processing options\n * @returns {Promise<object>} Processing results\n */\nasync function processNewMessages(conversationId, messages, options = {}) {\n  try {\n    logMessage(\n      \"DEBUG\",\n      `Processing ${messages.length} messages for conversation ${conversationId}`\n    );\n\n    const result = {\n      topicShift: false,\n      intentTransition: false,\n      currentIntent: null,\n    };\n\n    // Get the current active purpose if tracking transitions\n    let previousIntent = null;\n    if (options.trackIntentTransitions) {\n      try {\n        previousIntent = await ConversationPurposeDetector.getActivePurpose(\n          conversationId\n        );\n        logMessage(\"DEBUG\", \"Retrieved previous intent\", { previousIntent });\n      } catch (error) {\n        logMessage(\"WARN\", \"Failed to retrieve previous intent\", {\n          error: error.message,\n        });\n      }\n    }\n\n    // Process each message\n    for (const message of messages) {\n      try {\n        let isTopicShift = false;\n        let activeTopicId = null;\n\n        // Only check for topic shifts on user messages\n        if (message.role === \"user\") {\n          // Check for topic shift\n          logMessage(\"DEBUG\", \"Checking for topic shift with user message\");\n          isTopicShift = await ConversationIntelligence.detectTopicShift(\n            message.content,\n            conversationId\n          );\n\n          if (isTopicShift) {\n            logMessage(\"INFO\", `Topic shift detected`, {\n              messageContent:\n                message.content.substring(0, 50) +\n                (message.content.length > 50 ? \"...\" : \"\"),\n            });\n            result.topicShift = true;\n          }\n        }\n\n        // Record the message first without a topic segment ID\n        // We'll update this after creating a new topic if needed\n        logMessage(\"DEBUG\", `Recording message from ${message.role}`);\n        const recordedMessageId = await ConversationIntelligence.recordMessage(\n          message.content,\n          message.role,\n          conversationId,\n          [], // relatedContextEntityIds\n          null, // topicSegmentId - will be updated later if needed\n          options.trackIntentTransitions && result.currentIntent\n            ? result.currentIntent.purposeType\n            : null\n        );\n\n        logMessage(\"DEBUG\", `Message recorded with ID: ${recordedMessageId}`);\n\n        // Handle topic shift if detected\n        if (message.role === \"user\" && isTopicShift) {\n          // First, close any currently active topic segment\n          try {\n            const activeTopic =\n              await ConversationSegmenter.getActiveTopicForConversation(\n                conversationId\n              );\n\n            if (activeTopic) {\n              logMessage(\"INFO\", \"Closing active topic segment\", {\n                topicId: activeTopic.topic_id,\n              });\n\n              await ConversationSegmenter.closeTopicSegment(\n                activeTopic.topic_id,\n                recordedMessageId\n              );\n            }\n          } catch (closeError) {\n            logMessage(\"WARN\", \"Failed to close active topic segment\", {\n              error: closeError.message,\n            });\n          }\n\n          // Generate a topic name\n          let topicName = \"\";\n          try {\n            topicName = await ConversationSegmenter.generateTopicName([\n              recordedMessageId,\n            ]);\n          } catch (nameError) {\n            topicName = `Topic from: ${message.content.substring(0, 30)}...`;\n            logMessage(\n              \"WARN\",\n              \"Failed to generate topic name, using fallback\",\n              {\n                error: nameError.message,\n              }\n            );\n          }\n\n          // Create a new topic segment with the recorded message ID\n          try {\n            logMessage(\"INFO\", \"Creating new topic segment\");\n            const newTopicId =\n              await ConversationSegmenter.createNewTopicSegment(\n                conversationId,\n                recordedMessageId, // Use the actual message ID\n                {\n                  name: topicName,\n                  description: message.content,\n                }\n              );\n\n            logMessage(\"INFO\", `Created new topic segment`, {\n              topicId: newTopicId,\n            });\n\n            // Update the message with the new topic ID\n            // This requires a database update since we've already recorded the message\n            try {\n              const updateQuery = `\n                UPDATE conversation_history\n                SET topic_segment_id = ?\n                WHERE message_id = ?\n              `;\n\n              await executeQuery(updateQuery, [newTopicId, recordedMessageId]);\n              logMessage(\"DEBUG\", \"Updated message with new topic ID\", {\n                messageId: recordedMessageId,\n                topicId: newTopicId,\n              });\n\n              // Use this topic ID for tracking\n              activeTopicId = newTopicId;\n            } catch (updateError) {\n              logMessage(\"ERROR\", \"Failed to update message with topic ID\", {\n                error: updateError.message,\n              });\n            }\n          } catch (topicError) {\n            logMessage(\"ERROR\", \"Failed to create new topic segment\", {\n              error: topicError.message,\n            });\n          }\n        } else if (message.role === \"user\" && !isTopicShift) {\n          // If no topic shift, associate with current active topic if any\n          try {\n            const activeTopic =\n              await ConversationSegmenter.getActiveTopicForConversation(\n                conversationId\n              );\n\n            if (activeTopic) {\n              const updateQuery = `\n                UPDATE conversation_history\n                SET topic_segment_id = ?\n                WHERE message_id = ?\n              `;\n\n              await executeQuery(updateQuery, [\n                activeTopic.topic_id,\n                recordedMessageId,\n              ]);\n              logMessage(\"DEBUG\", \"Updated message with existing topic ID\", {\n                messageId: recordedMessageId,\n                topicId: activeTopic.topic_id,\n              });\n\n              activeTopicId = activeTopic.topic_id;\n            }\n          } catch (error) {\n            logMessage(\n              \"WARN\",\n              \"Failed to associate message with active topic\",\n              {\n                error: error.message,\n              }\n            );\n          }\n        }\n\n        // Detect conversation purpose for each user message\n        if (message.role === \"user\" && options.trackIntentTransitions) {\n          try {\n            // Get recent conversation history for context\n            const recentHistory =\n              await ConversationIntelligence.getConversationHistory(\n                conversationId,\n                10\n              );\n\n            // Detect purpose based on message and conversation history\n            const purposeResult =\n              await ConversationPurposeDetector.detectConversationPurpose(\n                message.content,\n                recentHistory\n              );\n\n            if (purposeResult) {\n              const newPurpose = purposeResult.purpose;\n              const currentPurpose = previousIntent\n                ? previousIntent.purposeType\n                : null;\n\n              // Check if purpose has changed\n              if (newPurpose !== currentPurpose) {\n                logMessage(\"INFO\", \"Conversation purpose change detected\", {\n                  from: currentPurpose,\n                  to: newPurpose,\n                });\n\n                // Track the purpose transition\n                await ConversationPurposeDetector.trackPurposeTransition(\n                  conversationId,\n                  currentPurpose,\n                  newPurpose,\n                  recordedMessageId\n                );\n\n                // Update result for the handler function\n                result.intentTransition = true;\n                result.currentIntent = {\n                  purposeType: newPurpose,\n                  confidence: purposeResult.confidence,\n                };\n\n                // Update previous intent for next iteration\n                previousIntent = {\n                  purposeType: newPurpose,\n                  confidence: purposeResult.confidence,\n                };\n              }\n            }\n          } catch (purposeError) {\n            logMessage(\"WARN\", \"Failed to detect conversation purpose\", {\n              error: purposeError.message,\n            });\n          }\n        }\n\n        // Update intent with the new message\n        if (options.trackIntentTransitions) {\n          try {\n            const intentUpdateResult = await IntentPredictorLogic.updateIntent({\n              conversationId,\n              messages: [message],\n              messageId: recordedMessageId,\n            });\n\n            // Check if intent has been updated during processing\n            if (intentUpdateResult.intentChanged && !result.intentTransition) {\n              result.intentTransition = true;\n              result.currentIntent = intentUpdateResult.newIntent;\n\n              logMessage(\"INFO\", \"Intent updated based on message content\", {\n                intent: intentUpdateResult.newIntent,\n              });\n            }\n          } catch (intentError) {\n            logMessage(\"WARN\", \"Failed to update intent\", {\n              error: intentError.message,\n            });\n          }\n        }\n      } catch (msgError) {\n        logMessage(\"ERROR\", `Failed to process message`, {\n          error: msgError.message,\n          role: message.role,\n          content: message.content?.substring(0, 50) + \"...\",\n        });\n      }\n    }\n\n    return result;\n  } catch (error) {\n    logMessage(\"ERROR\", `Error processing new messages`, {\n      error: error.message,\n      conversationId,\n    });\n    throw error; // Re-throw to be caught by the main handler\n  }\n}\n\n/**\n * Process code changes and update related context\n *\n * @param {string} conversationId - Conversation ID\n * @param {Array} codeChanges - Array of code changes\n * @returns {Promise<object>} Processing results\n */\nasync function processCodeChanges(conversationId, codeChanges) {\n  try {\n    logMessage(\n      \"DEBUG\",\n      `Processing ${codeChanges.length} code changes for conversation ${conversationId}`\n    );\n\n    const result = {\n      focusChanged: false,\n      newFocus: null,\n    };\n\n    // If there are no code changes, return early\n    if (!codeChanges || !codeChanges.length) {\n      return result;\n    }\n\n    // Process code changes in parallel using Promise.allSettled for better error handling\n    // This will never reject, ensuring we always get results even if some changes fail\n    const processingPromises = codeChanges.map((change) => {\n      // Ensure filePath exists before processing\n      if (!change || !change.filePath) {\n        logMessage(\"WARN\", \"Received invalid code change object, skipping\", {\n          change: JSON.stringify(change).substring(0, 100) + \"...\",\n        });\n        return Promise.resolve({\n          success: false,\n          filePath: change?.filePath || \"unknown\",\n          error: \"Invalid code change: missing filePath\",\n        });\n      }\n\n      return KnowledgeProcessor.processCodeChange(change)\n        .then((result) => {\n          if (result.success) {\n            logMessage(\"DEBUG\", `Processed code change for ${change.filePath}`);\n          } else {\n            logMessage(\"WARN\", `Failed to process code change`, {\n              error: result.error || \"Unknown error\",\n              path: change.filePath,\n            });\n          }\n          return result;\n        })\n        .catch((processErr) => {\n          // Extra safety - should never reach here as processCodeChange now handles errors\n          logMessage(\"WARN\", `Unexpected error processing code change`, {\n            error: processErr.message,\n            path: change.filePath,\n          });\n          return {\n            success: false,\n            filePath: change.filePath,\n            error: processErr.message,\n          };\n        });\n    });\n\n    // Wait for all code changes to be processed\n    const processingResults = await Promise.allSettled(processingPromises);\n\n    // Extract the actual results and handle any rejected promises (should be none)\n    const processedResults = processingResults.map((promiseResult) => {\n      if (promiseResult.status === \"fulfilled\") {\n        return promiseResult.value;\n      } else {\n        // This shouldn't happen but handle it anyway\n        logMessage(\"ERROR\", \"Promise rejected during code change processing\", {\n          reason: promiseResult.reason?.message || \"Unknown error\",\n        });\n        return {\n          success: false,\n          error: promiseResult.reason?.message || \"Unknown error\",\n        };\n      }\n    });\n\n    // Log a summary of the results\n    const successCount = processedResults.filter((r) => r.success).length;\n    const failureCount = processedResults.filter((r) => !r.success).length;\n\n    if (failureCount > 0) {\n      logMessage(\n        \"WARN\",\n        `${failureCount} of ${codeChanges.length} code changes failed processing`\n      );\n    } else {\n      logMessage(\n        \"INFO\",\n        `Successfully processed all ${codeChanges.length} code changes`\n      );\n    }\n\n    // Calculate new focus area based on code changes\n    try {\n      if (successCount > 0) {\n        const mostSignificantChange = codeChanges.reduce((prev, current) => {\n          // Simple heuristic: more changed lines = more significant\n          const prevChangedLines = prev.changedLines?.length || 0;\n          const currentChangedLines = current.changedLines?.length || 0;\n          return currentChangedLines > prevChangedLines ? current : prev;\n        }, codeChanges[0]);\n\n        // If we have a significant change, set it as the focus\n        if (mostSignificantChange) {\n          const newFocus = {\n            focus_type: \"file\",\n            identifier: mostSignificantChange.filePath,\n            description: `File ${mostSignificantChange.filePath} was modified`,\n          };\n\n          try {\n            // Update focus area\n            await FocusAreaManagerLogic.setFocusArea(newFocus);\n            result.focusChanged = true;\n            result.newFocus = newFocus;\n          } catch (focusError) {\n            logMessage(\"WARN\", \"Failed to update focus area\", {\n              error: focusError.message,\n            });\n            // Continue without updating focus\n          }\n        }\n      }\n    } catch (focusError) {\n      // Ignore focus calculation errors\n      logMessage(\"WARN\", \"Error calculating focus area from code changes\", {\n        error: focusError.message,\n      });\n    }\n\n    return result;\n  } catch (error) {\n    logMessage(\"ERROR\", `Failed to process code changes`, {\n      error: error.message,\n      conversationId,\n    });\n\n    // Return a default result instead of throwing\n    return {\n      focusChanged: false,\n      newFocus: null,\n      error: error.message,\n    };\n  }\n}\n\n/**\n * Integrates previous and new context states\n *\n * @param {Object} previousContextState - Previous context state\n * @param {Object} changes - Change indicators (topic shift, intent transition, etc.)\n * @param {string} integrationLevel - How aggressively to integrate contexts\n * @returns {Promise<Object>} Integrated context\n */\nasync function _integrateContexts(\n  previousContextState,\n  changes,\n  integrationLevel\n) {\n  const {\n    topicShift,\n    intentTransition,\n    previousIntent,\n    currentIntent,\n    codeChanges,\n  } = changes;\n\n  try {\n    logMessage(\"INFO\", `Integrating contexts with level: ${integrationLevel}`);\n\n    // Start with a copy of the previous context\n    const integratedContext = { ...previousContextState };\n\n    // Determine how much to preserve based on integration level\n    switch (integrationLevel) {\n      case \"minimal\":\n        // For minimal integration, only keep core focus and clear most context\n        if (topicShift) {\n          // Clear most context but keep current focus\n          const currentFocus = integratedContext.focus;\n          integratedContext.recentContextItems = [];\n          integratedContext.focus = currentFocus;\n        }\n        break;\n\n      case \"aggressive\":\n        // For aggressive integration, preserve all context even with transitions\n        // Just update the intent/purpose information\n        if (intentTransition) {\n          integratedContext.currentIntent = currentIntent;\n        }\n        break;\n\n      case \"balanced\":\n      default:\n        // For balanced integration, preserve relevant context\n        if (topicShift) {\n          // Reduce context items but keep those relevant to current focus\n          const currentFocus = integratedContext.focus;\n\n          // Keep items that are still relevant to current focus or code changes\n          if (integratedContext.recentContextItems) {\n            const changedFilePaths = codeChanges.map(\n              (change) => change.filePath\n            );\n\n            integratedContext.recentContextItems =\n              integratedContext.recentContextItems.filter((item) => {\n                // Keep items related to current focus\n                if (\n                  item.relatedTo &&\n                  item.relatedTo.includes(currentFocus?.identifier)\n                ) {\n                  return true;\n                }\n\n                // Keep items related to changed files\n                if (\n                  item.path &&\n                  changedFilePaths.some((path) => item.path.includes(path))\n                ) {\n                  return true;\n                }\n\n                // Keep very recent items\n                if (\n                  item.timestamp &&\n                  Date.now() - item.timestamp < 5 * 60 * 1000\n                ) {\n                  // 5 minutes\n                  return true;\n                }\n\n                return false;\n              });\n          }\n        }\n\n        // Always update intent information\n        if (intentTransition) {\n          integratedContext.currentIntent = currentIntent;\n\n          // If we have code changes, adjust priorities based on new intent\n          if (codeChanges.length > 0 && integratedContext.recentContextItems) {\n            // Re-prioritize based on new intent\n            integratedContext.recentContextItems.forEach((item) => {\n              if (item.contentType === \"code\" && currentIntent) {\n                // Adjust priority based on relevance to new intent\n                if (\n                  currentIntent === \"debugging\" &&\n                  item.path &&\n                  item.path.includes(\"test\")\n                ) {\n                  item.priority = Math.min(item.priority + 0.2, 1.0);\n                } else if (\n                  currentIntent === \"feature_planning\" &&\n                  item.path &&\n                  item.path.includes(\"docs\")\n                ) {\n                  item.priority = Math.min(item.priority + 0.2, 1.0);\n                }\n                // Add more intent-specific priority adjustments as needed\n              }\n            });\n\n            // Sort by adjusted priority\n            integratedContext.recentContextItems.sort(\n              (a, b) => b.priority - a.priority\n            );\n          }\n        }\n        break;\n    }\n\n    return integratedContext;\n  } catch (error) {\n    logMessage(\"ERROR\", `Error integrating contexts`, {\n      error: error.message,\n    });\n    // Fall back to previous context in case of error\n    return previousContextState;\n  }\n}\n\n/**\n * Generates a synthesis of the current context\n *\n * @param {string} conversationId - Conversation ID\n * @param {string} currentIntent - Current conversation intent\n * @param {boolean} contextChanged - Whether context has significantly changed\n * @returns {Promise<Object>} Context synthesis\n */\nasync function generateContextSynthesis(\n  conversationId,\n  currentIntent,\n  contextChanged\n) {\n  try {\n    logMessage(\"INFO\", `Generating context synthesis`);\n\n    // Get active context information\n    const activeContext = await ActiveContextManager.getActiveContextState();\n    const activeFocus = await ActiveContextManager.getActiveFocus();\n\n    // Get recent messages for context\n    const recentMessages = await ConversationIntelligence.getRecentMessages(\n      conversationId,\n      5\n    );\n\n    // Generate a summary appropriate to the current state\n    let summaryText = \"Current conversation context\";\n\n    if (contextChanged) {\n      // More detailed summary for changed context\n      if (activeFocus) {\n        summaryText = `The conversation is now focused on ${activeFocus.type} \"${activeFocus.identifier}\"`;\n\n        if (currentIntent) {\n          const intentStr =\n            typeof currentIntent === \"string\"\n              ? currentIntent.replace(/_/g, \" \")\n              : currentIntent;\n          summaryText += ` with the purpose of ${intentStr}`;\n        }\n      } else if (currentIntent) {\n        const intentStr =\n          typeof currentIntent === \"string\"\n            ? currentIntent.replace(/_/g, \" \")\n            : currentIntent;\n        summaryText = `The conversation is focused on ${intentStr}`;\n      }\n\n      // Add recent message summary if available\n      if (recentMessages.length > 0) {\n        const messageContent = recentMessages\n          .map((msg) => msg.content)\n          .join(\" \");\n        const messageSummary = await ContextCompressorLogic.summarizeText(\n          messageContent,\n          { targetLength: 150 }\n        );\n\n        summaryText += `. Recent discussion: ${messageSummary}`;\n      }\n    } else {\n      // Simpler summary for continued context\n      if (activeFocus) {\n        summaryText = `Continuing focus on ${activeFocus.type} \"${activeFocus.identifier}\"`;\n\n        if (currentIntent) {\n          const intentStr =\n            typeof currentIntent === \"string\"\n              ? currentIntent.replace(/_/g, \" \")\n              : currentIntent;\n          summaryText += ` with ${intentStr}`;\n        }\n      } else if (currentIntent) {\n        const intentStr =\n          typeof currentIntent === \"string\"\n            ? currentIntent.replace(/_/g, \" \")\n            : currentIntent;\n        summaryText = `Continuing with ${intentStr}`;\n      }\n    }\n\n    // Identify top priorities based on current context\n    const topPriorities = [];\n\n    if (activeFocus) {\n      topPriorities.push(\n        `Focus on ${activeFocus.type}: ${activeFocus.identifier}`\n      );\n    }\n\n    if (currentIntent) {\n      switch (currentIntent) {\n        case \"debugging\":\n          topPriorities.push(\"Identify and fix issues in the code\");\n          break;\n        case \"feature_planning\":\n          topPriorities.push(\"Design and plan new features\");\n          break;\n        case \"code_review\":\n          topPriorities.push(\"Review code for quality and correctness\");\n          break;\n        case \"learning\":\n          topPriorities.push(\"Explain concepts and provide information\");\n          break;\n        case \"code_generation\":\n          topPriorities.push(\"Generate or modify code\");\n          break;\n        default:\n          topPriorities.push(\"Address user's current needs\");\n      }\n    }\n\n    // Include active context items as priorities if available\n    if (activeContext && activeContext.recentContextItems) {\n      const priorityItems = activeContext.recentContextItems\n        .slice(0, 2)\n        .map((item) => {\n          if (item.type === \"file\") {\n            return `Maintain context on file: ${item.name || item.path}`;\n          } else if (item.type === \"entity\") {\n            return `Keep focus on: ${item.name}`;\n          }\n          return null;\n        })\n        .filter(Boolean);\n\n      topPriorities.push(...priorityItems);\n    }\n\n    return {\n      summary: summaryText,\n      topPriorities: topPriorities.length > 0 ? topPriorities : undefined,\n    };\n  } catch (error) {\n    logMessage(\"ERROR\", `Error generating context synthesis`, {\n      error: error.message,\n    });\n    // Return minimal synthesis in case of error\n    return {\n      summary: \"Context updated\",\n    };\n  }\n}\n\n// Export the tool definition for server registration\nexport default {\n  name: \"update_conversation_context\",\n  description:\n    \"Updates an existing conversation context with new messages, code changes, and context management\",\n  inputSchema: updateConversationContextInputSchema,\n  outputSchema: updateConversationContextOutputSchema,\n  handler,\n};\n", "/**\n * KnowledgeProcessor.js\n *\n * Processes and analyzes code changes in the codebase.\n * Orchestrates the indexing and knowledge extraction from changed files.\n */\n\nimport * as ContextIndexerLogic from \"./ContextIndexerLogic.js\";\nimport { executeQuery } from \"../db.js\";\n\n/**\n * @typedef {Object} CodeEntity\n * @property {string} id - Unique identifier for the code entity\n * @property {string} path - File path of the code entity\n * @property {string} type - Type of code entity ('file', 'function', 'class', etc.)\n * @property {string} name - Name of the code entity\n * @property {string} content - Content of the code entity\n * @property {string} symbol_path - Full symbol path of the entity\n * @property {number} version - Version number of the entity\n * @property {string} parent_id - ID of the parent entity, if any\n * @property {string} created_at - Timestamp when entity was created\n * @property {string} updated_at - Timestamp when entity was last updated\n */\n\n/**\n * Process a single code change\n *\n * @param {Object} change - Object containing file change information\n * @param {string} change.filePath - Path to the changed file\n * @param {string} change.newContent - New content of the file\n * @param {string} [change.languageHint] - Optional language hint for the file\n * @returns {Promise<Object>} Result of processing the code change\n */\nexport async function processCodeChange(change) {\n  const inMcpMode = process.env.MCP_MODE === \"true\";\n\n  if (!change || !change.filePath || !change.newContent) {\n    if (!inMcpMode) console.error(\"Invalid code change object:\", change);\n    return {\n      filePath: change?.filePath || \"unknown\",\n      success: false,\n      error: \"Invalid code change: missing required fields\",\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  try {\n    if (!inMcpMode)\n      console.log(`Processing code change for ${change.filePath}`);\n\n    // Calculate content hash for quick comparison\n    let contentHash;\n    try {\n      const crypto = await import(\"crypto\");\n      // Use SHA-256 consistent with ContextIndexerLogic.js\n      contentHash = crypto\n        .createHash(\"sha256\")\n        .update(change.newContent)\n        .digest(\"hex\");\n    } catch (hashError) {\n      // If hash calculation fails, just continue with a default hash\n      contentHash = \"unknown-hash-\" + Date.now();\n    }\n\n    // Check if file exists and has the same content hash\n    let skipProcessing = false;\n    try {\n      const existingFileQuery = `\n        SELECT entity_id, content_hash \n        FROM code_entities \n        WHERE file_path = ? AND entity_type = 'file'\n      `;\n\n      const existingFile = await executeQuery(existingFileQuery, [\n        change.filePath,\n      ]);\n\n      // If file exists and content hash matches, skip processing\n      if (\n        existingFile &&\n        existingFile.rows &&\n        existingFile.rows.length > 0 &&\n        existingFile.rows[0].content_hash === contentHash\n      ) {\n        if (!inMcpMode)\n          console.log(\n            `File ${change.filePath} is unchanged, skipping indexing`\n          );\n        skipProcessing = true;\n      }\n    } catch (dbError) {\n      // Just log the error and continue with indexing\n      if (!inMcpMode)\n        console.warn(\n          `DB check error for ${change.filePath}, proceeding with indexing: ${dbError.message}`\n        );\n    }\n\n    let entities = [];\n\n    // Only do the indexing if we need to (file changed or doesn't exist)\n    if (!skipProcessing) {\n      try {\n        // Index the updated file\n        await ContextIndexerLogic.indexCodeFile(\n          change.filePath,\n          change.newContent,\n          change.languageHint\n        );\n      } catch (indexError) {\n        // If indexing fails, log error but continue\n        if (!inMcpMode)\n          console.error(\n            `Error indexing file ${change.filePath}: ${indexError.message}`\n          );\n        return {\n          filePath: change.filePath,\n          success: false,\n          error: `Indexing failed: ${indexError.message}`,\n          timestamp: new Date().toISOString(),\n        };\n      }\n    }\n\n    // Try to get entities even if indexing failed - they might already exist\n    try {\n      // Get the entities associated with this file\n      entities = await getEntitiesFromChangedFiles([change.filePath]);\n    } catch (entitiesError) {\n      // If getting entities fails, just return an empty array\n      if (!inMcpMode)\n        console.warn(\n          `Error getting entities for ${change.filePath}: ${entitiesError.message}`\n        );\n      entities = [];\n    }\n\n    return {\n      filePath: change.filePath,\n      success: true,\n      entityCount: entities.length,\n      unchanged: skipProcessing,\n      timestamp: new Date().toISOString(),\n    };\n  } catch (error) {\n    if (!inMcpMode)\n      console.error(\n        `Error processing code change for ${change.filePath}:`,\n        error\n      );\n\n    // Return error info but don't throw\n    return {\n      filePath: change.filePath,\n      success: false,\n      error: `Failed to process code change: ${error.message}`,\n      timestamp: new Date().toISOString(),\n    };\n  }\n}\n\n/**\n * Process changes to multiple files in the codebase\n *\n * @param {Array<{filePath: string, newContent: string, languageHint: string}>} changedFiles - Array of changed files with their content and language\n * @returns {Promise<void>}\n */\nexport async function processCodebaseChanges(changedFiles) {\n  if (!changedFiles || changedFiles.length === 0) {\n    console.log(\"No files to process\");\n    return;\n  }\n\n  console.log(`Processing ${changedFiles.length} changed files...`);\n\n  try {\n    // Process each file in parallel using Promise.all\n    // Each file gets its own try/catch to prevent one failure from stopping the entire process\n    const processingPromises = changedFiles.map(async (file) => {\n      try {\n        await ContextIndexerLogic.indexCodeFile(\n          file.filePath,\n          file.newContent,\n          file.languageHint\n        );\n        return { filePath: file.filePath, success: true };\n      } catch (error) {\n        console.error(`Error processing file ${file.filePath}:`, error);\n        return {\n          filePath: file.filePath,\n          success: false,\n          error: error.message,\n        };\n      }\n    });\n\n    // Wait for all processing to complete\n    const results = await Promise.all(processingPromises);\n\n    // Count successes and failures\n    const successCount = results.filter((r) => r.success).length;\n    const failureCount = results.filter((r) => !r.success).length;\n\n    console.log(\n      `Completed processing ${changedFiles.length} files. Success: ${successCount}, Failures: ${failureCount}`\n    );\n\n    // If there were any failures, log them in detail\n    if (failureCount > 0) {\n      const failures = results.filter((r) => !r.success);\n      console.error(\n        \"Failed files:\",\n        failures.map((f) => f.filePath).join(\", \")\n      );\n    }\n  } catch (error) {\n    console.error(\"Error during codebase change processing:\", error);\n    throw error; // Rethrow to allow caller to handle the error\n  }\n}\n\n/**\n * Retrieves all code entities related to the provided file paths\n *\n * @param {string[]} filePaths - Array of file paths that have changed\n * @returns {Promise<CodeEntity[]>} Array of code entities related to the changed files\n */\nexport async function getEntitiesFromChangedFiles(filePaths) {\n  const inMcpMode = process.env.MCP_MODE === \"true\";\n\n  if (!filePaths || filePaths.length === 0) {\n    return [];\n  }\n\n  try {\n    // Process files one at a time to avoid complex query errors\n    let allEntities = [];\n    let processedPaths = new Set();\n\n    for (const filePath of filePaths) {\n      if (processedPaths.has(filePath)) continue;\n      processedPaths.add(filePath);\n\n      try {\n        // Get entities directly matching this file path\n        const fileQuery = `SELECT * FROM code_entities WHERE file_path = ?`;\n        const fileEntities = await executeQuery(fileQuery, [filePath]);\n\n        if (!fileEntities || !fileEntities.rows) continue;\n\n        // Add the file entities to our result\n        const entities = [...fileEntities.rows];\n\n        // Get file entity IDs to query for children\n        const fileEntityIds = entities\n          .filter((entity) => entity.entity_type === \"file\")\n          .map((entity) => entity.entity_id);\n\n        // If we have file entities, get their children\n        if (fileEntityIds.length > 0) {\n          for (const entityId of fileEntityIds) {\n            try {\n              const childQuery = `\n                SELECT * FROM code_entities \n                WHERE parent_entity_id = ?\n              `;\n              const childEntities = await executeQuery(childQuery, [entityId]);\n\n              if (childEntities && childEntities.rows) {\n                // Add child entities if not already present\n                for (const child of childEntities.rows) {\n                  // Check if entity is already in our results\n                  if (!entities.some((e) => e.entity_id === child.entity_id)) {\n                    entities.push(child);\n                  }\n                }\n              }\n            } catch (childErr) {\n              if (!inMcpMode) {\n                console.warn(\n                  `Error fetching children for entity ${entityId}: ${childErr.message}`\n                );\n              }\n              // Continue with next entityId\n            }\n          }\n        }\n\n        // Add all entities from this file to our result set\n        allEntities = [...allEntities, ...entities];\n      } catch (fileErr) {\n        if (!inMcpMode) {\n          console.warn(`Error processing file ${filePath}: ${fileErr.message}`);\n        }\n        // Continue with next file\n      }\n    }\n\n    return allEntities;\n  } catch (error) {\n    if (!inMcpMode) {\n      console.error(\"Error retrieving entities from changed files:\", error);\n    }\n    // Return empty array instead of throwing\n    return [];\n  }\n}\n", "/**\n * retrieveRelevantContext.tool.js\n *\n * MCP tool implementation for retrieving and blending relevant context\n * from multiple sources: code, conversations, documentation, and patterns.\n */\n\nimport { z } from \"zod\";\nimport { executeQuery } from \"../db.js\";\nimport * as ConversationIntelligence from \"../logic/ConversationIntelligence.js\";\nimport * as InsightEngine from \"../logic/InsightEngine.js\";\nimport * as TimelineManagerLogic from \"../logic/TimelineManagerLogic.js\";\nimport * as ActiveContextManager from \"../logic/ActiveContextManager.js\";\nimport * as SmartSearchServiceLogic from \"../logic/SmartSearchServiceLogic.js\";\nimport * as RelationshipContextManagerLogic from \"../logic/RelationshipContextManagerLogic.js\";\nimport * as ConversationSegmenter from \"../logic/ConversationSegmenter.js\";\nimport * as ConversationPurposeDetector from \"../logic/ConversationPurposeDetector.js\";\nimport { DEFAULT_TOKEN_BUDGET } from \"../config.js\";\nimport { logMessage } from \"../utils/logger.js\";\n\nimport {\n  retrieveRelevantContextInputSchema,\n  retrieveRelevantContextOutputSchema,\n} from \"../schemas/toolSchemas.js\";\n\n/**\n * Handler for retrieve_relevant_context tool\n *\n * @param {object} input - Tool input parameters\n * @param {object} sdkContext - SDK context\n * @returns {Promise<object>} Tool output\n */\nasync function handler(input, sdkContext) {\n  try {\n    logMessage(\"INFO\", `retrieve_relevant_context tool started`, {\n      query: input.query?.substring(0, 50),\n      conversationId: input.conversationId,\n      tokenBudget: input.tokenBudget || DEFAULT_TOKEN_BUDGET,\n    });\n\n    // 1. Extract input parameters with defaults\n    const {\n      conversationId,\n      query,\n      tokenBudget = DEFAULT_TOKEN_BUDGET,\n      constraints = {},\n      contextFilters = {},\n      weightingStrategy = \"balanced\",\n      balanceStrategy = \"proportional\",\n      contextBalance = \"auto\",\n      sourceTypePreferences = {},\n    } = input;\n\n    // Validation\n    if (!query) {\n      const error = new Error(\"Query is required\");\n      error.code = \"MISSING_QUERY\";\n      throw error;\n    }\n\n    if (!conversationId) {\n      const error = new Error(\"Conversation ID is required\");\n      error.code = \"MISSING_CONVERSATION_ID\";\n      throw error;\n    }\n\n    logMessage(\"DEBUG\", `Context retrieval parameters`, {\n      balanceStrategy,\n      contextBalance,\n      constraints: Object.keys(constraints),\n      filters: Object.keys(contextFilters),\n    });\n\n    // 2. Fetch conversation history, current topic and purpose\n    let conversationHistory = [];\n    let currentTopic = null;\n    let currentPurpose = null;\n\n    try {\n      conversationHistory =\n        await ConversationIntelligence.getConversationHistory(\n          conversationId,\n          20 // Get last 20 messages\n        );\n\n      logMessage(\"DEBUG\", `Retrieved conversation history`, {\n        messageCount: conversationHistory.length,\n      });\n    } catch (err) {\n      logMessage(\"WARN\", `Failed to retrieve conversation history`, {\n        error: err.message,\n        conversationId,\n      });\n      // Continue with empty history\n    }\n\n    // Simple fallback approach - just return conversation history as context\n    // This bypasses the buggy search functionality for now\n    const simplifiedResult = {\n      relevantContext: [],\n      conversationContext: conversationHistory.map((msg) => ({\n        type: \"conversation\",\n        content: msg.content,\n        metadata: {\n          role: msg.role,\n          messageId: msg.messageId,\n        },\n        relevanceScore: 0.9,\n      })),\n      currentTopic,\n      currentPurpose,\n      statusMessage: \"Retrieved conversation context successfully\",\n      metrics: {\n        totalSnippets: conversationHistory.length,\n        relevanceThreshold: 0.5,\n        tokenUsage: conversationHistory.reduce(\n          (acc, msg) => acc + _estimateTokenCount(msg.content),\n          0\n        ),\n      },\n    };\n\n    logMessage(\n      \"INFO\",\n      `Returning simplified context with ${simplifiedResult.conversationContext.length} conversation messages`\n    );\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify({\n            conversationId: input.conversationId,\n            query: input.query,\n            retrievalTime: Date.now(),\n            relevantContext: {\n              conversationContext: simplifiedResult.conversationContext,\n              codeContext: [],\n              patternContext: [],\n              fileContext: [],\n            },\n            focusInfo: {\n              currentTopic: simplifiedResult.currentTopic,\n              currentPurpose: simplifiedResult.currentPurpose,\n            },\n            queryAnalysis: {\n              status: simplifiedResult.statusMessage,\n              metrics: simplifiedResult.metrics,\n            },\n          }),\n        },\n      ],\n    };\n  } catch (error) {\n    logMessage(\"ERROR\", `Error in retrieve_relevant_context handler`, {\n      error: error.message,\n      code: error.code,\n    });\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify({\n            error: true,\n            errorCode: error.code || \"RETRIEVAL_FAILED\",\n            errorDetails: error.message,\n            conversationId: input.conversationId,\n            query: input.query,\n          }),\n        },\n      ],\n    };\n  }\n}\n\n/**\n * Apply context balance adjustments based on balance type and conversation purpose\n *\n * @param {object} contextSources - Context sources with target percentages\n * @param {string} contextBalance - Context balance strategy\n * @param {string} currentPurpose - Current conversation purpose\n */\nfunction _applyContextBalance(contextSources, contextBalance, currentPurpose) {\n  try {\n    logMessage(\"DEBUG\", `Applying context balance: ${contextBalance}`, {\n      currentPurpose,\n    });\n\n    if (contextBalance === \"auto\") {\n      // Automatic balancing based on purpose\n      if (currentPurpose) {\n        switch (currentPurpose) {\n          case \"code_explanation\":\n          case \"debugging\":\n            // More code when explaining or debugging\n            contextSources.code.targetPercentage = 0.7;\n            contextSources.conversation.targetPercentage = 0.1;\n            contextSources.documentation.targetPercentage = 0.15;\n            contextSources.patterns.targetPercentage = 0.05;\n            logMessage(\"DEBUG\", `Applied 'code_explanation/debugging' balance`);\n            break;\n          case \"implementation\":\n          case \"feature_development\":\n            // Balance between code and patterns when implementing\n            contextSources.code.targetPercentage = 0.6;\n            contextSources.conversation.targetPercentage = 0.1;\n            contextSources.documentation.targetPercentage = 0.1;\n            contextSources.patterns.targetPercentage = 0.2;\n            logMessage(\n              \"DEBUG\",\n              `Applied 'implementation/feature_development' balance`\n            );\n            break;\n          case \"architecture_discussion\":\n          case \"design\":\n            // More documentation and patterns for architecture\n            contextSources.code.targetPercentage = 0.4;\n            contextSources.conversation.targetPercentage = 0.15;\n            contextSources.documentation.targetPercentage = 0.25;\n            contextSources.patterns.targetPercentage = 0.2;\n            logMessage(\n              \"DEBUG\",\n              `Applied 'architecture_discussion/design' balance`\n            );\n            break;\n          case \"requirements_gathering\":\n          case \"clarification\":\n            // More conversation for requirements\n            contextSources.code.targetPercentage = 0.3;\n            contextSources.conversation.targetPercentage = 0.4;\n            contextSources.documentation.targetPercentage = 0.2;\n            contextSources.patterns.targetPercentage = 0.1;\n            logMessage(\n              \"DEBUG\",\n              `Applied 'requirements_gathering/clarification' balance`\n            );\n            break;\n          default:\n            // Default balance preserved\n            logMessage(\n              \"DEBUG\",\n              `No specific balance for purpose '${currentPurpose}', using defaults`\n            );\n            break;\n        }\n      } else {\n        logMessage(\"DEBUG\", `No current purpose, using default balance`);\n      }\n    } else if (contextBalance === \"code_heavy\") {\n      // Code-heavy balance\n      contextSources.code.targetPercentage = 0.8;\n      contextSources.conversation.targetPercentage = 0.1;\n      contextSources.documentation.targetPercentage = 0.05;\n      contextSources.patterns.targetPercentage = 0.05;\n      logMessage(\"DEBUG\", `Applied 'code_heavy' balance`);\n    } else if (contextBalance === \"conversation_focused\") {\n      // Conversation-focused balance\n      contextSources.code.targetPercentage = 0.3;\n      contextSources.conversation.targetPercentage = 0.5;\n      contextSources.documentation.targetPercentage = 0.1;\n      contextSources.patterns.targetPercentage = 0.1;\n      logMessage(\"DEBUG\", `Applied 'conversation_focused' balance`);\n    } else if (contextBalance === \"documentation_focused\") {\n      // Documentation-focused balance\n      contextSources.code.targetPercentage = 0.3;\n      contextSources.conversation.targetPercentage = 0.1;\n      contextSources.documentation.targetPercentage = 0.5;\n      contextSources.patterns.targetPercentage = 0.1;\n      logMessage(\"DEBUG\", `Applied 'documentation_focused' balance`);\n    } else if (contextBalance === \"pattern_focused\") {\n      // Pattern-focused balance\n      contextSources.code.targetPercentage = 0.3;\n      contextSources.conversation.targetPercentage = 0.1;\n      contextSources.documentation.targetPercentage = 0.1;\n      contextSources.patterns.targetPercentage = 0.5;\n      logMessage(\"DEBUG\", `Applied 'pattern_focused' balance`);\n    } else if (contextBalance === \"balanced\") {\n      // Balanced settings - already default\n      logMessage(\"DEBUG\", `Using balanced settings (default)`);\n    } else {\n      // If contextBalance doesn't match known values, log and keep defaults\n      logMessage(\n        \"WARN\",\n        `Unknown context balance type '${contextBalance}', using defaults`\n      );\n    }\n  } catch (error) {\n    logMessage(\"ERROR\", `Error applying context balance`, {\n      error: error.message,\n      contextBalance,\n    });\n    throw error;\n  }\n}\n\n/**\n * Integrate contexts from multiple sources respecting token budget\n *\n * @param {object} contextSources - Context sources with snippets\n * @param {number} tokenBudget - Total token budget\n * @param {string} balanceStrategy - Strategy for balancing context\n * @param {string} query - Original query for relevance calculations\n * @returns {Array} Integrated context snippets\n */\nfunction _integrateContexts(\n  contextSources,\n  tokenBudget,\n  balanceStrategy,\n  query\n) {\n  try {\n    logMessage(\n      \"DEBUG\",\n      `Integrating contexts with strategy: ${balanceStrategy}`\n    );\n\n    let integratedSnippets = [];\n\n    // Apply the selected balance strategy\n    switch (balanceStrategy) {\n      case \"proportional\":\n        integratedSnippets = _applyProportionalStrategy(\n          contextSources,\n          tokenBudget\n        );\n        break;\n      case \"equal_representation\":\n        integratedSnippets = _applyEqualRepresentationStrategy(\n          contextSources,\n          tokenBudget\n        );\n        break;\n      case \"priority_based\":\n        // Collect all snippets and sort by relevance\n        const allSnippets = [\n          ...contextSources.code.snippets,\n          ...contextSources.conversation.snippets,\n          ...contextSources.documentation.snippets,\n          ...contextSources.patterns.snippets,\n        ].sort((a, b) => b.relevanceScore - a.relevanceScore);\n\n        integratedSnippets = _applyPriorityBasedStrategy(\n          allSnippets,\n          tokenBudget\n        );\n        break;\n      default:\n        // Fallback to proportional\n        logMessage(\n          \"WARN\",\n          `Unknown balance strategy '${balanceStrategy}', falling back to proportional`\n        );\n        integratedSnippets = _applyProportionalStrategy(\n          contextSources,\n          tokenBudget\n        );\n    }\n\n    // Log the result\n    const typeBreakdown = {\n      code: integratedSnippets.filter((s) => s.type === \"code\").length,\n      conversation: integratedSnippets.filter((s) => s.type === \"conversation\")\n        .length,\n      documentation: integratedSnippets.filter(\n        (s) => s.type === \"documentation\"\n      ).length,\n      patterns: integratedSnippets.filter((s) => s.type === \"pattern\").length,\n    };\n\n    logMessage(\n      \"DEBUG\",\n      `Integrated ${integratedSnippets.length} snippets`,\n      typeBreakdown\n    );\n\n    return integratedSnippets;\n  } catch (error) {\n    logMessage(\"ERROR\", `Error integrating contexts`, {\n      error: error.message,\n      balanceStrategy,\n    });\n    throw error;\n  }\n}\n\n/**\n * Apply proportional balancing strategy for context integration\n *\n * @param {object} contextSources - Context sources with snippets\n * @param {number} tokenBudget - Total token budget\n * @returns {Array} Balanced context snippets\n */\nfunction _applyProportionalStrategy(contextSources, tokenBudget) {\n  try {\n    logMessage(\n      \"DEBUG\",\n      `Applying proportional strategy with budget: ${tokenBudget}`\n    );\n\n    const result = [];\n    let remainingBudget = tokenBudget;\n    const unusedBudgets = {};\n\n    // First pass: allocate tokens based on target percentages\n    for (const [sourceType, source] of Object.entries(contextSources)) {\n      // Skip empty sources\n      if (!source.snippets || source.snippets.length === 0) {\n        unusedBudgets[sourceType] = Math.floor(\n          tokenBudget * source.targetPercentage\n        );\n        logMessage(\n          \"DEBUG\",\n          `No snippets for ${sourceType}, reserving ${unusedBudgets[sourceType]} tokens`\n        );\n        continue;\n      }\n\n      // Calculate token budget for this source\n      const sourceBudget = Math.floor(tokenBudget * source.targetPercentage);\n\n      // Sort snippets by relevance score\n      const sortedSnippets = [...source.snippets].sort(\n        (a, b) => b.relevanceScore - a.relevanceScore\n      );\n\n      // Add snippets until budget is exhausted\n      let usedBudget = 0;\n      for (const snippet of sortedSnippets) {\n        if (usedBudget + snippet.tokenEstimate <= sourceBudget) {\n          result.push(snippet);\n          usedBudget += snippet.tokenEstimate;\n        } else {\n          // If the snippet doesn't fit, try the next one (might be smaller)\n          continue;\n        }\n      }\n\n      // Track unused budget for redistribution\n      if (usedBudget < sourceBudget) {\n        unusedBudgets[sourceType] = sourceBudget - usedBudget;\n        logMessage(\n          \"DEBUG\",\n          `${sourceType} used ${usedBudget}/${sourceBudget} tokens, ${unusedBudgets[sourceType]} unused`\n        );\n      } else {\n        unusedBudgets[sourceType] = 0;\n      }\n\n      remainingBudget -= usedBudget;\n    }\n\n    // Second pass: redistribute unused budget\n    if (remainingBudget > 0) {\n      logMessage(\"DEBUG\", `Redistributing ${remainingBudget} unused tokens`);\n\n      // Collect all remaining snippets\n      const remainingSnippets = [];\n      for (const [sourceType, source] of Object.entries(contextSources)) {\n        if (!source.snippets) continue;\n\n        const usedSnippetIds = new Set(\n          result.filter((s) => s.type === sourceType).map((s) => s.entity_id)\n        );\n\n        const unusedSnippets = source.snippets.filter(\n          (s) => !usedSnippetIds.has(s.entity_id)\n        );\n\n        remainingSnippets.push(...unusedSnippets);\n      }\n\n      // Sort by relevance score\n      remainingSnippets.sort((a, b) => b.relevanceScore - a.relevanceScore);\n\n      // Add snippets until remaining budget is exhausted\n      for (const snippet of remainingSnippets) {\n        if (snippet.tokenEstimate <= remainingBudget) {\n          result.push(snippet);\n          remainingBudget -= snippet.tokenEstimate;\n        }\n\n        if (remainingBudget <= 0) break;\n      }\n    }\n\n    logMessage(\n      \"DEBUG\",\n      `Applied proportional strategy, selected ${result.length} snippets with ${remainingBudget} tokens remaining`\n    );\n    return result;\n  } catch (error) {\n    logMessage(\"ERROR\", `Error applying proportional strategy`, {\n      error: error.message,\n      tokenBudget,\n    });\n    throw error;\n  }\n}\n\n/**\n * Apply equal representation balancing strategy for context integration\n *\n * @param {object} contextSources - Context sources with snippets\n * @param {number} tokenBudget - Total token budget\n * @returns {Array} Balanced context snippets\n */\nfunction _applyEqualRepresentationStrategy(contextSources, tokenBudget) {\n  try {\n    logMessage(\n      \"DEBUG\",\n      `Applying equal representation strategy with budget: ${tokenBudget}`\n    );\n\n    const result = [];\n    let remainingBudget = tokenBudget;\n\n    // Count non-empty sources\n    const nonEmptySources = Object.values(contextSources).filter(\n      (source) => source.snippets && source.snippets.length > 0\n    ).length;\n\n    if (nonEmptySources === 0) {\n      logMessage(\"WARN\", `No non-empty sources found for equal representation`);\n      return [];\n    }\n\n    // Allocate equal budget to each non-empty source\n    const budgetPerSource = Math.floor(tokenBudget / nonEmptySources);\n    logMessage(\"DEBUG\", `Allocating ${budgetPerSource} tokens per source`);\n\n    // First pass: add snippets from each source up to its equal share\n    for (const [sourceType, source] of Object.entries(contextSources)) {\n      if (!source.snippets || source.snippets.length === 0) continue;\n\n      // Sort snippets by relevance score\n      const sortedSnippets = [...source.snippets].sort(\n        (a, b) => b.relevanceScore - a.relevanceScore\n      );\n\n      // Add snippets until budget is exhausted\n      let usedBudget = 0;\n      for (const snippet of sortedSnippets) {\n        if (usedBudget + snippet.tokenEstimate <= budgetPerSource) {\n          result.push(snippet);\n          usedBudget += snippet.tokenEstimate;\n          remainingBudget -= snippet.tokenEstimate;\n        }\n      }\n    }\n\n    // Second pass: use remaining budget for highest relevance snippets\n    if (remainingBudget > 0) {\n      logMessage(\n        \"DEBUG\",\n        `Redistributing ${remainingBudget} unused tokens based on relevance`\n      );\n\n      // Collect all remaining snippets\n      const remainingSnippets = [];\n      for (const source of Object.values(contextSources)) {\n        if (!source.snippets) continue;\n\n        const usedSnippetIds = new Set(result.map((s) => s.entity_id));\n\n        const unusedSnippets = source.snippets.filter(\n          (s) => !usedSnippetIds.has(s.entity_id)\n        );\n\n        remainingSnippets.push(...unusedSnippets);\n      }\n\n      // Sort by relevance score\n      remainingSnippets.sort((a, b) => b.relevanceScore - a.relevanceScore);\n\n      // Add snippets until remaining budget is exhausted\n      for (const snippet of remainingSnippets) {\n        if (snippet.tokenEstimate <= remainingBudget) {\n          result.push(snippet);\n          remainingBudget -= snippet.tokenEstimate;\n        }\n\n        if (remainingBudget <= 0) break;\n      }\n    }\n\n    logMessage(\n      \"DEBUG\",\n      `Applied equal representation strategy, selected ${result.length} snippets with ${remainingBudget} tokens remaining`\n    );\n    return result;\n  } catch (error) {\n    logMessage(\"ERROR\", `Error applying equal representation strategy`, {\n      error: error.message,\n      tokenBudget,\n    });\n    throw error;\n  }\n}\n\n/**\n * Apply priority-based balancing strategy for context integration\n *\n * @param {Array} allSnippets - All snippets sorted by relevance\n * @param {number} tokenBudget - Total token budget\n * @returns {Array} Selected context snippets\n */\nfunction _applyPriorityBasedStrategy(allSnippets, tokenBudget) {\n  try {\n    logMessage(\n      \"DEBUG\",\n      `Applying priority-based strategy with budget: ${tokenBudget}`\n    );\n\n    const result = [];\n    let usedBudget = 0;\n\n    // Add snippets until budget is exhausted\n    for (const snippet of allSnippets) {\n      if (usedBudget + snippet.tokenEstimate <= tokenBudget) {\n        result.push(snippet);\n        usedBudget += snippet.tokenEstimate;\n      } else {\n        // If the snippet doesn't fit, try the next one (might be smaller)\n        continue;\n      }\n    }\n\n    logMessage(\n      \"DEBUG\",\n      `Applied priority-based strategy, selected ${result.length} snippets, using ${usedBudget}/${tokenBudget} tokens`\n    );\n    return result;\n  } catch (error) {\n    logMessage(\"ERROR\", `Error applying priority-based strategy`, {\n      error: error.message,\n      tokenBudget,\n    });\n    throw error;\n  }\n}\n\n/**\n * Estimate token count for a text\n *\n * @param {string} text - Text to estimate token count for\n * @returns {number} Estimated token count\n */\nfunction _estimateTokenCount(text) {\n  try {\n    if (!text) return 0;\n    // Simple estimation: ~4 characters per token on average\n    return Math.ceil(text.length / 4);\n  } catch (error) {\n    logMessage(\"WARN\", `Error estimating token count`, {\n      error: error.message,\n      textLength: text?.length || 0,\n    });\n    // Return a safe default\n    return text ? Math.ceil(text.length / 4) : 0;\n  }\n}\n\n/**\n * Generate source attribution for a snippet\n *\n * @param {object} snippet - Context snippet\n * @returns {string} Source attribution\n */\nfunction _generateSourceAttribution(snippet) {\n  try {\n    switch (snippet.type) {\n      case \"code\":\n        return `Source: ${snippet.metadata.path || \"Code\"} (${\n          snippet.metadata.entityType || \"entity\"\n        })`;\n      case \"conversation\":\n        const timestampStr = snippet.metadata.timestamp\n          ? new Date(snippet.metadata.timestamp).toLocaleString()\n          : \"Unknown time\";\n        return `From ${\n          snippet.metadata.role || \"conversation\"\n        } (${timestampStr})`;\n      case \"documentation\":\n        return `Documentation: ${\n          snippet.metadata.title || snippet.metadata.path || \"Unknown\"\n        }`;\n      case \"pattern\":\n        return `Pattern: ${snippet.metadata.name || \"Unknown\"} (${\n          snippet.metadata.patternType || \"general\"\n        })`;\n      default:\n        return `Source: ${snippet.type}`;\n    }\n  } catch (error) {\n    logMessage(\"WARN\", `Error generating source attribution`, {\n      error: error.message,\n      snippetType: snippet?.type,\n    });\n    // Return a generic attribution as fallback\n    return \"Source information unavailable\";\n  }\n}\n\n/**\n * Generate relevance explanation for a snippet\n *\n * @param {object} snippet - Context snippet\n * @param {string} query - Original query\n * @returns {string} Relevance explanation\n */\nfunction _generateRelevanceExplanation(snippet, query) {\n  try {\n    const relevanceScore = snippet.relevanceScore || 0;\n    const formattedScore = (relevanceScore * 100).toFixed(0);\n\n    let explanation = `Relevance: ${formattedScore}%`;\n\n    // Add type-specific explanations\n    switch (snippet.type) {\n      case \"code\":\n        explanation += ` - This code ${\n          relevanceScore > 0.8\n            ? \"directly addresses\"\n            : relevanceScore > 0.6\n            ? \"is closely related to\"\n            : \"may be relevant to\"\n        } your query about \"${query.substring(0, 30)}${\n          query.length > 30 ? \"...\" : \"\"\n        }\"`;\n        break;\n      case \"conversation\":\n        explanation += ` - This prior conversation ${\n          relevanceScore > 0.8\n            ? \"directly addresses\"\n            : relevanceScore > 0.6\n            ? \"discusses\"\n            : \"mentions\"\n        } similar topics to your current query`;\n        break;\n      case \"documentation\":\n        explanation += ` - This documentation ${\n          relevanceScore > 0.8\n            ? \"provides key information about\"\n            : relevanceScore > 0.6\n            ? \"explains\"\n            : \"contains information related to\"\n        } concepts in your query`;\n        break;\n      case \"pattern\":\n        explanation += ` - This pattern ${\n          relevanceScore > 0.8\n            ? \"is highly applicable to\"\n            : relevanceScore > 0.6\n            ? \"may be useful for\"\n            : \"could provide insights for\"\n        } your current task`;\n        break;\n      default:\n        explanation += ` - This content appears relevant to your query`;\n    }\n\n    return explanation;\n  } catch (error) {\n    logMessage(\"WARN\", `Error generating relevance explanation`, {\n      error: error.message,\n      snippetType: snippet?.type,\n    });\n    // Return a generic explanation as fallback\n    return `Relevance score: ${((snippet?.relevanceScore || 0) * 100).toFixed(\n      0\n    )}%`;\n  }\n}\n\n// Export the tool definition for server registration\nexport default {\n  name: \"retrieve_relevant_context\",\n  description:\n    \"Retrieves context from multiple sources that is relevant to the current query or conversation\",\n  inputSchema: retrieveRelevantContextInputSchema,\n  outputSchema: retrieveRelevantContextOutputSchema,\n  handler,\n};\n", "/**\n * InsightEngine.js\n *\n * Orchestrates the intelligent retrieval pipeline, combining intent prediction,\n * smart search, entity relationships, context prioritization, and compression\n * to provide the most relevant context for a given query.\n */\n\nimport * as IntentPredictorLogic from \"./IntentPredictorLogic.js\";\nimport * as SmartSearchServiceLogic from \"./SmartSearchServiceLogic.js\";\nimport * as RelationshipContextManagerLogic from \"./RelationshipContextManagerLogic.js\";\nimport * as ContextPrioritizerLogic from \"./ContextPrioritizerLogic.js\";\nimport * as ContextCompressorLogic from \"./ContextCompressorLogic.js\";\nimport * as ActiveContextManager from \"./ActiveContextManager.js\";\n\n/**\n * @typedef {Object} Message\n * @property {string} messageId - Unique identifier for the message\n * @property {string} conversationId - ID of the conversation this message belongs to\n * @property {string} role - Role of the message sender (e.g., 'user', 'assistant')\n * @property {string} content - Content of the message\n * @property {Date} timestamp - When the message was sent\n * @property {string[]} [relatedContextEntityIds] - IDs of related code entities\n * @property {string} [summary] - Summary of the message content\n * @property {string} [userIntent] - Inferred user intent\n * @property {string} [topicSegmentId] - ID of topic segment this message belongs to\n * @property {string[]} [semanticMarkers] - Semantic markers for enhanced retrieval\n * @property {Object} [sentimentIndicators] - Sentiment analysis results\n */\n\n/**\n * @typedef {Object} FocusArea\n * @property {string} focus_id - Unique identifier for the focus area\n * @property {string} focus_type - Type of focus area ('file', 'directory', 'task_type')\n * @property {string} identifier - Primary identifier for the focus area (e.g., file path)\n * @property {string} description - Human-readable description of the focus area\n * @property {string[]} related_entity_ids - Array of related entity IDs\n * @property {string[]} keywords - Array of keywords related to this focus area\n * @property {number} last_activated_at - Timestamp when this focus area was last active\n * @property {boolean} is_active - Whether this focus area is currently active\n */\n\n/**\n * @typedef {Object} Snippet\n * @property {string} entity_id - ID of the entity\n * @property {string} summarizedContent - Compressed/summarized content\n * @property {number} originalScore - Original relevance score\n * @property {string} type - Type of snippet\n */\n\n/**\n * @typedef {Object} SearchResult\n * @property {Object} entity - The found code entity\n * @property {number} relevanceScore - Relevance score for the search result\n */\n\n/**\n * @typedef {Object} ContextSnippet\n * @property {string} entity_id - ID of the entity\n * @property {string} content - Content of the entity\n * @property {string} type - Type of entity\n * @property {string} path - Path to the entity file\n * @property {string} name - Name of the entity\n * @property {number} baseRelevance - Base relevance score\n * @property {Object} metadata - Additional entity metadata\n */\n\n/**\n * Orchestrates the full retrieval pipeline to get the most relevant snippets for a query\n *\n * @param {string} query - The user's query\n * @param {Message[]} conversationHistory - Array of conversation messages\n * @param {FocusArea|null} currentFocusOverride - Optional override for the current focus area\n * @param {number} tokenBudget - Maximum token budget for returned context\n * @param {Object} [constraints] - Optional constraints for search\n * @returns {Promise<Snippet[]>} Array of relevant context snippets\n */\nexport async function orchestrateRetrieval(\n  query,\n  conversationHistory,\n  currentFocusOverride,\n  tokenBudget,\n  constraints = {}\n) {\n  try {\n    console.log(\n      `[InsightEngine] Orchestrating retrieval for query: \"${query}\"`\n    );\n\n    // 1. Determine current focus\n    const currentFocus =\n      currentFocusOverride || (await ActiveContextManager.getActiveFocus());\n    console.log(\n      `[InsightEngine] Using focus: ${\n        currentFocus ? currentFocus.identifier : \"None\"\n      }`\n    );\n\n    // 2. Get intent and refined keywords from query and conversation history\n    const { intent, keywords } =\n      await IntentPredictorLogic.inferIntentFromQuery(\n        query,\n        conversationHistory.slice(-5) // Use last 5 messages for context\n      );\n\n    // Ensure keywords are strings (they might be objects or other types)\n    let processedKeywords = [];\n    if (Array.isArray(keywords)) {\n      processedKeywords = keywords\n        .map((kw) => {\n          // Check if it's a string already\n          if (typeof kw === \"string\") {\n            return kw;\n          }\n          // If it's an object with a 'token' property\n          if (kw && typeof kw === \"object\" && kw.token) {\n            return kw.token;\n          }\n          // Convert to string if possible\n          return String(kw);\n        })\n        .filter((kw) => kw && kw.length > 0); // Remove empty entries\n    }\n\n    // If we ended up with no keywords, extract directly from the query\n    if (processedKeywords.length === 0) {\n      processedKeywords = query.split(/\\s+/).filter((word) => word.length > 2);\n    }\n\n    console.log(\n      `[InsightEngine] Detected intent: ${intent}, extracted keywords: ${processedKeywords.join(\n        \", \"\n      )}`\n    );\n\n    // 3. Call SmartSearchServiceLogic.searchByKeywords with refined keywords\n    const searchOptions = {\n      ...constraints,\n      limit: constraints.limit || 20, // Default to 20 results initially\n      strategy: constraints.strategy || \"combined\", // Default to combined search strategy\n    };\n\n    const searchResults = await SmartSearchServiceLogic.searchByKeywords(\n      processedKeywords,\n      searchOptions\n    );\n\n    console.log(\n      `[InsightEngine] Initial search returned ${searchResults.length} results`\n    );\n\n    // Skip further processing if no results\n    if (!searchResults || searchResults.length === 0) {\n      return [];\n    }\n\n    // 4. For highly relevant candidates, explore related entities\n    const relatedEntities = [];\n\n    // Process most relevant candidates (top 5 or 25% of results, whichever is smaller)\n    const topResultsCount = Math.min(5, Math.ceil(searchResults.length * 0.25));\n    const topResults = searchResults.slice(0, topResultsCount);\n\n    // For each top result, explore relationships\n    for (const result of topResults) {\n      const entityId = result.entity.entity_id;\n\n      // Use appropriate method based on entity type\n      if (\n        result.entity.entity_type === \"function\" ||\n        result.entity.entity_type === \"method\"\n      ) {\n        try {\n          // Get call graph for functions/methods\n          const callGraph =\n            await RelationshipContextManagerLogic.buildCallGraphSnippet(\n              entityId,\n              1 // Depth of 1 to avoid too much expansion\n            );\n\n          // Extract entities from call graph\n          if (callGraph && callGraph.nodes) {\n            for (const node of callGraph.nodes) {\n              // Skip if it's the same as the source entity\n              if (node.id !== entityId) {\n                relatedEntities.push({\n                  entity_id: node.id,\n                  relationship: \"call_graph\",\n                  source_entity_id: entityId,\n                });\n              }\n            }\n          }\n        } catch (error) {\n          console.warn(\n            `[InsightEngine] Error building call graph for ${entityId}:`,\n            error\n          );\n        }\n      } else {\n        try {\n          // Get general relationships for other entity types\n          const relationships =\n            await RelationshipContextManagerLogic.getRelationships(\n              entityId,\n              [\"imports\", \"uses\", \"inherits\", \"implements\"],\n              2 // Limit to 2 relationships per type\n            );\n\n          // Add related entities\n          for (const rel of relationships) {\n            relatedEntities.push({\n              entity_id: rel.target_entity_id,\n              relationship: rel.relationship_type,\n              source_entity_id: entityId,\n            });\n          }\n        } catch (error) {\n          console.warn(\n            `[InsightEngine] Error getting relationships for ${entityId}:`,\n            error\n          );\n        }\n      }\n    }\n\n    console.log(\n      `[InsightEngine] Found ${relatedEntities.length} related entities`\n    );\n\n    // 5. Fetch full details of related entities and combine with search results\n    const relatedEntityResults = [];\n\n    // Create a Set of existing entity IDs to avoid duplicates\n    const existingEntityIds = new Set(\n      searchResults.map((result) => result.entity.entity_id)\n    );\n\n    // Process each related entity\n    for (const relatedEntity of relatedEntities) {\n      // Skip if we already have this entity\n      if (existingEntityIds.has(relatedEntity.entity_id)) {\n        continue;\n      }\n\n      try {\n        // Query for entity details\n        const entities = await SmartSearchServiceLogic.searchByEntityIds([\n          relatedEntity.entity_id,\n        ]);\n\n        if (entities && entities.length > 0) {\n          // Add to results list with a slightly lower score\n          const sourceResult = searchResults.find(\n            (r) => r.entity.entity_id === relatedEntity.source_entity_id\n          );\n\n          // Base the relevance on the source entity, but reduce it\n          const relevanceScore = sourceResult\n            ? Math.max(0.4, sourceResult.relevanceScore * 0.8)\n            : 0.4;\n\n          relatedEntityResults.push({\n            entity: entities[0],\n            relevanceScore,\n          });\n\n          // Add to set to avoid duplicates\n          existingEntityIds.add(relatedEntity.entity_id);\n        }\n      } catch (error) {\n        console.warn(\n          `[InsightEngine] Error fetching details for related entity ${relatedEntity.entity_id}:`,\n          error\n        );\n      }\n    }\n\n    // Combine original search results with related entities\n    const combinedResults = [...searchResults, ...relatedEntityResults];\n    console.log(\n      `[InsightEngine] Combined results: ${combinedResults.length} entities`\n    );\n\n    // 6. Convert all candidate entities to ContextSnippet format\n    const contextSnippets = combinedResults.map((result) => ({\n      entity_id: result.entity.entity_id,\n      content: result.entity.raw_content || \"\",\n      type: result.entity.entity_type || \"unknown\",\n      path: result.entity.file_path || \"\",\n      name: result.entity.name || \"\",\n      baseRelevance: result.relevanceScore,\n      metadata: {\n        symbolPath: result.entity.symbol_path,\n        parentId: result.entity.parent_entity_id,\n        version: result.entity.version,\n      },\n      entity: result.entity, // Include full entity for prioritization logic\n    }));\n\n    // 7. Prioritize the context snippets\n    const prioritizedSnippets =\n      await ContextPrioritizerLogic.prioritizeContexts(\n        contextSnippets,\n        processedKeywords,\n        currentFocus,\n        Math.max(50, contextSnippets.length) // Higher limit to ensure we consider all snippets\n      );\n\n    console.log(\n      `[InsightEngine] Prioritized ${prioritizedSnippets.length} context snippets`\n    );\n\n    // 8. Manage token budget to get final set of snippets\n    const processedSnippets = await ContextCompressorLogic.manageTokenBudget(\n      prioritizedSnippets.map((snippet) => ({\n        ...snippet,\n        score: snippet.relevanceScore || snippet.baseRelevance,\n      })),\n      tokenBudget,\n      processedKeywords\n    );\n\n    console.log(\n      `[InsightEngine] Final result: ${processedSnippets.length} processed snippets within token budget`\n    );\n\n    // 9. Map the processed snippets to the expected Snippet format\n    const finalSnippets = processedSnippets.map((snippet) => ({\n      entity_id: snippet.entity_id,\n      summarizedContent: snippet.summarizedContent,\n      originalScore: snippet.originalScore || snippet.score,\n      type:\n        snippet.type ||\n        (snippet.entity && snippet.entity.entity_type) ||\n        \"unknown\",\n    }));\n\n    return finalSnippets;\n  } catch (error) {\n    console.error(\"[InsightEngine] Error orchestrating retrieval:\", error);\n    return []; // Return empty array on error\n  }\n}\n", "/**\n * recordMilestoneContext.tool.js\n *\n * MCP tool implementation for recording milestone context\n * This tool creates a snapshot of the current context and performs\n * impact analysis for major milestones during development.\n */\n\nimport { z } from \"zod\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { executeQuery } from \"../db.js\";\nimport * as ActiveContextManager from \"../logic/ActiveContextManager.js\";\nimport * as TimelineManagerLogic from \"../logic/TimelineManagerLogic.js\";\nimport * as LearningSystem from \"../logic/LearningSystem.js\";\nimport * as RelationshipContextManagerLogic from \"../logic/RelationshipContextManagerLogic.js\";\nimport * as SmartSearchServiceLogic from \"../logic/SmartSearchServiceLogic.js\";\nimport { logMessage } from \"../utils/logger.js\";\n\nimport {\n  recordMilestoneContextInputSchema,\n  recordMilestoneContextOutputSchema,\n} from \"../schemas/toolSchemas.js\";\n\n/**\n * Handler for record_milestone_context tool\n *\n * @param {object} input - Tool input parameters\n * @param {object} sdkContext - SDK context\n * @returns {Promise<object>} Tool output\n */\nasync function handler(input, sdkContext) {\n  try {\n    logMessage(\"INFO\", `record_milestone_context tool started`, {\n      milestoneName: input.name,\n      category: input.milestoneCategory || \"uncategorized\",\n      conversationId: input.conversationId,\n    });\n\n    // 1. Extract input parameters\n    const {\n      conversationId,\n      name,\n      description = \"\",\n      customData = {},\n      milestoneCategory = \"uncategorized\",\n      assessImpact = true,\n    } = input;\n\n    // Validate essential parameters\n    if (!name) {\n      const error = new Error(\"Milestone name is required\");\n      error.code = \"MISSING_NAME\";\n      throw error;\n    }\n\n    // 2. Gather active context\n    let activeContextEntities = [];\n    let activeFocus = null;\n    let activeContextIds = [];\n\n    try {\n      activeContextEntities =\n        await ActiveContextManager.getActiveContextAsEntities();\n      activeFocus = await ActiveContextManager.getActiveFocus();\n      activeContextIds = activeContextEntities.map((entity) => entity.id);\n\n      logMessage(\"DEBUG\", `Retrieved active context`, {\n        entityCount: activeContextIds.length,\n        hasFocus: !!activeFocus,\n      });\n    } catch (contextErr) {\n      logMessage(\n        \"WARN\",\n        `Error retrieving active context, continuing with empty context`,\n        {\n          error: contextErr.message,\n        }\n      );\n      // Continue with empty context instead of failing\n    }\n\n    // 3. Create the snapshot data\n    const snapshotData = {\n      milestoneCategory,\n      name,\n      description,\n      activeFocus,\n      entityIds: activeContextIds,\n      customData,\n      timestamp: Date.now(),\n      conversationId,\n    };\n\n    // 4. Record the milestone event in the timeline\n    let milestoneEventId;\n    try {\n      milestoneEventId = await TimelineManagerLogic.recordEvent(\n        \"milestone_created\",\n        {\n          name,\n          category: milestoneCategory,\n          entityCount: activeContextIds.length,\n          timestamp: Date.now(),\n        },\n        activeContextIds,\n        conversationId\n      );\n      logMessage(\"DEBUG\", `Recorded milestone event in timeline`, {\n        eventId: milestoneEventId,\n      });\n    } catch (timelineErr) {\n      logMessage(\"ERROR\", `Failed to record milestone event in timeline`, {\n        error: timelineErr.message,\n        name,\n        category: milestoneCategory,\n      });\n      // This is a critical failure, rethrow\n      throw timelineErr;\n    }\n\n    // 5. Create snapshot in the database\n    let milestoneId;\n    try {\n      milestoneId = await TimelineManagerLogic.createSnapshot(\n        snapshotData,\n        name,\n        description,\n        milestoneEventId\n      );\n      logMessage(\"INFO\", `Created milestone with ID: ${milestoneId}`);\n\n      // Also save milestone in context_states table\n      try {\n        const stateId = uuidv4();\n        const currentTime = new Date().toISOString();\n        const stateData = JSON.stringify(snapshotData);\n\n        const insertStateQuery = `\n          INSERT INTO context_states (\n            state_id, milestone_id, conversation_id, state_type, \n            state_data, created_at, metadata\n          ) VALUES (?, ?, ?, ?, ?, ?, ?)\n        `;\n\n        const stateParams = [\n          stateId,\n          milestoneId,\n          conversationId,\n          \"milestone\",\n          stateData,\n          currentTime,\n          JSON.stringify({ name, description, category: milestoneCategory }),\n        ];\n\n        await executeQuery(insertStateQuery, stateParams);\n        logMessage(\n          \"INFO\",\n          `Saved milestone state in context_states with ID: ${stateId}`\n        );\n      } catch (stateErr) {\n        logMessage(\n          \"ERROR\",\n          `Failed to save milestone in context_states table`,\n          {\n            error: stateErr.message,\n            milestoneId,\n          }\n        );\n        // Continue despite error, as we already have the snapshot\n      }\n    } catch (snapshotErr) {\n      logMessage(\"ERROR\", `Failed to create milestone snapshot`, {\n        error: snapshotErr.message,\n        name,\n        eventId: milestoneEventId,\n      });\n      // This is a critical failure, rethrow\n      throw snapshotErr;\n    }\n\n    // 6. Initialize impact assessment result\n    let impactAssessment = null;\n\n    // 7. If impact assessment is requested, perform it\n    if (assessImpact) {\n      try {\n        logMessage(\"INFO\", `Starting impact assessment for milestone`, {\n          milestoneId,\n          category: milestoneCategory,\n        });\n        impactAssessment = await _assessMilestoneImpact(\n          milestoneId,\n          milestoneCategory,\n          activeContextIds\n        );\n      } catch (impactErr) {\n        logMessage(\"WARN\", `Failed to assess milestone impact`, {\n          error: impactErr.message,\n          milestoneId,\n        });\n        // Set a basic impact assessment with error information\n        impactAssessment = {\n          impactScore: 0,\n          impactLevel: \"unknown\",\n          impactSummary: `Unable to assess impact: ${impactErr.message}`,\n          error: impactErr.message,\n          scopeMetrics: {\n            directlyModifiedEntities: activeContextIds.length,\n            potentiallyImpactedEntities: 0,\n            impactedComponents: 0,\n            criticalPathsCount: 0,\n          },\n        };\n      }\n    } else {\n      logMessage(\"DEBUG\", `Skipping impact assessment (not requested)`);\n    }\n\n    // 8. Trigger background pattern analysis (don't await)\n    setTimeout(() => {\n      logMessage(\n        \"DEBUG\",\n        `Starting background pattern analysis for milestone: ${milestoneId}`\n      );\n      LearningSystem.analyzePatternsAroundMilestone(milestoneId).catch(\n        (error) => {\n          logMessage(\"ERROR\", `Error in background pattern analysis`, {\n            error: error.message,\n            milestoneId,\n          });\n        }\n      );\n    }, 100);\n\n    // 9. Return the tool response\n    logMessage(\"INFO\", `record_milestone_context tool completed successfully`, {\n      milestoneId,\n      entityCount: activeContextIds.length,\n      hasImpactAssessment: !!impactAssessment,\n    });\n\n    const responseData = {\n      message: `Milestone \"${name}\" recorded successfully with ${activeContextIds.length} related entities.`,\n      milestoneId,\n      status: \"success\",\n      milestoneCategory,\n      relatedEntitiesCount: activeContextIds.length,\n      impactAssessment,\n    };\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify(responseData),\n        },\n      ],\n    };\n  } catch (error) {\n    // Log detailed error information\n    logMessage(\"ERROR\", `Error in record_milestone_context tool`, {\n      error: error.message,\n      stack: error.stack,\n      input: {\n        name: input.name,\n        category: input.milestoneCategory,\n        conversationId: input.conversationId,\n      },\n    });\n\n    // Return error response\n    const errorResponse = {\n      error: true,\n      errorCode: error.code || \"MILESTONE_RECORDING_FAILED\",\n      errorDetails: error.message,\n      milestoneId: null,\n      status: \"error\",\n      milestoneCategory: input.milestoneCategory || \"uncategorized\",\n      relatedEntitiesCount: 0,\n      impactAssessment: {\n        error: error.message,\n      },\n    };\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify(errorResponse),\n        },\n      ],\n    };\n  }\n}\n\n/**\n * Assesses the impact of a milestone by analyzing relationships and dependencies\n *\n * @param {string} milestoneId - ID of the milestone\n * @param {string} category - Category of the milestone\n * @param {string[]} activeContextIds - IDs of entities in the active context\n * @returns {Promise<Object>} Impact assessment results\n * @private\n */\nasync function _assessMilestoneImpact(milestoneId, category, activeContextIds) {\n  try {\n    logMessage(\"DEBUG\", `Assessing impact for milestone: ${milestoneId}`, {\n      category,\n      entityCount: activeContextIds?.length || 0,\n    });\n\n    // Skip if no active context IDs\n    if (!activeContextIds || activeContextIds.length === 0) {\n      logMessage(\n        \"DEBUG\",\n        `No active context entities, skipping detailed impact assessment`\n      );\n      return {\n        impactScore: 0,\n        impactLevel: \"none\",\n        impactSummary: \"No code entities were modified in this milestone.\",\n        scopeMetrics: {\n          directlyModifiedEntities: 0,\n          potentiallyImpactedEntities: 0,\n          impactedComponents: 0,\n          criticalPathsCount: 0,\n        },\n      };\n    }\n\n    // 1. Fetch full details of active context entities\n    let entities = [];\n    try {\n      logMessage(\n        \"DEBUG\",\n        `Fetching details for ${activeContextIds.length} entities`\n      );\n\n      const entityDetails = await Promise.all(\n        activeContextIds.map(async (id) => {\n          try {\n            // Fetch entity details from database\n            const query = `SELECT * FROM code_entities WHERE entity_id = ?`;\n            const result = await executeQuery(query, [id]);\n            return result.length > 0 ? result[0] : null;\n          } catch (queryErr) {\n            logMessage(\"WARN\", `Failed to fetch entity details`, {\n              error: queryErr.message,\n              entityId: id,\n            });\n            return null;\n          }\n        })\n      );\n\n      entities = entityDetails.filter(Boolean);\n      logMessage(\n        \"DEBUG\",\n        `Retrieved details for ${entities.length}/${activeContextIds.length} entities`\n      );\n    } catch (fetchErr) {\n      logMessage(\"ERROR\", `Failed to fetch entity details`, {\n        error: fetchErr.message,\n      });\n      // Return a minimal assessment\n      return {\n        impactScore: 0.1,\n        impactLevel: \"unknown\",\n        impactSummary: `Impact could not be fully assessed due to database error: ${fetchErr.message}`,\n        scopeMetrics: {\n          directlyModifiedEntities: activeContextIds.length,\n          potentiallyImpactedEntities: 0,\n          impactedComponents: 0,\n          criticalPathsCount: 0,\n        },\n        error: fetchErr.message,\n      };\n    }\n\n    // 2. Analyze relationships to find potentially impacted entities\n    const impactedEntityIds = new Set(activeContextIds);\n    const criticalPaths = [];\n    const componentImpacts = new Map(); // Map to track impacts by component/directory\n\n    // Build a map of entity types for quick reference\n    const entityTypeMap = new Map();\n    entities.forEach((entity) => {\n      entityTypeMap.set(entity.entity_id, entity.entity_type);\n    });\n\n    // 3. For each entity, find its relationships\n    try {\n      for (const entity of entities) {\n        // Get outgoing relationships (dependencies on other entities)\n        const outgoingRelationships =\n          await RelationshipContextManagerLogic.getRelationships(\n            entity.entity_id,\n            \"outgoing\"\n          );\n\n        logMessage(\n          \"DEBUG\",\n          `Retrieved ${outgoingRelationships.length} outgoing relationships for entity`,\n          {\n            entityId: entity.entity_id,\n            entityType: entity.entity_type,\n          }\n        );\n\n        // For each relationship, add the target to potentially impacted entities\n        for (const rel of outgoingRelationships) {\n          // Only add if it's not already in the active context\n          if (!impactedEntityIds.has(rel.target_entity_id)) {\n            impactedEntityIds.add(rel.target_entity_id);\n\n            // Check if this forms a critical path\n            if (\n              rel.relationship_type === \"calls\" ||\n              rel.relationship_type === \"extends\" ||\n              rel.relationship_type === \"implements\"\n            ) {\n              criticalPaths.push({\n                source: entity.entity_id,\n                target: rel.target_entity_id,\n                type: rel.relationship_type,\n                criticality: 0.8, // Default high criticality for these types\n              });\n            }\n          }\n        }\n\n        // Track component impacts\n        // Extract component/directory from file path\n        const filePath = entity.file_path || \"\";\n        const component = filePath.split(\"/\").slice(0, 2).join(\"/\");\n        if (component) {\n          const currentCount = componentImpacts.get(component) || 0;\n          componentImpacts.set(component, currentCount + 1);\n        }\n      }\n    } catch (relErr) {\n      logMessage(\"WARN\", `Error analyzing relationships`, {\n        error: relErr.message,\n        milestoneId,\n      });\n      // Continue with partial data\n    }\n\n    logMessage(\"DEBUG\", `Completed relationship analysis`, {\n      impactedEntities: impactedEntityIds.size,\n      criticalPaths: criticalPaths.length,\n      componentCount: componentImpacts.size,\n    });\n\n    // 4. Calculate impact metrics\n    const directlyModifiedCount = activeContextIds.length;\n    const potentiallyImpactedCount =\n      impactedEntityIds.size - directlyModifiedCount;\n    const impactedComponentsCount = componentImpacts.size;\n    const criticalPathsCount = criticalPaths.length;\n\n    // 5. Calculate impact score based on metrics\n    let impactScore;\n    let impactLevel;\n\n    try {\n      // Calculate base impact score (0-1)\n      const baseImpactScore = Math.min(\n        1,\n        directlyModifiedCount * 0.02 +\n          potentiallyImpactedCount * 0.01 +\n          impactedComponentsCount * 0.1 +\n          criticalPathsCount * 0.05\n      );\n\n      // Adjust based on milestone category\n      let categoryMultiplier = 1;\n      switch (category) {\n        case \"major_feature\":\n          categoryMultiplier = 1.2;\n          break;\n        case \"refactoring\":\n          categoryMultiplier = 1.5; // Refactorings often have wide impact\n          break;\n        case \"bug_fix\":\n          categoryMultiplier = 0.7; // Bug fixes typically have more limited scope\n          break;\n        case \"critical_fix\":\n          categoryMultiplier = 1.3; // Critical fixes may touch core parts\n          break;\n        default:\n          categoryMultiplier = 1;\n      }\n\n      impactScore = Math.min(1, baseImpactScore * categoryMultiplier);\n\n      // Determine impact level\n      if (impactScore < 0.2) {\n        impactLevel = \"low\";\n      } else if (impactScore < 0.5) {\n        impactLevel = \"medium\";\n      } else if (impactScore < 0.8) {\n        impactLevel = \"high\";\n      } else {\n        impactLevel = \"critical\";\n      }\n\n      logMessage(\"INFO\", `Calculated impact assessment`, {\n        impactScore,\n        impactLevel,\n        directlyModified: directlyModifiedCount,\n        potentiallyImpacted: potentiallyImpactedCount,\n        components: impactedComponentsCount,\n      });\n    } catch (calcErr) {\n      logMessage(\"ERROR\", `Error calculating impact score`, {\n        error: calcErr.message,\n      });\n      // Provide default values\n      impactScore = 0.3;\n      impactLevel = \"medium\";\n    }\n\n    // 6. Generate impact summary text\n    let impactSummary;\n    try {\n      impactSummary = _generateImpactSummary(\n        impactLevel,\n        directlyModifiedCount,\n        potentiallyImpactedCount,\n        impactedComponentsCount,\n        criticalPathsCount,\n        category\n      );\n    } catch (summaryErr) {\n      logMessage(\"WARN\", `Error generating impact summary`, {\n        error: summaryErr.message,\n      });\n      // Provide default summary\n      impactSummary = `This milestone has a ${impactLevel} impact, affecting ${directlyModifiedCount} entities directly and potentially impacting ${potentiallyImpactedCount} others.`;\n    }\n\n    // 7. Return the complete assessment\n    return {\n      impactScore,\n      impactLevel,\n      impactSummary,\n      scopeMetrics: {\n        directlyModifiedEntities: directlyModifiedCount,\n        potentiallyImpactedEntities: potentiallyImpactedCount,\n        impactedComponents: impactedComponentsCount,\n        criticalPathsCount,\n      },\n      componentBreakdown: Object.fromEntries(componentImpacts),\n      criticalPathsTop: criticalPaths.slice(0, 5), // Only include top 5 critical paths\n    };\n  } catch (error) {\n    logMessage(\"ERROR\", `Error in impact assessment`, {\n      error: error.message,\n      stack: error.stack,\n      milestoneId,\n      category,\n    });\n\n    // Return a minimal assessment with error info\n    return {\n      impactScore: 0.1,\n      impactLevel: \"unknown\",\n      impactSummary: `Impact assessment encountered an error: ${error.message}`,\n      error: error.message,\n      scopeMetrics: {\n        directlyModifiedEntities: activeContextIds\n          ? activeContextIds.length\n          : 0,\n        potentiallyImpactedEntities: 0,\n        impactedComponents: 0,\n        criticalPathsCount: 0,\n      },\n    };\n  }\n}\n\n/**\n * Generates an impact summary text based on assessment metrics\n *\n * @param {string} impactLevel - Level of impact (low, medium, high, critical)\n * @param {number} directCount - Count of directly modified entities\n * @param {number} indirectCount - Count of indirectly impacted entities\n * @param {number} componentCount - Count of impacted components\n * @param {number} criticalPathCount - Count of critical paths\n * @param {string} category - Milestone category\n * @returns {string} Human-readable impact summary\n * @private\n */\nfunction _generateImpactSummary(\n  impactLevel,\n  directCount,\n  indirectCount,\n  componentCount,\n  criticalPathCount,\n  category\n) {\n  try {\n    // Start with impact level\n    let summary = `This ${category} milestone has a ${impactLevel} impact, `;\n\n    // Add direct and indirect counts\n    summary += `directly modifying ${directCount} entities and potentially affecting ${indirectCount} additional entities. `;\n\n    // Add component information\n    if (componentCount > 0) {\n      summary += `Changes span ${componentCount} component${\n        componentCount === 1 ? \"\" : \"s\"\n      }. `;\n    }\n\n    // Add critical path information if relevant\n    if (criticalPathCount > 0) {\n      summary += `Found ${criticalPathCount} critical dependency path${\n        criticalPathCount === 1 ? \"\" : \"s\"\n      } that may require careful testing. `;\n    }\n\n    // Add category-specific advice\n    switch (category) {\n      case \"refactoring\":\n        summary +=\n          \"Since this is a refactoring, consider comprehensive regression testing.\";\n        break;\n      case \"major_feature\":\n        summary +=\n          \"As a major feature, ensure adequate test coverage for new functionality.\";\n        break;\n      case \"bug_fix\":\n        summary +=\n          \"For this bug fix, focus testing on the specific issue resolution.\";\n        break;\n      case \"critical_fix\":\n        summary +=\n          \"This critical fix requires careful validation in production-like environments.\";\n        break;\n    }\n\n    return summary;\n  } catch (error) {\n    logMessage(\"WARN\", `Error generating impact summary text`, {\n      error: error.message,\n    });\n    // Return a simple fallback summary\n    return `This milestone has a ${impactLevel} impact, affecting ${directCount} entities directly.`;\n  }\n}\n\n// Export the tool definition for server registration\nexport default {\n  name: \"record_milestone_context\",\n  description:\n    \"Records a development milestone and its context, creating a snapshot for reference and learning\",\n  inputSchema: recordMilestoneContextInputSchema,\n  outputSchema: recordMilestoneContextOutputSchema,\n  handler,\n};\n", "/**\n * LearningSystem.js\n *\n * Background analysis of the codebase to extract and store reusable patterns.\n */\n\nimport { executeQuery } from \"../db.js\";\nimport * as SemanticPatternRecognizerLogic from \"./SemanticPatternRecognizerLogic.js\";\nimport * as CodeStructureAnalyzerLogic from \"./CodeStructureAnalyzerLogic.js\";\nimport * as ConversationIntelligence from \"./ConversationIntelligence.js\";\nimport * as GlobalPatternRepository from \"./GlobalPatternRepository.js\";\nimport * as TextTokenizerLogic from \"./TextTokenizerLogic.js\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { logMessage } from \"../utils/logger.js\";\n\n/**\n * Performs background analysis of the entire project's codebase for patterns.\n *\n * @returns {Promise<void>}\n */\nexport async function extractPatternsFromCode() {\n  try {\n    logMessage(\"info\", \"[LearningSystem] Starting code pattern extraction...\");\n    // 1. Fetch all code entities of interest (functions, classes, methods)\n    const query = `\n      SELECT * FROM code_entities\n      WHERE type IN ('function', 'class', 'method')\n      LIMIT 1000\n    `;\n    const entities = await executeQuery(query, []);\n    if (!entities || entities.length === 0) {\n      logMessage(\n        \"info\",\n        \"[LearningSystem] No code entities found for pattern extraction.\"\n      );\n      return;\n    }\n    logMessage(\n      \"info\",\n      `[LearningSystem] Analyzing ${entities.length} code entities...`\n    );\n\n    // 2. Analyze each entity for patterns\n    for (const entity of entities) {\n      try {\n        // Recognize patterns in the entity\n        const patterns = await SemanticPatternRecognizerLogic.recognizePatterns(\n          entity\n        );\n        if (patterns && patterns.length > 0) {\n          for (const pattern of patterns) {\n            if (pattern.confidence && pattern.confidence >= 0.7) {\n              // Store the pattern if not already stored\n              await SemanticPatternRecognizerLogic.addPatternToRepository(\n                pattern\n              );\n              logMessage(\n                \"info\",\n                `[LearningSystem] Pattern stored: ${pattern.name || pattern.id}`\n              );\n            }\n          }\n        }\n      } catch (entityErr) {\n        logMessage(\n          \"warn\",\n          `[LearningSystem] Error analyzing entity ${entity.id}:`,\n          { error: entityErr.message }\n        );\n      }\n    }\n\n    // 3. Optionally, find groups of structurally similar entities\n    try {\n      const groups =\n        await CodeStructureAnalyzerLogic.findStructurallySimilarEntities(\n          entities\n        );\n      for (const group of groups) {\n        try {\n          const groupPattern =\n            await SemanticPatternRecognizerLogic.generatePatternFromExamples(\n              group\n            );\n          if (\n            groupPattern &&\n            groupPattern.confidence &&\n            groupPattern.confidence >= 0.7\n          ) {\n            await SemanticPatternRecognizerLogic.addPatternToRepository(\n              groupPattern\n            );\n            logMessage(\n              \"info\",\n              `[LearningSystem] Group pattern stored: ${\n                groupPattern.name || groupPattern.id\n              }`\n            );\n          }\n        } catch (groupErr) {\n          logMessage(\n            \"warn\",\n            \"[LearningSystem] Error generating pattern from group:\",\n            { error: groupErr.message }\n          );\n        }\n      }\n    } catch (groupingErr) {\n      logMessage(\n        \"warn\",\n        \"[LearningSystem] Error finding structurally similar entity groups:\",\n        { error: groupingErr.message }\n      );\n    }\n\n    logMessage(\"info\", \"[LearningSystem] Pattern extraction complete.\");\n  } catch (error) {\n    logMessage(\n      \"error\",\n      \"[LearningSystem] Fatal error during pattern extraction:\",\n      { error: error.message }\n    );\n  }\n}\n\n/**\n * Analyzes timeline_events and conversation_history to find patterns of tool usage, feature interaction, or problem-solving sequences.\n *\n * @returns {Promise<void>}\n */\nexport async function identifyUsagePatterns() {\n  try {\n    logMessage(\n      \"info\",\n      \"[LearningSystem] Starting usage pattern identification...\"\n    );\n    // 1. Fetch timeline events (limit for performance)\n    const timelineQuery = `\n      SELECT conversation_id, type, timestamp\n      FROM timeline_events\n      WHERE type IN ('search_query', 'file_edit', 'milestone_created', 'new_message', 'code_change', 'focus_change')\n      ORDER BY conversation_id, timestamp ASC\n      LIMIT 5000\n    `;\n    const events = await executeQuery(timelineQuery, []);\n    if (!events || events.length === 0) {\n      logMessage(\n        \"info\",\n        \"[LearningSystem] No timeline events found for usage pattern analysis.\"\n      );\n      return;\n    }\n\n    // 2. Group events by conversation\n    const eventsByConversation = {};\n    for (const event of events) {\n      if (!eventsByConversation[event.conversation_id]) {\n        eventsByConversation[event.conversation_id] = [];\n      }\n      eventsByConversation[event.conversation_id].push(event);\n    }\n\n    // 3. Analyze event type transitions (simple Markov chain/frequency count)\n    const transitionCounts = {};\n    for (const convId in eventsByConversation) {\n      const convEvents = eventsByConversation[convId];\n      for (let i = 0; i < convEvents.length - 1; i++) {\n        const from = convEvents[i].type;\n        const to = convEvents[i + 1].type;\n        const key = `${from}=>${to}`;\n        transitionCounts[key] = (transitionCounts[key] || 0) + 1;\n      }\n    }\n\n    // 4. Find most common transitions (usage patterns)\n    const sortedTransitions = Object.entries(transitionCounts)\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 10); // Top 10 patterns\n\n    // 5. Store discovered patterns in project_patterns\n    for (const [transition, count] of sortedTransitions) {\n      const [from, to] = transition.split(\"=>\");\n      const pattern = {\n        pattern_type: \"usage_workflow\",\n        name: `Common transition: ${from} \u2192 ${to}`,\n        description: `Frequently observed transition from ${from} to ${to} in user workflow.`,\n        representation: JSON.stringify({ sequence: [from, to], count }),\n        is_global: true,\n        utility_score: count,\n        confidence_score: Math.min(1, count / 10),\n        created_at: new Date().toISOString(),\n        last_used: null,\n        use_count: 0,\n      };\n      // Insert into project_patterns (ignore duplicates for now)\n      try {\n        await executeQuery(\n          `INSERT INTO project_patterns (pattern_type, name, description, representation, is_global, utility_score, confidence_score, created_at, last_used, use_count)\n           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n          `,\n          [\n            pattern.pattern_type,\n            pattern.name,\n            pattern.description,\n            pattern.representation,\n            pattern.is_global ? 1 : 0,\n            pattern.utility_score,\n            pattern.confidence_score,\n            pattern.created_at,\n            pattern.last_used,\n            pattern.use_count,\n          ]\n        );\n        logMessage(\n          \"info\",\n          `[LearningSystem] Usage pattern stored: ${pattern.name}`\n        );\n      } catch (insertErr) {\n        // Ignore duplicate errors, log others\n        if (!/UNIQUE|duplicate/i.test(insertErr.message)) {\n          logMessage(\"warn\", \"[LearningSystem] Error storing usage pattern:\", {\n            error: insertErr.message,\n          });\n        }\n      }\n    }\n\n    logMessage(\n      \"info\",\n      \"[LearningSystem] Usage pattern identification complete.\"\n    );\n  } catch (error) {\n    logMessage(\n      \"error\",\n      \"[LearningSystem] Fatal error during usage pattern identification:\",\n      { error: error.message }\n    );\n  }\n}\n\n/**\n * Analyzes context and activity leading up to and following a recorded milestone.\n *\n * @param {string} milestoneSnapshotId - The ID of the milestone snapshot\n * @returns {Promise<void>}\n */\nexport async function analyzePatternsAroundMilestone(milestoneSnapshotId) {\n  try {\n    logMessage(\n      \"info\",\n      `[LearningSystem] Analyzing patterns around milestone: ${milestoneSnapshotId}`\n    );\n    // 1. Retrieve the context_snapshots record\n    const snapshotQuery = `SELECT * FROM context_states WHERE milestone_id = ?`;\n    const snapshots = await executeQuery(snapshotQuery, [milestoneSnapshotId]);\n    if (!snapshots || !snapshots.rows || snapshots.rows.length === 0) {\n      logMessage(\n        \"warn\",\n        `[LearningSystem] No context snapshot found for milestone ${milestoneSnapshotId}`\n      );\n      return;\n    }\n\n    const snapshot = snapshots.rows[0];\n    if (!snapshot) {\n      logMessage(\n        \"warn\",\n        `[LearningSystem] Empty snapshot data for milestone ${milestoneSnapshotId}`\n      );\n      return;\n    }\n\n    // Safely extract properties with defaults\n    const created_at = snapshot.created_at || new Date().toISOString();\n    const focus_areas = snapshot.focus_areas || [];\n    const conversation_id = snapshot.conversation_id;\n\n    // Check if we have a valid conversation_id\n    if (!conversation_id) {\n      logMessage(\n        \"warn\",\n        `[LearningSystem] No conversation_id in snapshot for milestone ${milestoneSnapshotId}`\n      );\n      return;\n    }\n\n    const milestoneTime = new Date(created_at).getTime();\n    const windowBeforeMs = 2 * 60 * 60 * 1000; // 2 hours before\n    const windowAfterMs = 1 * 60 * 60 * 1000; // 1 hour after\n    const windowStart = new Date(milestoneTime - windowBeforeMs).toISOString();\n    const windowEnd = new Date(milestoneTime + windowAfterMs).toISOString();\n\n    // 2. Fetch timeline events in the window\n    const eventsQuery = `\n      SELECT * FROM timeline_events\n      WHERE conversation_id = ?\n        AND timestamp >= ?\n        AND timestamp <= ?\n      ORDER BY timestamp ASC\n    `;\n    const events = await executeQuery(eventsQuery, [\n      conversation_id,\n      windowStart,\n      windowEnd,\n    ]);\n\n    // Only proceed if we have events\n    if (!events || !events.rows || events.rows.length === 0) {\n      logMessage(\n        \"info\",\n        `[LearningSystem] No events found in the time window for milestone ${milestoneSnapshotId}`\n      );\n      return;\n    }\n\n    // Access the rows property correctly\n    const eventRows = events.rows || [];\n\n    // 3. Fetch conversation history in the window\n    const historyQuery = `\n      SELECT * FROM conversation_history\n      WHERE conversation_id = ?\n        AND timestamp >= ?\n        AND timestamp <= ?\n      ORDER BY timestamp ASC\n    `;\n    const messages = await executeQuery(historyQuery, [\n      conversation_id,\n      windowStart,\n      windowEnd,\n    ]);\n\n    // Access the rows property correctly\n    const messageRows = messages && messages.rows ? messages.rows : [];\n\n    // 4. Analyze for patterns\n    // a) Common code entities accessed\n    const entityAccessCounts = {};\n    for (const event of eventRows) {\n      if (event.data) {\n        try {\n          const data =\n            typeof event.data === \"string\"\n              ? JSON.parse(event.data)\n              : event.data;\n          if (data.activeFile) {\n            entityAccessCounts[data.activeFile] =\n              (entityAccessCounts[data.activeFile] || 0) + 1;\n          }\n          if (data.relatedFiles && Array.isArray(data.relatedFiles)) {\n            for (const file of data.relatedFiles) {\n              entityAccessCounts[file] = (entityAccessCounts[file] || 0) + 1;\n            }\n          }\n        } catch (err) {\n          // Ignore parse errors\n        }\n      }\n    }\n    // b) Common search queries\n    const searchQueries = eventRows\n      .filter((e) => e.type === \"search_query\")\n      .map((e) => {\n        try {\n          const data = typeof e.data === \"string\" ? JSON.parse(e.data) : e.data;\n          return data && data.query ? data.query : null;\n        } catch {\n          return null;\n        }\n      })\n      .filter(Boolean);\n    // c) Conversation topics/purposes\n    // For simplicity, just count topic_segment_id and purpose_type in messages\n    const topicCounts = {};\n    const purposeCounts = {};\n    for (const msg of messageRows) {\n      if (msg.topic_segment_id) {\n        topicCounts[msg.topic_segment_id] =\n          (topicCounts[msg.topic_segment_id] || 0) + 1;\n      }\n      if (msg.purpose_type) {\n        purposeCounts[msg.purpose_type] =\n          (purposeCounts[msg.purpose_type] || 0) + 1;\n      }\n    }\n\n    // 5. Log insights\n    logMessage(\n      \"info\",\n      `[LearningSystem] Milestone ${milestoneSnapshotId} context analysis:`\n    );\n    logMessage(\"info\", \"  Most accessed code entities:\", {\n      entities: Object.entries(entityAccessCounts)\n        .sort((a, b) => b[1] - a[1])\n        .slice(0, 5),\n    });\n    logMessage(\"info\", \"  Most common search queries:\", {\n      queries: searchQueries.slice(0, 5),\n    });\n    logMessage(\"info\", \"  Most discussed topics:\", {\n      topics: Object.entries(topicCounts)\n        .sort((a, b) => b[1] - a[1])\n        .slice(0, 3),\n    });\n    logMessage(\"info\", \"  Most discussed purposes:\", {\n      purposes: Object.entries(purposeCounts)\n        .sort((a, b) => b[1] - a[1])\n        .slice(0, 3),\n    });\n\n    // 6. Optionally reinforce patterns in project_patterns (not implemented in detail here)\n    // This could update utility_score/confidence_score for patterns related to these entities/topics\n    // ...\n\n    logMessage(\n      \"info\",\n      `[LearningSystem] Analysis around milestone ${milestoneSnapshotId} complete.`\n    );\n  } catch (error) {\n    logMessage(\n      \"error\",\n      `[LearningSystem] Error analyzing patterns around milestone ${milestoneSnapshotId}:`,\n      { error: error.message }\n    );\n  }\n}\n\n/**\n * Analyzes a conversation for patterns when the conversation concludes.\n *\n * @param {string} conversationId - The ID of the conversation to analyze\n * @param {string} outcome - The outcome of the conversation (e.g., 'successful_debug', 'feature_planned')\n * @returns {Promise<void>}\n */\nexport async function analyzeConversationForPatterns(conversationId, outcome) {\n  try {\n    logMessage(\n      \"info\",\n      `[LearningSystem] Analyzing conversation ${conversationId} with outcome: ${outcome}`\n    );\n\n    // 1. Fetch the full conversation history\n    const conversationHistory =\n      await ConversationIntelligence.getConversationHistory(conversationId);\n    if (!conversationHistory || conversationHistory.length === 0) {\n      logMessage(\n        \"info\",\n        `[LearningSystem] No conversation history found for ${conversationId}`\n      );\n      return;\n    }\n\n    logMessage(\n      \"info\",\n      `[LearningSystem] Retrieved ${conversationHistory.length} messages for analysis`\n    );\n\n    // 2. Extract code entities mentioned in the conversation\n    const codeEntityIds = new Set();\n\n    for (const message of conversationHistory) {\n      if (\n        message.related_context_entity_ids &&\n        Array.isArray(message.related_context_entity_ids)\n      ) {\n        message.related_context_entity_ids.forEach((id) =>\n          codeEntityIds.add(id)\n        );\n      }\n    }\n\n    if (codeEntityIds.size === 0) {\n      logMessage(\n        \"info\",\n        `[LearningSystem] No code entities found in conversation ${conversationId}`\n      );\n      return;\n    }\n\n    logMessage(\n      \"info\",\n      `[LearningSystem] Found ${codeEntityIds.size} unique code entities to analyze for patterns`\n    );\n\n    // 3. Fetch full details of each code entity\n    const codeEntities = [];\n    for (const entityId of codeEntityIds) {\n      const entityQuery = `SELECT * FROM code_entities WHERE id = ?`;\n      const [entity] = await executeQuery(entityQuery, [entityId]);\n\n      if (entity) {\n        codeEntities.push(entity);\n      }\n    }\n\n    logMessage(\n      \"info\",\n      `[LearningSystem] Retrieved ${codeEntities.length} code entities for pattern recognition`\n    );\n\n    // 4. For each code entity, recognize patterns\n    for (const entity of codeEntities) {\n      try {\n        // Recognize patterns in the entity\n        const { patterns, confidence } =\n          await SemanticPatternRecognizerLogic.recognizePatterns(entity);\n\n        if (patterns && patterns.length > 0) {\n          logMessage(\n            \"info\",\n            `[LearningSystem] Found ${patterns.length} patterns in entity ${entity.id}`\n          );\n\n          // For each pattern, consider adding to repository if confidence is high\n          for (const pattern of patterns) {\n            if (pattern.confidence && pattern.confidence >= 0.7) {\n              // Add pattern to repository if it's new or interesting\n              await SemanticPatternRecognizerLogic.addPatternToRepository(\n                pattern\n              );\n              logMessage(\n                \"info\",\n                `[LearningSystem] Added pattern ${\n                  pattern.id || pattern.name\n                } to repository`\n              );\n            }\n          }\n        }\n      } catch (error) {\n        logMessage(\n          \"warn\",\n          `[LearningSystem] Error analyzing entity ${entity.id}:`,\n          { error: error.message }\n        );\n      }\n    }\n\n    // 5. If the outcome was successful, reinforce patterns that were likely used\n    if (\n      outcome &&\n      (outcome.includes(\"success\") ||\n        outcome === \"feature_planned\" ||\n        outcome === \"bug_fixed\")\n    ) {\n      // Get all patterns that were recognized during this conversation\n      const patternQuery = `\n        SELECT DISTINCT p.pattern_id \n        FROM project_patterns p\n        JOIN pattern_observations po ON p.pattern_id = po.pattern_id\n        WHERE po.conversation_id = ?\n      `;\n\n      const patternIds = await executeQuery(patternQuery, [conversationId]);\n\n      if (patternIds && patternIds.length > 0) {\n        logMessage(\n          \"info\",\n          `[LearningSystem] Reinforcing ${patternIds.length} patterns based on successful outcome`\n        );\n\n        for (const { pattern_id } of patternIds) {\n          await GlobalPatternRepository.reinforcePattern(\n            pattern_id,\n            \"confirmation\",\n            { conversationId }\n          );\n          logMessage(\n            \"info\",\n            `[LearningSystem] Reinforced pattern ${pattern_id} based on successful outcome`\n          );\n        }\n      }\n    }\n\n    logMessage(\n      \"info\",\n      `[LearningSystem] Completed pattern analysis for conversation ${conversationId}`\n    );\n  } catch (error) {\n    logMessage(\n      \"error\",\n      `[LearningSystem] Error analyzing conversation patterns:`,\n      { error: error.message }\n    );\n  }\n}\n\n/**\n * Promotes session-specific patterns to global patterns for reuse across multiple sessions.\n *\n * @param {string} sessionId - The ID of the session/conversation\n * @param {Object} [filterOptions] - Optional filtering options\n * @param {number} [filterOptions.minConfidence] - Minimum confidence score for patterns to be promoted\n * @returns {Promise<number>} The number of successfully promoted patterns\n */\nexport async function promoteSessionPatternsToGlobal(\n  sessionId,\n  filterOptions = {}\n) {\n  try {\n    logMessage(\n      \"info\",\n      `[LearningSystem] Promoting session patterns to global for session ${sessionId}`\n    );\n\n    // Build the query with filtering options\n    let query = `\n      SELECT * FROM project_patterns \n      WHERE is_global = FALSE \n      AND session_origin_id = ?\n    `;\n\n    const params = [sessionId];\n\n    // Apply minimum confidence filter if provided\n    if (filterOptions.minConfidence !== undefined) {\n      query += ` AND confidence_score >= ?`;\n      params.push(filterOptions.minConfidence);\n    }\n\n    // Execute the query to get qualifying patterns\n    const patterns = await executeQuery(query, params);\n\n    if (!patterns || patterns.length === 0) {\n      console.log(\n        `[LearningSystem] No qualifying session patterns found for promotion in session ${sessionId}`\n      );\n      return 0;\n    }\n\n    console.log(\n      `[LearningSystem] Found ${patterns.length} session patterns qualifying for promotion to global`\n    );\n\n    // Counter for successfully promoted patterns\n    let promotedCount = 0;\n\n    // Promote each qualifying pattern\n    for (const pattern of patterns) {\n      try {\n        await GlobalPatternRepository.promotePatternToGlobal(\n          pattern.pattern_id,\n          pattern.confidence_score\n        );\n\n        promotedCount++;\n        console.log(\n          `[LearningSystem] Successfully promoted pattern ${pattern.pattern_id} to global`\n        );\n      } catch (error) {\n        console.warn(\n          `[LearningSystem] Error promoting pattern ${pattern.pattern_id} to global:`,\n          error\n        );\n        // Continue with the next pattern even if one fails\n      }\n    }\n\n    console.log(\n      `[LearningSystem] Completed pattern promotion. ${promotedCount}/${patterns.length} patterns promoted successfully`\n    );\n    return promotedCount;\n  } catch (error) {\n    console.error(\n      `[LearningSystem] Error promoting session patterns to global:`,\n      error\n    );\n    return 0;\n  }\n}\n\n/**\n * Enriches context with applicable global patterns\n *\n * @param {Array} context - An array of CodeEntity or ContextSnippet objects\n * @param {Object} [filterOptions] - Optional filtering options for patterns\n * @param {number} [filterOptions.minConfidence] - Minimum confidence score for patterns to consider\n * @returns {Promise<Array>} The enriched context with matched global patterns\n */\nexport async function applyGlobalPatternsToContext(\n  context,\n  filterOptions = {}\n) {\n  try {\n    console.log(`[LearningSystem] Enriching context with global patterns`);\n\n    if (!context || !Array.isArray(context) || context.length === 0) {\n      console.log(\n        `[LearningSystem] No context items provided for pattern enrichment`\n      );\n      return context;\n    }\n\n    // 1. Retrieve relevant global patterns using GlobalPatternRepository\n    const globalPatterns = await GlobalPatternRepository.retrieveGlobalPatterns(\n      filterOptions\n    );\n\n    if (!globalPatterns || globalPatterns.length === 0) {\n      console.log(\n        `[LearningSystem] No global patterns found with the specified criteria`\n      );\n      return context;\n    }\n\n    console.log(\n      `[LearningSystem] Retrieved ${globalPatterns.length} global patterns for matching`\n    );\n\n    // 2. For each item in the context, try to match global patterns\n    const enrichedContext = await Promise.all(\n      context.map(async (item) => {\n        // Create a copy of the item to avoid mutating the original\n        const enrichedItem = { ...item, matched_global_patterns: [] };\n\n        // Extract necessary content from item (could be a CodeEntity or ContextSnippet)\n        const content =\n          item.content || item.raw_content || item.summarizedContent;\n\n        if (!content) {\n          return enrichedItem; // Skip if no content available\n        }\n\n        // Get the item type (for type-specific pattern matching)\n        const itemType = item.type || \"unknown\";\n\n        // Extract textual features for pattern matching\n        const tokenizedContent = TextTokenizerLogic.tokenize(content);\n        const keywords = TextTokenizerLogic.extractKeywords(tokenizedContent);\n\n        // Try to extract or use provided structural features\n        let structuralFeatures = item.custom_metadata?.structuralFeatures || {};\n\n        // For each global pattern, attempt to match against this item\n        const matchPromises = globalPatterns.map(async (pattern) => {\n          try {\n            // Similar to matchPattern in SemanticPatternRecognizerLogic but simplified\n            const { detection_rules } = pattern;\n            let textualMatchScore = 0;\n            let structuralMatchScore = 0;\n            let typeMatchScore = 0;\n\n            // Check if pattern applies to this item type\n            if (\n              detection_rules.applicable_types &&\n              Array.isArray(detection_rules.applicable_types)\n            ) {\n              typeMatchScore = detection_rules.applicable_types.includes(\n                itemType\n              )\n                ? 1\n                : 0;\n\n              // If pattern explicitly doesn't apply to this type and strict matching is enabled, skip\n              if (\n                typeMatchScore === 0 &&\n                detection_rules.strict_type_matching\n              ) {\n                return { pattern, confidence: 0 };\n              }\n            } else {\n              // If no type restrictions, full score\n              typeMatchScore = 1;\n            }\n\n            // Perform textual matching with keywords\n            if (\n              detection_rules.keywords &&\n              Array.isArray(detection_rules.keywords)\n            ) {\n              const keywordMatches = detection_rules.keywords.filter(\n                (keyword) =>\n                  keywords.some((k) =>\n                    typeof k === \"string\"\n                      ? k === keyword\n                      : k.keyword === keyword\n                  )\n              );\n\n              textualMatchScore =\n                keywordMatches.length / detection_rules.keywords.length;\n            }\n\n            // Check for text patterns\n            if (\n              detection_rules.text_patterns &&\n              Array.isArray(detection_rules.text_patterns)\n            ) {\n              let patternMatchCount = 0;\n\n              for (const textPattern of detection_rules.text_patterns) {\n                if (typeof textPattern === \"string\") {\n                  if (content.includes(textPattern)) {\n                    patternMatchCount++;\n                  }\n                } else if (\n                  textPattern instanceof RegExp ||\n                  (typeof textPattern === \"object\" && textPattern.pattern)\n                ) {\n                  // Handle regex pattern objects\n                  const patternObj =\n                    textPattern instanceof RegExp\n                      ? textPattern\n                      : new RegExp(\n                          textPattern.pattern,\n                          textPattern.flags || \"\"\n                        );\n\n                  if (patternObj.test(content)) {\n                    patternMatchCount++;\n                  }\n                }\n              }\n\n              const textPatternScore =\n                detection_rules.text_patterns.length > 0\n                  ? patternMatchCount / detection_rules.text_patterns.length\n                  : 0;\n\n              // Combine with keyword score\n              textualMatchScore =\n                textualMatchScore > 0\n                  ? (textualMatchScore + textPatternScore) / 2\n                  : textPatternScore;\n            }\n\n            // Perform structural matching if we have structural rules and features\n            if (\n              detection_rules.structural_rules &&\n              Array.isArray(detection_rules.structural_rules) &&\n              Object.keys(structuralFeatures).length > 0\n            ) {\n              let structRuleMatchCount = 0;\n\n              for (const rule of detection_rules.structural_rules) {\n                const { feature, condition, value } = rule;\n\n                // Skip invalid rules\n                if (!feature || !condition || value === undefined) continue;\n\n                // Get the actual feature value\n                const featureValue = structuralFeatures[feature];\n\n                // Skip if feature doesn't exist\n                if (featureValue === undefined) continue;\n\n                // Evaluate condition\n                let matches = false;\n\n                switch (condition) {\n                  case \"equals\":\n                    matches = featureValue === value;\n                    break;\n                  case \"contains\":\n                    matches = Array.isArray(featureValue)\n                      ? featureValue.includes(value)\n                      : String(featureValue).includes(String(value));\n                    break;\n                  case \"greater_than\":\n                    matches = Number(featureValue) > Number(value);\n                    break;\n                  case \"less_than\":\n                    matches = Number(featureValue) < Number(value);\n                    break;\n                  case \"matches_regex\":\n                    matches = new RegExp(value).test(String(featureValue));\n                    break;\n                  default:\n                    matches = false;\n                }\n\n                if (matches) {\n                  structRuleMatchCount++;\n                }\n              }\n\n              structuralMatchScore =\n                detection_rules.structural_rules.length > 0\n                  ? structRuleMatchCount /\n                    detection_rules.structural_rules.length\n                  : 0;\n            }\n\n            // Calculate combined confidence\n            const weights = detection_rules.weights || {\n              textual: 0.6, // Give more weight to textual matching for context items\n              structural: 0.3,\n              type: 0.1,\n            };\n\n            // Calculate weighted average\n            const confidence =\n              textualMatchScore * weights.textual +\n              structuralMatchScore * weights.structural +\n              typeMatchScore * weights.type;\n\n            return {\n              pattern,\n              confidence,\n              textualMatchScore,\n              structuralMatchScore,\n              typeMatchScore,\n            };\n          } catch (error) {\n            console.warn(\n              `[LearningSystem] Error matching pattern ${pattern.pattern_id}:`,\n              error\n            );\n            return { pattern, confidence: 0 };\n          }\n        });\n\n        // Wait for all pattern matching to complete\n        const matchResults = await Promise.all(matchPromises);\n\n        // Filter for patterns with significant match confidence and sort by confidence\n        const significantMatches = matchResults\n          .filter((result) => result.confidence > 0.3) // Only include significant matches\n          .sort((a, b) => b.confidence - a.confidence);\n\n        // Add matched patterns to the enriched item\n        if (significantMatches.length > 0) {\n          enrichedItem.matched_global_patterns = significantMatches.map(\n            (match) => ({\n              pattern_id: match.pattern.pattern_id,\n              pattern_type: match.pattern.pattern_type,\n              name: match.pattern.name,\n              description: match.pattern.description,\n              confidence: match.confidence,\n              match_details: {\n                textual_score: match.textualMatchScore,\n                structural_score: match.structuralMatchScore,\n                type_score: match.typeMatchScore,\n              },\n            })\n          );\n\n          console.log(\n            `[LearningSystem] Found ${\n              enrichedItem.matched_global_patterns.length\n            } matching patterns for item ${\n              item.id || item.entity_id || \"unknown\"\n            }`\n          );\n        }\n\n        return enrichedItem;\n      })\n    );\n\n    console.log(\n      `[LearningSystem] Completed context enrichment with global patterns`\n    );\n    return enrichedContext;\n  } catch (error) {\n    console.error(\n      `[LearningSystem] Error applying global patterns to context:`,\n      error\n    );\n    // In case of error, return the original context to avoid data loss\n    return context;\n  }\n}\n\n/**\n * Records pattern application success or failure for reinforcement learning\n *\n * @param {string} patternId - The ID of the pattern that was applied\n * @param {boolean} successful - Whether the pattern application was successful\n * @param {string} [conversationId] - Optional ID of the conversation where pattern was applied\n * @param {string[]} [contextEntities] - Optional array of entity IDs related to the pattern application\n * @returns {Promise<void>}\n */\nexport async function registerPatternObservation(\n  patternId,\n  successful,\n  conversationId,\n  contextEntities\n) {\n  try {\n    console.log(\n      `[LearningSystem] Registering pattern observation for ${patternId} (successful: ${successful})`\n    );\n\n    // Determine observation type based on success\n    const observationType = successful ? \"confirmation\" : \"rejection\";\n\n    // Prepare context data object with any provided context information\n    const contextData = {\n      conversationId,\n      entities: contextEntities,\n    };\n\n    // Call GlobalPatternRepository to reinforce the pattern\n    await GlobalPatternRepository.reinforcePattern(\n      patternId,\n      observationType,\n      contextData\n    );\n\n    console.log(\n      `[LearningSystem] Successfully registered ${observationType} observation for pattern ${patternId}`\n    );\n  } catch (error) {\n    console.error(\n      `[LearningSystem] Error registering pattern observation:`,\n      error\n    );\n  }\n}\n\n/**\n * Extracts patterns from a conversation by analyzing messages and related code entities\n *\n * @param {string} conversationId - The ID of the conversation to analyze\n * @returns {Promise<Array>} Array of patterns found in the conversation\n */\nexport async function extractPatternsFromConversation(conversationId) {\n  try {\n    console.log(\n      `[LearningSystem] Extracting patterns from conversation ${conversationId}`\n    );\n\n    // 1. Fetch the complete conversation history\n    const conversationHistory =\n      await ConversationIntelligence.getConversationHistory(conversationId);\n    if (!conversationHistory || conversationHistory.length === 0) {\n      console.log(\n        `[LearningSystem] No conversation history found for ${conversationId}`\n      );\n      return [];\n    }\n\n    // 2. Extract unique code entity IDs mentioned in the conversation\n    const codeEntityIds = new Set();\n    for (const message of conversationHistory) {\n      if (\n        message.related_context_entity_ids &&\n        Array.isArray(message.related_context_entity_ids)\n      ) {\n        message.related_context_entity_ids.forEach((id) =>\n          codeEntityIds.add(id)\n        );\n      }\n    }\n\n    if (codeEntityIds.size === 0) {\n      console.log(\n        `[LearningSystem] No code entities found in conversation ${conversationId}`\n      );\n      return [];\n    }\n\n    // 3. Fetch details of each entity from the database\n    const codeEntities = [];\n    for (const entityId of codeEntityIds) {\n      const entityQuery = `SELECT * FROM code_entities WHERE id = ?`;\n      const entityResults = await executeQuery(entityQuery, [entityId]);\n\n      if (entityResults && entityResults.length > 0) {\n        codeEntities.push(entityResults[0]);\n      }\n    }\n\n    // 4. Use SemanticPatternRecognizerLogic to find patterns in each entity\n    const recognizedPatternIds = new Set();\n\n    for (const entity of codeEntities) {\n      try {\n        const { patterns } =\n          await SemanticPatternRecognizerLogic.recognizePatterns(entity);\n\n        if (patterns && patterns.length > 0) {\n          patterns.forEach((pattern) => {\n            if (pattern.pattern_id) {\n              recognizedPatternIds.add(pattern.pattern_id);\n            }\n          });\n        }\n      } catch (error) {\n        console.warn(\n          `[LearningSystem] Error recognizing patterns in entity ${entity.id}:`,\n          error\n        );\n      }\n    }\n\n    // 5. Fetch full pattern details from the project_patterns table\n    if (recognizedPatternIds.size === 0) {\n      console.log(\n        `[LearningSystem] No patterns recognized in conversation ${conversationId}`\n      );\n      return [];\n    }\n\n    // Convert Set to array for the IN clause\n    const patternIdArray = Array.from(recognizedPatternIds);\n\n    // Build placeholders for the IN clause\n    const placeholders = patternIdArray.map(() => \"?\").join(\",\");\n\n    const patternsQuery = `\n      SELECT * FROM project_patterns \n      WHERE pattern_id IN (${placeholders})\n      ORDER BY confidence_score DESC\n    `;\n\n    const patterns = await executeQuery(patternsQuery, patternIdArray);\n\n    console.log(\n      `[LearningSystem] Found ${patterns.length} patterns in conversation ${conversationId}`\n    );\n\n    // Parse detection_rules JSON field and return patterns\n    return patterns.map((pattern) => ({\n      ...pattern,\n      detection_rules: pattern.detection_rules\n        ? JSON.parse(pattern.detection_rules)\n        : {},\n      is_global: Boolean(pattern.is_global),\n    }));\n  } catch (error) {\n    console.error(\n      `[LearningSystem] Error extracting patterns from conversation:`,\n      error\n    );\n    return [];\n  }\n}\n\n/**\n * Extracts bug patterns from conversation messages by analyzing text for error messages and solutions\n *\n * @param {string} conversationId - The ID of the conversation to analyze\n * @returns {Promise<Array>} Array of bug patterns with descriptions and confidence scores\n */\nexport async function extractBugPatterns(conversationId) {\n  try {\n    console.log(\n      `[LearningSystem] Extracting bug patterns from conversation ${conversationId}`\n    );\n\n    // 1. Fetch all messages from the conversation\n    const messages = await ConversationIntelligence.getConversationHistory(\n      conversationId\n    );\n    if (!messages || messages.length === 0) {\n      return [];\n    }\n\n    // 2. Define regex patterns for identifying bug-related content\n    const errorPatterns = [\n      /error:?\\s+([^\\n.]+)/i,\n      /exception:?\\s+([^\\n.]+)/i,\n      /failed\\s+(?:to|with):?\\s+([^\\n.]+)/i,\n      /bug:?\\s+([^\\n.]+)/i,\n      /issue:?\\s+([^\\n.]+)/i,\n      /problem:?\\s+([^\\n.]+)/i,\n    ];\n\n    const fixPatterns = [\n      /fix(?:ed|ing)?:?\\s+([^\\n.]+)/i,\n      /solv(?:ed|ing)?:?\\s+([^\\n.]+)/i,\n      /resolv(?:ed|ing)?:?\\s+([^\\n.]+)/i,\n      /solutions?:?\\s+([^\\n.]+)/i,\n      /workaround:?\\s+([^\\n.]+)/i,\n      /(?:the\\s+)?(?:root\\s+)?cause\\s+(?:is|was):?\\s+([^\\n.]+)/i,\n    ];\n\n    // 3. Analyze each message for bug patterns\n    const bugDescriptions = [];\n    const bugSolutions = [];\n\n    for (const message of messages) {\n      const content = message.content;\n      if (!content) continue;\n\n      // Look for error/bug descriptions\n      for (const pattern of errorPatterns) {\n        const matches = content.match(pattern);\n        if (matches && matches[1]) {\n          bugDescriptions.push({\n            description: matches[1].trim(),\n            confidence: 0.7,\n            messageId: message.message_id,\n            type: \"error\",\n          });\n        }\n      }\n\n      // Look for fix/solution descriptions\n      for (const pattern of fixPatterns) {\n        const matches = content.match(pattern);\n        if (matches && matches[1]) {\n          bugSolutions.push({\n            description: matches[1].trim(),\n            confidence: 0.7,\n            messageId: message.message_id,\n            type: \"solution\",\n          });\n        }\n      }\n\n      // Look for code blocks with error messages or stacktraces\n      const codeBlockMatches = content.match(/```[\\s\\S]*?```/g);\n      if (codeBlockMatches) {\n        for (const codeBlock of codeBlockMatches) {\n          // If code block contains error-related keywords\n          if (/error|exception|traceback|fail|bug|issue/i.test(codeBlock)) {\n            bugDescriptions.push({\n              description:\n                codeBlock.replace(/```/g, \"\").trim().substring(0, 100) + \"...\",\n              confidence: 0.8,\n              messageId: message.message_id,\n              type: \"code_error\",\n            });\n          }\n        }\n      }\n    }\n\n    // 4. Match bug descriptions with their solutions when possible\n    const bugPatterns = [];\n\n    // For each bug description, try to find a related solution\n    for (const bug of bugDescriptions) {\n      // Create tokens from the bug description\n      const bugTokens = TextTokenizerLogic.tokenize(bug.description);\n      const bugKeywords = TextTokenizerLogic.extractKeywords(bugTokens);\n\n      // Find solutions with matching keywords\n      let bestSolution = null;\n      let bestScore = 0;\n\n      for (const solution of bugSolutions) {\n        const solutionTokens = TextTokenizerLogic.tokenize(\n          solution.description\n        );\n        const solutionKeywords =\n          TextTokenizerLogic.extractKeywords(solutionTokens);\n\n        // Calculate simple relevance score (keyword overlap)\n        let matchScore = 0;\n        for (const bugKeyword of bugKeywords) {\n          if (solutionKeywords.includes(bugKeyword)) {\n            matchScore++;\n          }\n        }\n\n        if (matchScore > bestScore) {\n          bestScore = matchScore;\n          bestSolution = solution;\n        }\n      }\n\n      // Add the bug pattern, with solution if found\n      bugPatterns.push({\n        description: bug.description,\n        confidence: bug.confidence,\n        solution: bestSolution ? bestSolution.description : undefined,\n        relatedIssues: [], // Would require additional lookup to find related issues\n      });\n    }\n\n    // Add any solutions without a matched bug as standalone patterns (with lower confidence)\n    for (const solution of bugSolutions) {\n      // Check if we've already used this solution\n      const alreadyUsed = bugPatterns.some(\n        (bp) => bp.solution === solution.description\n      );\n      if (!alreadyUsed) {\n        bugPatterns.push({\n          description: `Solution: ${solution.description}`,\n          confidence: 0.6,\n          relatedIssues: [],\n        });\n      }\n    }\n\n    // Remove duplicates by comparing descriptions\n    const seenDescriptions = new Set();\n    const uniquePatterns = [];\n\n    for (const pattern of bugPatterns) {\n      if (!seenDescriptions.has(pattern.description)) {\n        seenDescriptions.add(pattern.description);\n        uniquePatterns.push(pattern);\n      }\n    }\n\n    console.log(\n      `[LearningSystem] Extracted ${uniquePatterns.length} bug patterns from conversation ${conversationId}`\n    );\n    return uniquePatterns;\n  } catch (error) {\n    console.error(`[LearningSystem] Error extracting bug patterns:`, error);\n    return [];\n  }\n}\n\n/**\n * Extracts design decisions from conversation by identifying discussion of choices and tradeoffs\n *\n * @param {string} conversationId - The ID of the conversation to analyze\n * @returns {Promise<Array>} Array of design decisions with descriptions and confidence scores\n */\nexport async function extractDesignDecisions(conversationId) {\n  try {\n    console.log(\n      `[LearningSystem] Extracting design decisions from conversation ${conversationId}`\n    );\n\n    // 1. Fetch all messages from the conversation\n    const messages = await ConversationIntelligence.getConversationHistory(\n      conversationId\n    );\n    if (!messages || messages.length === 0) {\n      return [];\n    }\n\n    // 2. Define patterns for identifying design discussions\n    const designPatterns = [\n      /(?:I|we)\\s+(?:chose|decided|selected|opted|will use|should use)\\s+([^.]+)(?:\\s+because|for|to)\\s+([^.]+)/i,\n      /(?:the|a)\\s+(?:better|best|optimal|appropriate|right)\\s+(?:approach|design|solution|pattern|architecture)\\s+(?:is|would be)\\s+([^.]+)/i,\n      /(?:advantages|benefits|pros)\\s+of\\s+([^.]+)(?:\\s+(?:are|include))\\s+([^.]+)/i,\n      /(?:disadvantages|drawbacks|cons)\\s+of\\s+([^.]+)(?:\\s+(?:are|include))\\s+([^.]+)/i,\n      /(?:comparing|between)\\s+([^\\s.]+)\\s+and\\s+([^\\s.]+),\\s+([^.]+)/i,\n      /(?:I|we)\\s+recommend\\s+([^.]+)(?:\\s+because|for|to)\\s+([^.]+)/i,\n    ];\n\n    const alternativePatterns = [\n      /(?:alternative|another|other)\\s+(?:approach|option|solution)\\s+(?:would be|is|could be)\\s+([^.]+)/i,\n      /(?:instead of|rather than)\\s+([^,]+),\\s+(?:we could|we should|we might|you could|you should|you might)\\s+([^.]+)/i,\n      /(?:we|you)\\s+(?:could|should|might)\\s+(?:also|instead|alternatively)\\s+(?:consider|use|try)\\s+([^.]+)/i,\n    ];\n\n    const rationalePatterns = [\n      /(?:because|since|as|given that)\\s+([^,.]+)/i,\n      /(?:the|a)\\s+(?:reason|rationale|justification)\\s+(?:is|was|being)\\s+([^.]+)/i,\n      /(?:this|that)\\s+(?:approach|solution|design|pattern|choice|decision)\\s+(?:helps|allows|enables|provides|ensures)\\s+([^.]+)/i,\n    ];\n\n    // 3. Extract design decisions from messages\n    const designDecisions = [];\n\n    for (const message of messages) {\n      const content = message.content;\n      if (!content) continue;\n\n      // Split content into sentences for more precise pattern matching\n      const sentences = content.split(/[.!?]\\s+/);\n\n      for (let i = 0; i < sentences.length; i++) {\n        const sentence = sentences[i];\n\n        // Look for design decision patterns\n        for (const pattern of designPatterns) {\n          const matches = sentence.match(pattern);\n          if (matches && matches.length > 1) {\n            // Found a design decision\n            const description = matches[1].trim();\n\n            // Look for rationale in the same sentence or following sentences\n            let rationale = matches[2] ? matches[2].trim() : \"\";\n\n            // If no rationale found in the match, check the next sentence\n            if (!rationale && i < sentences.length - 1) {\n              const nextSentence = sentences[i + 1];\n              for (const rationalePattern of rationalePatterns) {\n                const rationaleMatch = nextSentence.match(rationalePattern);\n                if (rationaleMatch && rationaleMatch[1]) {\n                  rationale = rationaleMatch[1].trim();\n                  break;\n                }\n              }\n            }\n\n            // Look for alternatives in nearby sentences\n            let alternatives = [];\n\n            // Check a window of 3 sentences before and after\n            const windowStart = Math.max(0, i - 3);\n            const windowEnd = Math.min(sentences.length - 1, i + 3);\n\n            for (let j = windowStart; j <= windowEnd; j++) {\n              if (j === i) continue; // Skip the current sentence\n\n              const nearbySentence = sentences[j];\n              for (const altPattern of alternativePatterns) {\n                const altMatch = nearbySentence.match(altPattern);\n                if (altMatch && altMatch.length > 1) {\n                  // Found an alternative\n                  if (altMatch[2]) {\n                    alternatives.push(altMatch[2].trim());\n                  } else if (altMatch[1]) {\n                    alternatives.push(altMatch[1].trim());\n                  }\n                }\n              }\n            }\n\n            // Assign confidence based on completeness of the decision\n            let confidence = 0.7; // Base confidence\n            if (rationale) confidence += 0.1;\n            if (alternatives.length > 0) confidence += 0.1;\n\n            designDecisions.push({\n              description,\n              confidence,\n              rationale: rationale || undefined,\n              alternatives: alternatives.length > 0 ? alternatives : undefined,\n              messageId: message.message_id,\n            });\n          }\n        }\n      }\n    }\n\n    // Remove duplicates\n    const uniqueDecisions = [];\n    const seenDescriptions = new Set();\n\n    for (const decision of designDecisions) {\n      if (!seenDescriptions.has(decision.description)) {\n        seenDescriptions.add(decision.description);\n        uniqueDecisions.push(decision);\n      }\n    }\n\n    console.log(\n      `[LearningSystem] Extracted ${uniqueDecisions.length} design decisions from conversation ${conversationId}`\n    );\n    return uniqueDecisions;\n  } catch (error) {\n    console.error(`[LearningSystem] Error extracting design decisions:`, error);\n    return [];\n  }\n}\n\n/**\n * Extracts best practices mentioned in conversation\n *\n * @param {string} conversationId - The ID of the conversation to analyze\n * @returns {Promise<Array>} Array of best practices with descriptions and confidence scores\n */\nexport async function extractBestPractices(conversationId) {\n  try {\n    console.log(\n      `[LearningSystem] Extracting best practices from conversation ${conversationId}`\n    );\n\n    // 1. Fetch all messages from the conversation\n    const messages = await ConversationIntelligence.getConversationHistory(\n      conversationId\n    );\n    if (!messages || messages.length === 0) {\n      return [];\n    }\n\n    // 2. Define patterns for identifying best practices\n    const bestPracticePatterns = [\n      /(?:best|good)\\s+practice[s]?\\s+(?:is|are|for|to)\\s+([^.]+)/i,\n      /(?:recommended|suggested|advisable)\\s+(?:approach|practice|method|way)\\s+(?:is|would be)\\s+([^.]+)/i,\n      /(?:should|must|always|never)\\s+([^.]+)/i,\n      /(?:it['']s|its)\\s+(?:better|best|recommended)\\s+to\\s+([^.]+)/i,\n      /(?:convention|standard|norm|guideline|rule)\\s+(?:is|dictates|suggests|recommends|states)\\s+([^.]+)/i,\n      /(?:important|critical|essential|key)\\s+to\\s+([^.]+)/i,\n    ];\n\n    // 3. Extract best practices from messages\n    const bestPractices = [];\n    let messageIdToPractices = {};\n\n    for (const message of messages) {\n      const content = message.content;\n      if (!content) continue;\n\n      // Split content into sentences for more precise pattern matching\n      const sentences = content.split(/[.!?]\\s+/);\n\n      for (const sentence of sentences) {\n        for (const pattern of bestPracticePatterns) {\n          const matches = sentence.match(pattern);\n          if (matches && matches[1]) {\n            const description = matches[1].trim();\n\n            // Assign confidence based on the strength of the pattern\n            let confidence = 0.6; // Base confidence\n\n            // Adjust confidence based on keywords\n            if (/best practice|always|never|must|essential/i.test(sentence)) {\n              confidence += 0.2;\n            } else if (/should|recommended|better|important/i.test(sentence)) {\n              confidence += 0.1;\n            }\n\n            // Store practices with their message ID for later reference extraction\n            if (!messageIdToPractices[message.message_id]) {\n              messageIdToPractices[message.message_id] = [];\n            }\n\n            messageIdToPractices[message.message_id].push({\n              description,\n              confidence,\n              messageId: message.message_id,\n            });\n          }\n        }\n      }\n    }\n\n    // 4. For each message with best practices, look for code references\n    for (const messageId in messageIdToPractices) {\n      const message = messages.find((m) => m.message_id === messageId);\n      if (!message) continue;\n\n      // Look for code blocks in the message\n      const codeBlocks = message.content.match(/```[\\s\\S]*?```/g) || [];\n      const codeReferences = codeBlocks.map((block) =>\n        block.replace(/```/g, \"\").trim()\n      );\n\n      // Add code references to each practice from this message\n      for (const practice of messageIdToPractices[messageId]) {\n        if (codeReferences.length > 0) {\n          practice.codeReferences = codeReferences;\n          // Boost confidence if code examples are provided\n          practice.confidence = Math.min(0.9, practice.confidence + 0.1);\n        }\n\n        bestPractices.push(practice);\n      }\n    }\n\n    // 5. Remove duplicates\n    const uniquePractices = [];\n    const seenDescriptions = new Set();\n\n    for (const practice of bestPractices) {\n      if (!seenDescriptions.has(practice.description)) {\n        seenDescriptions.add(practice.description);\n        uniquePractices.push(practice);\n      }\n    }\n\n    console.log(\n      `[LearningSystem] Extracted ${uniquePractices.length} best practices from conversation ${conversationId}`\n    );\n    return uniquePractices;\n  } catch (error) {\n    console.error(`[LearningSystem] Error extracting best practices:`, error);\n    return [];\n  }\n}\n\n/**\n * Extracts general learning points from conversation messages\n *\n * @param {string[]} messageContents - Array of message contents to analyze\n * @returns {Promise<Array>} Array of general learnings with text and confidence scores\n */\nexport async function extractGeneralLearnings(messageContents) {\n  try {\n    console.log(\n      `[LearningSystem] Extracting general learnings from ${messageContents.length} messages`\n    );\n\n    if (\n      !messageContents ||\n      !Array.isArray(messageContents) ||\n      messageContents.length === 0\n    ) {\n      return [];\n    }\n\n    // 1. Define patterns for identifying factual statements and key takeaways\n    const learningPatterns = [\n      /(?:in\\s+(?:conclusion|summary)|to\\s+summarize|summing\\s+up|overall|in\\s+essence),\\s+([^.]+)/i,\n      /(?:the\\s+(?:key|main|important|critical|essential)\\s+(?:point|takeaway|learning|insight|fact|thing to remember))\\s+(?:is|was|would be)\\s+([^.]+)/i,\n      /(?:I|we|you)\\s+(?:learned|discovered|found out|realized|understand|know)\\s+(?:that|how|why)\\s+([^.]+)/i,\n      /(?:it['']s|its)\\s+(?:worth|important|useful|helpful)\\s+(?:noting|remembering|understanding|recognizing)\\s+(?:that|how|why)\\s+([^.]+)/i,\n      /(?:fact|truth|reality|principle|rule|concept|discovery|revelation|insight):\\s+([^.]+)/i,\n    ];\n\n    // Patterns that might indicate conclusion statements\n    const conclusionIndicators = [\n      /(?:in\\s+(?:conclusion|summary)|to\\s+summarize|summing\\s+up|finally|lastly)/i,\n      /(?:key|main|important|critical)\\s+(?:point|takeaway|lesson|learning)/i,\n      /(?:remember|note|understand|fundamental|essentially)/i,\n    ];\n\n    // 2. Extract learnings from each message\n    const generalLearnings = [];\n\n    for (let i = 0; i < messageContents.length; i++) {\n      const content = messageContents[i];\n      if (!content) continue;\n\n      // Split content into sentences\n      const sentences = content.split(/[.!?]\\s+/);\n\n      // Check each sentence for learning patterns\n      for (let j = 0; j < sentences.length; j++) {\n        const sentence = sentences[j];\n        let learning = null;\n        let confidenceScore = 0;\n\n        // Check for explicit learning patterns\n        for (const pattern of learningPatterns) {\n          const matches = sentence.match(pattern);\n          if (matches && matches[1]) {\n            learning = matches[1].trim();\n            confidenceScore = 0.8; // High confidence for explicit patterns\n            break;\n          }\n        }\n\n        // If no explicit pattern matched, check if this might be a conclusion in the last 25% of the message\n        if (!learning && j > sentences.length * 0.75) {\n          // Check for conclusion indicators\n          for (const indicator of conclusionIndicators) {\n            if (indicator.test(sentence)) {\n              learning = sentence.trim();\n              confidenceScore = 0.7; // Slightly lower confidence\n              break;\n            }\n          }\n        }\n\n        // If still no match, check for declarative statements that might be factual\n        if (\n          !learning &&\n          /^(?:the|a|this|these|those)\\s+\\w+\\s+(?:is|are|was|were|has|have|had)\\s+/i.test(\n            sentence\n          )\n        ) {\n          // Look for strong factual indicators\n          if (\n            /always|never|every|all|none|must|proven|demonstrated|shown|verified|confirmed/i.test(\n              sentence\n            )\n          ) {\n            learning = sentence.trim();\n            confidenceScore = 0.6; // Medium confidence\n          }\n        }\n\n        // Add the learning if found\n        if (learning) {\n          generalLearnings.push({\n            text: learning,\n            confidence: confidenceScore,\n            messageId: `message_${i}`, // Using index as we don't have actual messageIds\n          });\n        }\n      }\n    }\n\n    // 3. Remove duplicates and very short learnings\n    const uniqueLearnings = [];\n    const seenTexts = new Set();\n\n    for (const learning of generalLearnings) {\n      if (learning.text.length < 10) continue; // Skip very short learnings\n\n      if (!seenTexts.has(learning.text)) {\n        seenTexts.add(learning.text);\n        uniqueLearnings.push(learning);\n      }\n    }\n\n    console.log(\n      `[LearningSystem] Extracted ${uniqueLearnings.length} general learnings from messages`\n    );\n    return uniqueLearnings;\n  } catch (error) {\n    console.error(\n      `[LearningSystem] Error extracting general learnings:`,\n      error\n    );\n    return [];\n  }\n}\n\n/**\n * Extracts key-value pairs of knowledge from a collection of messages\n *\n * @param {Array<Object>} messages - Array of message objects\n * @param {string} conversationId - ID of the conversation\n * @returns {Promise<Array<{key: string, value: string, confidence: number}>>} Array of extracted key-value pairs\n */\nexport async function extractKeyValuePairs(messages, conversationId) {\n  try {\n    console.log(\n      `[LearningSystem] Extracting key-value pairs from conversation ${conversationId}`\n    );\n\n    if (!messages || messages.length === 0) {\n      console.log(\n        \"[LearningSystem] No messages provided for key-value extraction\"\n      );\n      return [];\n    }\n\n    // Get the text content from messages\n    const messageContents = messages\n      .map((msg) => msg.content || \"\")\n      .filter((content) => content.trim().length > 0);\n\n    if (messageContents.length === 0) {\n      return [];\n    }\n\n    // Simple heuristic extraction of key-value pairs\n    // Look for patterns like \"X: Y\", \"X - Y\", \"key is value\", etc.\n    const extractedPairs = [];\n\n    for (const content of messageContents) {\n      // Process common patterns\n      // Pattern 1: \"Key: Value\" or \"Key - Value\"\n      const colonPattern = /^([^:]+):\\s*(.+)$/gm;\n      let match;\n\n      while ((match = colonPattern.exec(content)) !== null) {\n        const key = match[1].trim();\n        const value = match[2].trim();\n\n        if (key && value && key.length < 100 && !key.includes(\"\\n\")) {\n          extractedPairs.push({\n            key,\n            value,\n            confidence: 0.8,\n          });\n        }\n      }\n\n      // Pattern 2: \"The X is Y\" or \"X is Y\"\n      const isPattern = /(?:The\\s+)?([A-Za-z0-9\\s_-]+)\\s+is\\s+([^.]+)/g;\n\n      while ((match = isPattern.exec(content)) !== null) {\n        const key = match[1].trim();\n        const value = match[2].trim();\n\n        if (key && value && key.length < 50 && !key.includes(\"\\n\")) {\n          extractedPairs.push({\n            key,\n            value,\n            confidence: 0.6,\n          });\n        }\n      }\n    }\n\n    // Deduplicate by key (keep highest confidence)\n    const keyMap = new Map();\n\n    for (const pair of extractedPairs) {\n      const existingPair = keyMap.get(pair.key.toLowerCase());\n\n      if (!existingPair || existingPair.confidence < pair.confidence) {\n        keyMap.set(pair.key.toLowerCase(), pair);\n      }\n    }\n\n    // Convert back to array\n    return Array.from(keyMap.values());\n  } catch (error) {\n    console.error(\"[LearningSystem] Error extracting key-value pairs:\", error);\n    return [];\n  }\n}\n\n/**\n * Stores a code pattern in the database\n *\n * @param {Object} pattern - The pattern to store\n * @param {string} pattern.name - Name of the pattern\n * @param {string} pattern.description - Description of the pattern\n * @param {string} pattern.representation - String representation of the pattern\n * @param {string} pattern.category - Category of the pattern\n * @param {string} [pattern.language] - Programming language (if applicable)\n * @param {number} [pattern.confidence=0.7] - Confidence score (0-1)\n * @param {string} [pattern.conversationId] - ID of conversation where pattern was discovered\n * @returns {Promise<Object>} The stored pattern\n */\nexport async function storePattern(pattern) {\n  try {\n    console.log(`[LearningSystem] Storing pattern: ${pattern.name}`);\n\n    if (\n      !pattern ||\n      !pattern.name ||\n      !pattern.description ||\n      !pattern.representation\n    ) {\n      throw new Error(\"Invalid pattern: missing required fields\");\n    }\n\n    const patternId = pattern.id || uuidv4();\n    const now = new Date().toISOString();\n    const confidence = pattern.confidence || 0.7;\n\n    // Insert into project_patterns table\n    const query = `\n      INSERT INTO project_patterns \n      (pattern_id, pattern_type, name, description, representation, language, confidence_score, created_at, updated_at, session_origin_id) \n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      ON CONFLICT(pattern_id) DO UPDATE SET\n        name = excluded.name,\n        description = excluded.description,\n        representation = excluded.representation,\n        language = excluded.language,\n        confidence_score = excluded.confidence_score,\n        updated_at = excluded.updated_at\n    `;\n\n    await executeQuery(query, [\n      patternId,\n      pattern.category || \"code_pattern\",\n      pattern.name,\n      pattern.description,\n      pattern.representation,\n      pattern.language || null,\n      confidence,\n      now,\n      now,\n      pattern.conversationId || null,\n    ]);\n\n    return {\n      id: patternId,\n      ...pattern,\n      created_at: now,\n      updated_at: now,\n    };\n  } catch (error) {\n    console.error(\"[LearningSystem] Error storing pattern:\", error);\n    throw new Error(`Failed to store pattern: ${error.message}`);\n  }\n}\n\n/**\n * Stores a bug pattern in the database\n *\n * @param {Object} bugPattern - The bug pattern to store\n * @param {string} bugPattern.name - Name of the bug pattern\n * @param {string} bugPattern.description - Description of the bug pattern\n * @param {string} bugPattern.representation - String representation of the bug pattern\n * @param {string} [bugPattern.solution] - Solution for the bug\n * @param {string} [bugPattern.language] - Programming language (if applicable)\n * @param {number} [bugPattern.confidence=0.7] - Confidence score (0-1)\n * @param {string} [bugPattern.conversationId] - ID of conversation where bug pattern was discovered\n * @returns {Promise<Object>} The stored bug pattern\n */\nexport async function storeBugPattern(bugPattern) {\n  try {\n    console.log(`[LearningSystem] Storing bug pattern: ${bugPattern.name}`);\n\n    if (!bugPattern || !bugPattern.name || !bugPattern.description) {\n      throw new Error(\"Invalid bug pattern: missing required fields\");\n    }\n\n    const patternId = bugPattern.id || uuidv4();\n    const now = new Date().toISOString();\n    const confidence = bugPattern.confidence || 0.7;\n\n    // Enhance the representation with the solution if available\n    let representation = bugPattern.representation;\n    if (bugPattern.solution && typeof representation === \"object\") {\n      representation = {\n        ...JSON.parse(\n          typeof representation === \"string\"\n            ? representation\n            : JSON.stringify(representation)\n        ),\n        solution: bugPattern.solution,\n      };\n      representation = JSON.stringify(representation);\n    } else if (bugPattern.solution && typeof representation === \"string\") {\n      try {\n        const parsed = JSON.parse(representation);\n        parsed.solution = bugPattern.solution;\n        representation = JSON.stringify(parsed);\n      } catch (e) {\n        // Not valid JSON, keep as is\n      }\n    }\n\n    // Insert into project_patterns table with bug_pattern type\n    const query = `\n      INSERT INTO project_patterns \n      (pattern_id, pattern_type, name, description, representation, language, confidence_score, created_at, updated_at, session_origin_id) \n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      ON CONFLICT(pattern_id) DO UPDATE SET\n        name = excluded.name,\n        description = excluded.description,\n        representation = excluded.representation,\n        language = excluded.language,\n        confidence_score = excluded.confidence_score,\n        updated_at = excluded.updated_at\n    `;\n\n    await executeQuery(query, [\n      patternId,\n      \"bug_pattern\",\n      bugPattern.name,\n      bugPattern.description,\n      representation,\n      bugPattern.language || null,\n      confidence,\n      now,\n      now,\n      bugPattern.conversationId || null,\n    ]);\n\n    return {\n      id: patternId,\n      ...bugPattern,\n      created_at: now,\n      updated_at: now,\n      pattern_type: \"bug_pattern\",\n    };\n  } catch (error) {\n    console.error(\"[LearningSystem] Error storing bug pattern:\", error);\n    throw new Error(`Failed to store bug pattern: ${error.message}`);\n  }\n}\n\n/**\n * Stores a key-value pair of knowledge in the database\n *\n * @param {Object} keyValuePair - The key-value pair to store\n * @param {string} keyValuePair.key - The key (concept, term, etc.)\n * @param {string} keyValuePair.value - The value (definition, explanation, etc.)\n * @param {number} [keyValuePair.confidence=0.7] - Confidence score (0-1)\n * @param {string} [keyValuePair.category=\"general\"] - Category of knowledge\n * @param {string} [keyValuePair.conversationId] - ID of conversation where knowledge was discovered\n * @returns {Promise<Object>} The stored key-value pair\n */\nexport async function storeKeyValuePair(keyValuePair) {\n  try {\n    console.log(\n      `[LearningSystem] Storing knowledge key-value pair: ${keyValuePair.key}`\n    );\n\n    if (!keyValuePair || !keyValuePair.key || !keyValuePair.value) {\n      throw new Error(\"Invalid key-value pair: missing required fields\");\n    }\n\n    const knowledgeId = keyValuePair.id || uuidv4();\n    const now = new Date().toISOString();\n    const confidence = keyValuePair.confidence || 0.7;\n    const category = keyValuePair.category || \"general\";\n\n    // Insert into knowledge_base table\n    const query = `\n      INSERT INTO knowledge_items \n      (item_id, item_type, name, content, metadata, confidence_score, created_at, updated_at, conversation_id) \n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n      ON CONFLICT(item_id) DO UPDATE SET\n        name = excluded.name,\n        content = excluded.content,\n        metadata = excluded.metadata,\n        confidence_score = excluded.confidence_score,\n        updated_at = excluded.updated_at\n    `;\n\n    // Create metadata\n    const metadata = JSON.stringify({\n      category,\n      source: keyValuePair.conversationId ? \"conversation\" : \"analysis\",\n      conversationId: keyValuePair.conversationId || null,\n    });\n\n    await executeQuery(query, [\n      knowledgeId,\n      \"concept_definition\",\n      keyValuePair.key,\n      keyValuePair.value,\n      metadata,\n      confidence,\n      now,\n      now,\n      keyValuePair.conversationId || null,\n    ]);\n\n    return {\n      id: knowledgeId,\n      ...keyValuePair,\n      created_at: now,\n      updated_at: now,\n      item_type: \"concept_definition\",\n    };\n  } catch (error) {\n    console.error(\"[LearningSystem] Error storing key-value pair:\", error);\n    throw new Error(`Failed to store key-value pair: ${error.message}`);\n  }\n}\n", "/**\n * SemanticPatternRecognizerLogic.js\n *\n * Logic for recognizing semantic patterns in code entities.\n * Uses both textual and structural analysis to identify patterns.\n */\n\nimport * as TextTokenizerLogic from \"./TextTokenizerLogic.js\";\nimport * as CodeStructureAnalyzerLogic from \"./CodeStructureAnalyzerLogic.js\";\nimport * as RelationshipContextManagerLogic from \"./RelationshipContextManagerLogic.js\";\nimport { executeQuery } from \"../db.js\";\nimport { v4 as uuidv4 } from \"uuid\";\n\n/**\n * @typedef {Object} Pattern\n * @property {string} id - Unique identifier for the pattern\n * @property {string} name - Human-readable name for the pattern\n * @property {string} description - Description of what the pattern represents\n * @property {string} language - Programming language this pattern applies to (e.g., 'javascript', 'python', or 'any' for language-agnostic patterns)\n * @property {string} category - Category of the pattern (e.g., 'design_pattern', 'antipattern', 'common_idiom')\n * @property {string} representation - Textual or structured representation of the pattern\n * @property {string} detection_rules - JSON string of rules used to detect this pattern\n * @property {number} importance - Importance score of this pattern (0-1)\n * @property {string} created_at - When this pattern was created\n * @property {string} updated_at - When this pattern was last updated\n */\n\n/**\n * @typedef {Object} PatternDefinition\n * @property {string} name - Human-readable name for the pattern\n * @property {string} description - Description of what the pattern represents\n * @property {string} language - Programming language this pattern applies to (e.g., 'javascript', 'python', or 'any' for language-agnostic patterns)\n * @property {string} category - Category of the pattern\n * @property {string} representation - Textual or structured representation of the pattern\n * @property {Object} detection_rules - Rules used to detect this pattern\n * @property {number} importance - Importance score of this pattern (0-1)\n */\n\n/**\n * @typedef {Object} CodeEntity\n * @property {string} id - Unique identifier for the code entity\n * @property {string} path - File path of the code entity\n * @property {string} type - Type of code entity ('file', 'function', 'class', etc.)\n * @property {string} name - Name of the code entity\n * @property {string} content - Content of the code entity\n * @property {string} raw_content - Raw unprocessed content of the entity\n * @property {string} language - Programming language of the entity\n * @property {Object} custom_metadata - Optional metadata including structural information\n */\n\n/**\n * Recognizes semantic patterns in a code entity\n *\n * @param {CodeEntity} entity - The code entity to analyze\n * @returns {Promise<{patterns: Pattern[], confidence: number}>} Matched patterns and overall confidence\n */\nexport async function recognizePatterns(entity) {\n  try {\n    // 1. Extract key information from the entity\n    const { content, raw_content, language, type, custom_metadata } = entity;\n\n    // If entity has no content, return empty result\n    if (!content && !raw_content) {\n      return { patterns: [], confidence: 0 };\n    }\n\n    const entityContent = raw_content || content;\n\n    // 2. Get structural features - either from metadata or by analyzing\n    let structuralFeatures = custom_metadata?.structuralFeatures;\n\n    if (!structuralFeatures) {\n      // Build AST and extract structural features\n      const ast = await CodeStructureAnalyzerLogic.buildAST(\n        entityContent,\n        language\n      );\n      structuralFeatures =\n        await CodeStructureAnalyzerLogic.extractStructuralFeatures(ast);\n    }\n\n    // 3. Get token-based features using TextTokenizerLogic\n    const tokenizedContent = TextTokenizerLogic.tokenize(entityContent);\n    const keywords = TextTokenizerLogic.extractKeywords(tokenizedContent);\n    const codeNgrams = TextTokenizerLogic.extractNGrams(tokenizedContent, 3); // Extract up to 3-grams\n\n    // 4. Retrieve known patterns from database\n    const knownPatterns = await getKnownPatterns({\n      language: language, // Filter by entity's language\n      minConfidence: 0.3, // Only get reasonably confident patterns\n    });\n\n    if (knownPatterns.length === 0) {\n      return { patterns: [], confidence: 0 };\n    }\n\n    // 5. Match patterns against the entity\n    const matchResults = await Promise.all(\n      knownPatterns.map((pattern) =>\n        matchPattern(\n          pattern,\n          entityContent,\n          structuralFeatures,\n          keywords,\n          codeNgrams,\n          type\n        )\n      )\n    );\n\n    // 6. Filter patterns with positive matches and sort by confidence\n    const matchedPatterns = matchResults\n      .filter((result) => result.confidence > 0.1) // Only include patterns with reasonable confidence\n      .sort((a, b) => b.confidence - a.confidence);\n\n    // 7. Calculate overall confidence (weighted average based on pattern importance)\n    let overallConfidence = 0;\n    let totalImportance = 0;\n\n    if (matchedPatterns.length > 0) {\n      for (const match of matchedPatterns) {\n        const importance = match.pattern.importance || 0.5; // Default importance if not specified\n        overallConfidence += match.confidence * importance;\n        totalImportance += importance;\n      }\n\n      overallConfidence =\n        totalImportance > 0\n          ? overallConfidence / totalImportance\n          : matchedPatterns[0].confidence; // If no importance values, use highest confidence\n    }\n\n    // 8. Return matched patterns and overall confidence\n    return {\n      patterns: matchedPatterns.map((match) => match.pattern),\n      confidence: overallConfidence,\n    };\n  } catch (error) {\n    console.error(\"Error in pattern recognition:\", error);\n    return { patterns: [], confidence: 0 };\n  }\n}\n\n/**\n * Retrieves known patterns from the database with optional filtering\n *\n * @param {Object} filterOptions - Options to filter the patterns\n * @param {string} [filterOptions.type] - Filter by pattern type\n * @param {number} [filterOptions.minConfidence] - Filter by minimum confidence score\n * @param {string} [filterOptions.language] - Filter by programming language\n * @returns {Promise<Pattern[]>} Array of patterns matching the filters\n */\nexport async function getKnownPatterns(filterOptions = {}) {\n  try {\n    const { type, minConfidence, language } = filterOptions;\n\n    // Build the query\n    let query = \"SELECT * FROM project_patterns WHERE 1=1\";\n    const params = [];\n\n    // Apply type filter\n    if (type) {\n      query += \" AND pattern_type = ?\";\n      params.push(type);\n    }\n\n    // Apply confidence filter\n    if (minConfidence !== undefined && !isNaN(minConfidence)) {\n      query += \" AND confidence_score >= ?\";\n      params.push(minConfidence);\n    }\n\n    // Apply language filter\n    if (language) {\n      query += \" AND (language = ? OR language = ? OR language IS NULL)\";\n      params.push(language, \"any\"); // Include language-specific, universal patterns, and legacy NULL values\n    }\n\n    // Order by confidence and frequency\n    query += \" ORDER BY confidence_score DESC, frequency DESC\";\n\n    // Execute the query\n    const patterns = await executeQuery(query, params);\n\n    // Parse detection_rules JSON for each pattern\n    return patterns.map((pattern) => ({\n      ...pattern,\n      detection_rules: JSON.parse(pattern.detection_rules || \"{}\"),\n    }));\n  } catch (error) {\n    console.error(\"Error retrieving patterns with filters:\", error);\n    throw new Error(`Failed to retrieve patterns: ${error.message}`);\n  }\n}\n\n/**\n * Retrieves known patterns from the database\n *\n * @param {string} language - Programming language to filter by (optional)\n * @returns {Promise<Pattern[]>} Array of known patterns\n * @private\n */\nasync function _getKnownPatternsInternal(language) {\n  try {\n    let query = \"SELECT * FROM project_patterns\";\n    const params = [];\n\n    // Filter by language if specified\n    if (language) {\n      query += \" WHERE language = ? OR language = ? OR language IS NULL\";\n      params.push(language, \"any\"); // Include language-specific, universal patterns, and legacy NULL values\n    }\n\n    const patterns = await executeQuery(query, params);\n\n    // Parse detection_rules JSON\n    return patterns.map((pattern) => ({\n      ...pattern,\n      detection_rules: JSON.parse(pattern.detection_rules || \"{}\"),\n    }));\n  } catch (error) {\n    console.error(\"Error retrieving known patterns:\", error);\n    return [];\n  }\n}\n\n/**\n * Matches a pattern against an entity\n *\n * @param {Pattern} pattern - The pattern to match\n * @param {string} content - The entity content\n * @param {Object} structuralFeatures - Structural features of the entity\n * @param {string[]} keywords - Extracted keywords from the entity\n * @param {Object[]} codeNgrams - N-grams extracted from the entity\n * @param {string} entityType - Type of the entity (file, function, class, etc.)\n * @returns {Promise<{pattern: Pattern, confidence: number}>} Match result with confidence\n * @private\n */\nasync function matchPattern(\n  pattern,\n  content,\n  structuralFeatures,\n  keywords,\n  codeNgrams,\n  entityType\n) {\n  try {\n    const { detection_rules } = pattern;\n    let textualMatchScore = 0;\n    let structuralMatchScore = 0;\n    let typeMatchScore = 0;\n\n    // Check if pattern applies to this entity type\n    if (\n      detection_rules.applicable_types &&\n      Array.isArray(detection_rules.applicable_types)\n    ) {\n      typeMatchScore = detection_rules.applicable_types.includes(entityType)\n        ? 1\n        : 0;\n\n      // If pattern explicitly doesn't apply to this type, return zero confidence\n      if (typeMatchScore === 0 && detection_rules.strict_type_matching) {\n        return { pattern, confidence: 0 };\n      }\n    } else {\n      // If no type restrictions, full score\n      typeMatchScore = 1;\n    }\n\n    // Perform textual matching\n    if (detection_rules.keywords && Array.isArray(detection_rules.keywords)) {\n      const keywordMatches = detection_rules.keywords.filter((keyword) =>\n        keywords.includes(keyword)\n      );\n\n      textualMatchScore =\n        keywordMatches.length / detection_rules.keywords.length;\n    }\n\n    // Check for text patterns\n    if (\n      detection_rules.text_patterns &&\n      Array.isArray(detection_rules.text_patterns)\n    ) {\n      let patternMatchCount = 0;\n\n      for (const textPattern of detection_rules.text_patterns) {\n        if (typeof textPattern === \"string\") {\n          if (content.includes(textPattern)) {\n            patternMatchCount++;\n          }\n        } else if (\n          textPattern instanceof RegExp ||\n          (typeof textPattern === \"object\" && textPattern.pattern)\n        ) {\n          // Handle regex pattern objects\n          const pattern =\n            textPattern instanceof RegExp\n              ? textPattern\n              : new RegExp(textPattern.pattern, textPattern.flags || \"\");\n\n          if (pattern.test(content)) {\n            patternMatchCount++;\n          }\n        }\n      }\n\n      const textPatternScore =\n        detection_rules.text_patterns.length > 0\n          ? patternMatchCount / detection_rules.text_patterns.length\n          : 0;\n\n      // Combine with keyword score\n      textualMatchScore =\n        textualMatchScore > 0\n          ? (textualMatchScore + textPatternScore) / 2\n          : textPatternScore;\n    }\n\n    // Perform structural matching\n    if (\n      detection_rules.structural_rules &&\n      Array.isArray(detection_rules.structural_rules)\n    ) {\n      let structRuleMatchCount = 0;\n\n      for (const rule of detection_rules.structural_rules) {\n        const { feature, condition, value } = rule;\n\n        // Skip invalid rules\n        if (!feature || !condition || value === undefined) continue;\n\n        // Get the actual feature value\n        const featureValue = structuralFeatures[feature];\n\n        // Skip if feature doesn't exist\n        if (featureValue === undefined) continue;\n\n        // Evaluate condition\n        let matches = false;\n\n        switch (condition) {\n          case \"equals\":\n            matches = featureValue === value;\n            break;\n          case \"contains\":\n            matches = Array.isArray(featureValue)\n              ? featureValue.includes(value)\n              : String(featureValue).includes(String(value));\n            break;\n          case \"greater_than\":\n            matches = Number(featureValue) > Number(value);\n            break;\n          case \"less_than\":\n            matches = Number(featureValue) < Number(value);\n            break;\n          case \"matches_regex\":\n            matches = new RegExp(value).test(String(featureValue));\n            break;\n          default:\n            matches = false;\n        }\n\n        if (matches) {\n          structRuleMatchCount++;\n        }\n      }\n\n      structuralMatchScore =\n        detection_rules.structural_rules.length > 0\n          ? structRuleMatchCount / detection_rules.structural_rules.length\n          : 0;\n    }\n\n    // Calculate combined confidence\n    const weights = detection_rules.weights || {\n      textual: 0.4,\n      structural: 0.4,\n      type: 0.2,\n    };\n\n    // Calculate weighted average\n    const confidence =\n      textualMatchScore * weights.textual +\n      structuralMatchScore * weights.structural +\n      typeMatchScore * weights.type;\n\n    return { pattern, confidence };\n  } catch (error) {\n    console.error(`Error matching pattern ${pattern.name}:`, error);\n    return { pattern, confidence: 0 };\n  }\n}\n\n/**\n * Adds a new pattern to the pattern repository\n *\n * @param {PatternDefinition} patternDefinition - The pattern definition to add\n * @returns {Promise<string>} The ID of the newly added pattern\n */\nexport async function addPatternToRepository(patternDefinition) {\n  try {\n    // 1. Generate a unique ID for the pattern\n    const pattern_id = uuidv4();\n\n    // 2. Extract and prepare pattern data with defaults\n    const {\n      pattern_type,\n      name = `Pattern_${pattern_id.substring(0, 8)}`,\n      description = \"\",\n      representation,\n      detection_rules = \"{}\",\n      language = \"any\",\n    } = patternDefinition;\n\n    // 3. Ensure representation and detection_rules are in string format for storage\n    const representationStr =\n      typeof representation === \"object\"\n        ? JSON.stringify(representation)\n        : representation;\n\n    const detectionRulesStr =\n      typeof detection_rules === \"object\"\n        ? JSON.stringify(detection_rules)\n        : detection_rules;\n\n    // 4. Set default scores and counters\n    const frequency = 1;\n    const utility_score = 0.1;\n    const confidence_score = 0.5;\n    const reinforcement_count = 1;\n    const created_at = new Date().toISOString();\n    const updated_at = created_at;\n\n    // 5. Insert the pattern into the database\n    const query = `\n      INSERT INTO project_patterns (\n        pattern_id, \n        pattern_type, \n        name, \n        description, \n        representation, \n        detection_rules,\n        language,\n        frequency,\n        utility_score,\n        confidence_score,\n        reinforcement_count,\n        created_at,\n        updated_at\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `;\n\n    const params = [\n      pattern_id,\n      pattern_type,\n      name,\n      description,\n      representationStr,\n      detectionRulesStr,\n      language,\n      frequency,\n      utility_score,\n      confidence_score,\n      reinforcement_count,\n      created_at,\n      updated_at,\n    ];\n\n    await executeQuery(query, params);\n\n    console.log(`Added new pattern \"${name}\" (${pattern_id}) to repository`);\n\n    // 6. Return the generated pattern ID\n    return pattern_id;\n  } catch (error) {\n    console.error(\"Error adding pattern to repository:\", error);\n    throw new Error(`Failed to add pattern: ${error.message}`);\n  }\n}\n\n/**\n * Finds code entities that match a specific pattern\n *\n * @param {string} patternId - ID of the pattern to match against\n * @param {number} [limit=10] - Maximum number of matches to return\n * @returns {Promise<CodeEntity[]>} Array of code entities that match the pattern\n */\nexport async function findSimilarCodeByPattern(patternId, limit = 10) {\n  try {\n    // 1. Retrieve the pattern from the database\n    const patternQuery = \"SELECT * FROM project_patterns WHERE pattern_id = ?\";\n    const patterns = await executeQuery(patternQuery, [patternId]);\n\n    if (patterns.length === 0) {\n      console.warn(`Pattern with ID ${patternId} not found`);\n      return [];\n    }\n\n    const pattern = {\n      ...patterns[0],\n      detection_rules: JSON.parse(patterns[0].detection_rules || \"{}\"),\n    };\n\n    // 2. Determine if we can optimize by filtering entities\n    const preFilters = [];\n    const preFilterParams = [];\n\n    // Filter by language if the pattern is language-specific\n    if (pattern.language && pattern.language !== \"any\") {\n      preFilters.push(\"language = ?\");\n      preFilterParams.push(pattern.language);\n    }\n\n    // Filter by entity type if the pattern has applicable types\n    if (\n      pattern.detection_rules.applicable_types &&\n      Array.isArray(pattern.detection_rules.applicable_types) &&\n      pattern.detection_rules.applicable_types.length > 0\n    ) {\n      const typePlaceholders = pattern.detection_rules.applicable_types\n        .map(() => \"?\")\n        .join(\", \");\n      preFilters.push(`type IN (${typePlaceholders})`);\n      preFilterParams.push(...pattern.detection_rules.applicable_types);\n    }\n\n    // 3. Create a query to get candidate entities\n    let entityQuery = \"SELECT * FROM code_entities\";\n\n    if (preFilters.length > 0) {\n      entityQuery += \" WHERE \" + preFilters.join(\" AND \");\n    }\n\n    // 4. Perform keyword search optimization if possible\n    if (\n      pattern.detection_rules.keywords &&\n      Array.isArray(pattern.detection_rules.keywords) &&\n      pattern.detection_rules.keywords.length > 0\n    ) {\n      // Get the first few keywords to use as a pre-filter\n      // This optimization assumes there's a full-text search or that content is indexed\n      // We'll limit to 3 keywords to avoid over-filtering\n      const keywordsToUse = pattern.detection_rules.keywords.slice(0, 3);\n\n      // Search for entities with content containing any of these keywords\n      // This is a simplified approach - a real implementation might use a more sophisticated\n      // full-text search or entity_keywords table\n      if (keywordsToUse.length > 0) {\n        const keywordConditions = keywordsToUse\n          .map((keyword) => \"content LIKE ?\")\n          .join(\" OR \");\n\n        if (preFilters.length > 0) {\n          entityQuery += ` AND (${keywordConditions})`;\n        } else {\n          entityQuery += ` WHERE (${keywordConditions})`;\n        }\n\n        // Add the LIKE parameters with wildcards\n        keywordsToUse.forEach((keyword) => {\n          preFilterParams.push(`%${keyword}%`);\n        });\n      }\n    }\n\n    // Add a reasonable limit to avoid processing too many entities\n    // We'll process more than the requested limit since some might not match\n    const processingLimit = Math.min(limit * 5, 100);\n    entityQuery += ` LIMIT ${processingLimit}`;\n\n    // 5. Get candidate entities\n    const entities = await executeQuery(entityQuery, preFilterParams);\n\n    // 6. Check each entity for pattern matches\n    const matchResults = [];\n\n    for (const entity of entities) {\n      // Perform pattern matching similar to recognizePatterns but for a single pattern\n      try {\n        // Extract content and prepare for analysis\n        const entityContent = entity.raw_content || entity.content;\n\n        if (!entityContent) continue;\n\n        // Get token-based features\n        const tokenizedContent = TextTokenizerLogic.tokenize(entityContent);\n        const keywords = TextTokenizerLogic.extractKeywords(tokenizedContent);\n        const codeNgrams = TextTokenizerLogic.extractNGrams(\n          tokenizedContent,\n          3\n        );\n\n        // Get or generate structural features if needed for this pattern\n        let structuralFeatures = entity.custom_metadata?.structuralFeatures;\n\n        // Only parse the AST if the pattern has structural rules and we don't already have features\n        const needsStructuralAnalysis =\n          pattern.detection_rules.structural_rules && !structuralFeatures;\n\n        if (needsStructuralAnalysis) {\n          try {\n            const ast = await CodeStructureAnalyzerLogic.buildAST(\n              entityContent,\n              entity.language\n            );\n            structuralFeatures =\n              await CodeStructureAnalyzerLogic.extractStructuralFeatures(ast);\n          } catch (error) {\n            console.warn(\n              `Could not analyze structure for entity ${entity.id}:`,\n              error\n            );\n            structuralFeatures = {};\n          }\n        }\n\n        // Match this entity against the pattern\n        const matchResult = await matchPattern(\n          pattern,\n          entityContent,\n          structuralFeatures || {},\n          keywords,\n          codeNgrams,\n          entity.type\n        );\n\n        // If confidence is above threshold, add to results\n        if (matchResult.confidence > 0.3) {\n          // Using a slightly higher threshold than recognizePatterns\n          matchResults.push({\n            entity,\n            confidence: matchResult.confidence,\n          });\n        }\n      } catch (error) {\n        console.warn(\n          `Error matching entity ${entity.id} against pattern:`,\n          error\n        );\n      }\n    }\n\n    // 7. Sort by confidence and limit results\n    matchResults.sort((a, b) => b.confidence - a.confidence);\n\n    // 8. Return the entities, limited by the requested limit\n    return matchResults.slice(0, limit).map((result) => result.entity);\n  } catch (error) {\n    console.error(\"Error finding similar code by pattern:\", error);\n    return [];\n  }\n}\n\n/**\n * Generates a pattern definition from example code entities\n *\n * @param {CodeEntity[]} examples - Code entities that exemplify the pattern\n * @param {string} name - Name to give the generated pattern\n * @param {string} [patternType='derived_from_examples'] - Type of pattern to create\n * @returns {PatternDefinition} Generated pattern definition\n */\nexport function generatePatternFromExamples(\n  examples,\n  name,\n  patternType = \"derived_from_examples\"\n) {\n  if (!examples || examples.length === 0) {\n    throw new Error(\"At least one example is required to generate a pattern\");\n  }\n\n  // 1. Extract necessary information from examples\n  const language = identifyCommonLanguage(examples);\n  const entityType = identifyCommonEntityType(examples);\n\n  // 2. Extract textual features from all examples\n  const textualFeatures = extractTextualFeatures(examples);\n\n  // 3. Extract structural features if possible\n  const structuralFeatures = extractStructuralFeatures(examples);\n\n  // 4. Generate a description based on examples\n  const description = `Pattern derived from ${examples.length} examples related to ${name}`;\n\n  // 5. Create detection rules based on commonalities\n  const detectionRules = {\n    keywords: textualFeatures.commonKeywords,\n    text_patterns: textualFeatures.commonNgrams.map((ngram) => ngram.text),\n    structural_rules: structuralFeatures.rules,\n    applicable_types: [entityType],\n    weights: {\n      textual: 0.5,\n      structural: 0.4,\n      type: 0.1,\n    },\n  };\n\n  // 6. Create a representation based on the most representative example\n  // Choose the example with the highest number of common features\n  let bestExampleIndex = 0;\n  let bestMatchScore = -1;\n\n  examples.forEach((example, index) => {\n    const content = example.raw_content || example.content;\n    if (!content) return;\n\n    let matchScore = 0;\n\n    // Count how many common keywords and n-grams this example contains\n    const tokenizedContent = TextTokenizerLogic.tokenize(content);\n    const keywords = TextTokenizerLogic.extractKeywords(tokenizedContent);\n\n    textualFeatures.commonKeywords.forEach((keyword) => {\n      if (keywords.includes(keyword)) matchScore++;\n    });\n\n    textualFeatures.commonNgrams.forEach((ngram) => {\n      if (content.includes(ngram.text)) matchScore++;\n    });\n\n    if (matchScore > bestMatchScore) {\n      bestMatchScore = matchScore;\n      bestExampleIndex = index;\n    }\n  });\n\n  // Use the best example as the representation template\n  const representativeExample = examples[bestExampleIndex];\n  const representation = {\n    template:\n      representativeExample.raw_content || representativeExample.content,\n    variables: textualFeatures.variableTokens,\n    structure: structuralFeatures.commonPattern,\n  };\n\n  // 7. Return the pattern definition\n  return {\n    pattern_type: patternType,\n    name,\n    description,\n    language,\n    representation: JSON.stringify(representation),\n    detection_rules: detectionRules,\n    importance: 0.5, // Default moderate importance\n  };\n}\n\n/**\n * Identifies the common programming language from examples\n *\n * @param {CodeEntity[]} examples - Code entities to analyze\n * @returns {string} Common language or 'any' if mixed\n * @private\n */\nfunction identifyCommonLanguage(examples) {\n  const languages = examples.map((ex) => ex.language).filter(Boolean);\n\n  if (languages.length === 0) return \"any\";\n\n  // Check if all examples have the same language\n  const firstLanguage = languages[0];\n  const allSameLanguage = languages.every((lang) => lang === firstLanguage);\n\n  return allSameLanguage ? firstLanguage : \"any\";\n}\n\n/**\n * Identifies the common entity type from examples\n *\n * @param {CodeEntity[]} examples - Code entities to analyze\n * @returns {string} Common entity type\n * @private\n */\nfunction identifyCommonEntityType(examples) {\n  const types = examples.map((ex) => ex.type).filter(Boolean);\n\n  if (types.length === 0) return \"any\";\n\n  // Check if all examples have the same type\n  const firstType = types[0];\n  const allSameType = types.every((type) => type === firstType);\n\n  return allSameType ? firstType : \"any\";\n}\n\n/**\n * Extracts textual features from examples\n *\n * @param {CodeEntity[]} examples - Code entities to analyze\n * @returns {Object} Extracted textual features\n * @private\n */\nfunction extractTextualFeatures(examples) {\n  // 1. Extract tokens, keywords, and n-grams from each example\n  const allKeywords = [];\n  const allNgrams = [];\n  const allTokens = [];\n\n  examples.forEach((example) => {\n    const content = example.raw_content || example.content;\n    if (!content) return;\n\n    const tokenizedContent = TextTokenizerLogic.tokenize(content);\n    const keywords = TextTokenizerLogic.extractKeywords(tokenizedContent);\n    const ngrams = TextTokenizerLogic.extractNGrams(tokenizedContent, 3);\n\n    allKeywords.push(keywords);\n    allNgrams.push(ngrams);\n    allTokens.push(tokenizedContent);\n  });\n\n  // 2. Find common keywords across examples\n  let commonKeywords = [];\n  if (allKeywords.length > 0) {\n    // Start with first example's keywords\n    commonKeywords = [...allKeywords[0]];\n\n    // Intersect with all other examples\n    for (let i = 1; i < allKeywords.length; i++) {\n      commonKeywords = commonKeywords.filter((keyword) =>\n        allKeywords[i].includes(keyword)\n      );\n    }\n\n    // Limit to most significant keywords (top 10)\n    commonKeywords = commonKeywords.slice(0, 10);\n  }\n\n  // 3. Find common n-grams\n  let commonNgrams = [];\n  if (allNgrams.length > 0) {\n    // Create a frequency map of n-grams\n    const ngramFrequency = new Map();\n\n    allNgrams.forEach((exampleNgrams) => {\n      exampleNgrams.forEach((ngram) => {\n        const key = ngram.text;\n        ngramFrequency.set(key, (ngramFrequency.get(key) || 0) + 1);\n      });\n    });\n\n    // Find n-grams that appear in at least half of the examples\n    const threshold = Math.max(1, Math.floor(examples.length / 2));\n\n    commonNgrams = Array.from(ngramFrequency.entries())\n      .filter(([_, count]) => count >= threshold)\n      .map(([text, _]) => ({ text }))\n      .slice(0, 5); // Limit to top 5 common n-grams\n  }\n\n  // 4. Identify variable tokens (tokens that vary across examples)\n  const variableTokens = [];\n\n  // If we have more than one example, find tokens that vary in position\n  if (allTokens.length > 1) {\n    const firstTokens = allTokens[0];\n\n    // Simple approach: look for positions where token differs across examples\n    // For each token position in the first example:\n    for (let i = 0; i < Math.min(firstTokens.length, 30); i++) {\n      // Limit to first 30 tokens\n      if (i >= firstTokens.length) break;\n\n      const token = firstTokens[i];\n      let isVariable = false;\n\n      // Check if this position has different tokens in other examples\n      for (let j = 1; j < allTokens.length; j++) {\n        const otherTokens = allTokens[j];\n        if (i >= otherTokens.length || otherTokens[i] !== token) {\n          isVariable = true;\n          break;\n        }\n      }\n\n      if (isVariable) {\n        variableTokens.push({\n          position: i,\n          examples: examples\n            .map((ex) => {\n              const tokens = TextTokenizerLogic.tokenize(\n                ex.raw_content || ex.content || \"\"\n              );\n              return i < tokens.length ? tokens[i] : null;\n            })\n            .filter(Boolean),\n        });\n      }\n    }\n  }\n\n  return {\n    commonKeywords,\n    commonNgrams,\n    variableTokens,\n  };\n}\n\n/**\n * Extracts structural features from examples\n *\n * @param {CodeEntity[]} examples - Code entities to analyze\n * @returns {Object} Extracted structural features\n * @private\n */\nfunction extractStructuralFeatures(examples) {\n  // Default result with empty values\n  const defaultResult = {\n    rules: [],\n    commonPattern: null,\n  };\n\n  try {\n    // 1. Extract structural features from each example if possible\n    const allFeatures = [];\n\n    for (const example of examples) {\n      const content = example.raw_content || example.content;\n      if (!content) continue;\n\n      // Use existing structural features if available\n      if (example.custom_metadata?.structuralFeatures) {\n        allFeatures.push(example.custom_metadata.structuralFeatures);\n        continue;\n      }\n\n      // Otherwise try to extract features (synchronously)\n      try {\n        // Note: We're calling async functions synchronously here which is not ideal,\n        // but for simplicity in this example we'll assume they can work synchronously\n        const ast = CodeStructureAnalyzerLogic.buildAST(\n          content,\n          example.language\n        );\n        if (!ast) continue;\n\n        const features =\n          CodeStructureAnalyzerLogic.extractStructuralFeatures(ast);\n        if (features) {\n          allFeatures.push(features);\n        }\n      } catch (error) {\n        console.warn(\n          `Could not extract structural features for example: ${error.message}`\n        );\n      }\n    }\n\n    if (allFeatures.length === 0) {\n      return defaultResult;\n    }\n\n    // 2. Find common structural properties\n    const structuralRules = [];\n\n    // Start with the first example's features\n    const firstFeatures = allFeatures[0];\n\n    // For each property in the first example, check if it's common across all examples\n    for (const [feature, value] of Object.entries(firstFeatures)) {\n      // Skip if the value is complex or undefined\n      if (typeof value === \"undefined\" || typeof value === \"object\") continue;\n\n      // Check if this feature has the same value across all examples\n      const isCommon = allFeatures.every((features) => {\n        return features[feature] === value;\n      });\n\n      // If common, add a structural rule\n      if (isCommon) {\n        structuralRules.push({\n          feature,\n          condition: \"equals\",\n          value,\n        });\n      }\n      // If not exactly the same but similar (for numeric values)\n      else if (typeof value === \"number\") {\n        // Calculate range\n        const values = allFeatures\n          .map((f) => f[feature])\n          .filter((v) => typeof v === \"number\");\n        const min = Math.min(...values);\n        const max = Math.max(...values);\n\n        // If there's a reasonable range, add a range rule\n        if (max - min < max * 0.5) {\n          // Max is no more than 50% larger than min\n          structuralRules.push({\n            feature,\n            condition: \"greater_than\",\n            value: min * 0.9, // 10% below minimum observed\n          });\n\n          structuralRules.push({\n            feature,\n            condition: \"less_than\",\n            value: max * 1.1, // 10% above maximum observed\n          });\n        }\n      }\n    }\n\n    // 3. Identify common structural pattern\n    // For simplicity, we'll use the most important structural features\n    const commonPattern = {\n      nodeType: examples[0].type,\n      structuralRules: structuralRules.slice(0, 3), // Top 3 rules\n      complexity:\n        allFeatures.reduce((sum, f) => sum + (f.complexity || 0), 0) /\n        allFeatures.length,\n    };\n\n    return {\n      rules: structuralRules,\n      commonPattern,\n    };\n  } catch (error) {\n    console.error(\"Error extracting structural features:\", error);\n    return defaultResult;\n  }\n}\n\n/**\n * Detects design patterns in a set of code entities\n *\n * @param {CodeEntity[]} entities - Code entities to analyze\n * @returns {Array<{patternType: string, entities: string[], confidence: number}>} Detected design patterns\n */\nexport async function detectDesignPatterns(entities) {\n  if (!entities || entities.length === 0) {\n    return [];\n  }\n\n  // Results array\n  const detectedPatterns = [];\n\n  // Get entity IDs for relationship lookup\n  const entityIds = entities.map((entity) => entity.id);\n\n  // Get relationships between entities if available\n  let relationships = [];\n  try {\n    relationships = await RelationshipContextManagerLogic.getRelationships(\n      entityIds\n    );\n  } catch (error) {\n    console.warn(\"Error retrieving relationships between entities:\", error);\n    // Continue without relationships\n  }\n\n  // Define pattern detectors\n  const patternDetectors = [\n    detectSingletonPattern,\n    detectFactoryPattern,\n    detectObserverPattern,\n    // Add more pattern detectors here as needed\n  ];\n\n  // Apply each detector\n  for (const detector of patternDetectors) {\n    const result = await detector(entities, relationships);\n    if (result.length > 0) {\n      detectedPatterns.push(...result);\n    }\n  }\n\n  return detectedPatterns;\n}\n\n/**\n * Detects Singleton pattern\n *\n * @param {CodeEntity[]} entities - Code entities to analyze\n * @param {Array} relationships - Relationships between entities\n * @returns {Array<{patternType: string, entities: string[], confidence: number}>} Detected patterns\n * @private\n */\nasync function detectSingletonPattern(entities, relationships) {\n  const results = [];\n\n  // Find class entities\n  const classEntities = entities.filter(\n    (entity) => entity.type === \"class\" || entity.type === \"interface\"\n  );\n\n  for (const classEntity of classEntities) {\n    let confidence = 0;\n    let evidence = [];\n\n    const content = classEntity.raw_content || classEntity.content;\n    if (!content) continue;\n\n    // Look for private/protected constructor\n    const hasPrivateConstructor =\n      /private\\s+constructor|protected\\s+constructor/.test(content);\n    if (hasPrivateConstructor) {\n      confidence += 0.3;\n      evidence.push(\"private/protected constructor\");\n    }\n\n    // Look for static instance field\n    const hasStaticInstance =\n      /static\\s+(\\w+)\\s*:\\s*\\w+|static\\s+(\\w+)\\s*=/.test(content);\n    if (hasStaticInstance) {\n      confidence += 0.3;\n      evidence.push(\"static instance field\");\n    }\n\n    // Look for getInstance method\n    const hasGetInstanceMethod =\n      /static\\s+getInstance\\s*\\(|static\\s+instance\\s*\\(|static\\s+get\\s+instance\\s*\\(/.test(\n        content\n      );\n    if (hasGetInstanceMethod) {\n      confidence += 0.4;\n      evidence.push(\"getInstance method\");\n    }\n\n    // Look for self-assignment in constructor\n    const hasSelfAssignment =\n      /this\\._instance\\s*=\\s*this|instance\\s*=\\s*this/.test(content);\n    if (hasSelfAssignment) {\n      confidence += 0.2;\n      evidence.push(\"self-assignment in constructor\");\n    }\n\n    // Check if this class is being instantiated elsewhere\n    const isInstantiatedElsewhere = relationships.some(\n      (rel) =>\n        rel.relationship_type === \"instantiates\" &&\n        rel.target_entity_id === classEntity.id\n    );\n\n    // If instantiated in multiple places, it's less likely to be a Singleton\n    if (isInstantiatedElsewhere) {\n      confidence -= 0.2;\n      evidence.push(\"instantiated elsewhere (negative)\");\n    }\n\n    // If confidence is high enough, add to results\n    if (confidence >= 0.6) {\n      results.push({\n        patternType: \"Singleton\",\n        entities: [classEntity.id],\n        confidence,\n        evidence,\n      });\n    }\n  }\n\n  return results;\n}\n\n/**\n * Detects Factory pattern\n *\n * @param {CodeEntity[]} entities - Code entities to analyze\n * @param {Array} relationships - Relationships between entities\n * @returns {Array<{patternType: string, entities: string[], confidence: number}>} Detected patterns\n * @private\n */\nasync function detectFactoryPattern(entities, relationships) {\n  const results = [];\n\n  // Find class and function entities\n  const classEntities = entities.filter((entity) => entity.type === \"class\");\n  const functionEntities = entities.filter(\n    (entity) => entity.type === \"function\" || entity.type === \"method\"\n  );\n\n  // Look for factory classes\n  for (const classEntity of classEntities) {\n    let confidence = 0;\n    let evidence = [];\n    const involvedEntities = [classEntity.id];\n\n    const content = classEntity.raw_content || classEntity.content;\n    if (!content) continue;\n\n    // Class name suggests Factory\n    if (/Factory|Builder|Creator|Producer/i.test(classEntity.name)) {\n      confidence += 0.2;\n      evidence.push(\"name suggests factory\");\n    }\n\n    // Look for create/make/build methods in the class\n    const hasCreateMethods =\n      /\\b(create|make|build|produce|get)\\w*\\s*\\([^)]*\\)\\s*{/.test(content);\n    if (hasCreateMethods) {\n      confidence += 0.3;\n      evidence.push(\"has creation methods\");\n    }\n\n    // Check if this class has relationships that indicate creation of other objects\n    const creationRelationships = relationships.filter(\n      (rel) =>\n        rel.source_entity_id === classEntity.id &&\n        (rel.relationship_type === \"creates\" ||\n          rel.relationship_type === \"instantiates\")\n    );\n\n    if (creationRelationships.length > 0) {\n      confidence += 0.3;\n      evidence.push(`creates ${creationRelationships.length} other entities`);\n\n      // Add related entities\n      creationRelationships.forEach((rel) => {\n        if (!involvedEntities.includes(rel.target_entity_id)) {\n          involvedEntities.push(rel.target_entity_id);\n        }\n      });\n    }\n\n    // Look for method return types that match other known entities\n    const otherClassNames = classEntities\n      .filter((e) => e.id !== classEntity.id)\n      .map((e) => e.name);\n\n    let returnTypeMatches = 0;\n    for (const otherClass of otherClassNames) {\n      const returnTypeRegex = new RegExp(\n        `:\\\\s*${otherClass}\\\\b|return\\\\s+(new\\\\s+)?${otherClass}\\\\b`\n      );\n      if (returnTypeRegex.test(content)) {\n        returnTypeMatches++;\n      }\n    }\n\n    if (returnTypeMatches > 0) {\n      confidence += 0.2;\n      evidence.push(`returns known types (${returnTypeMatches})`);\n    }\n\n    // If confidence is high enough, add to results\n    if (confidence >= 0.5) {\n      results.push({\n        patternType: \"Factory\",\n        entities: involvedEntities,\n        confidence,\n        evidence,\n      });\n    }\n  }\n\n  // Look for standalone factory functions\n  for (const functionEntity of functionEntities) {\n    let confidence = 0;\n    let evidence = [];\n    const involvedEntities = [functionEntity.id];\n\n    const content = functionEntity.raw_content || functionEntity.content;\n    if (!content) continue;\n\n    // Function name suggests Factory\n    if (/create|make|build|produce|factory|new/i.test(functionEntity.name)) {\n      confidence += 0.3;\n      evidence.push(\"name suggests factory function\");\n    }\n\n    // Check if this function has relationships that indicate creation of objects\n    const creationRelationships = relationships.filter(\n      (rel) =>\n        rel.source_entity_id === functionEntity.id &&\n        (rel.relationship_type === \"creates\" ||\n          rel.relationship_type === \"instantiates\")\n    );\n\n    if (creationRelationships.length > 0) {\n      confidence += 0.3;\n      evidence.push(`creates ${creationRelationships.length} entities`);\n\n      // Add related entities\n      creationRelationships.forEach((rel) => {\n        if (!involvedEntities.includes(rel.target_entity_id)) {\n          involvedEntities.push(rel.target_entity_id);\n        }\n      });\n    }\n\n    // Look for 'new' keyword\n    if (/return\\s+new\\s+\\w+/.test(content)) {\n      confidence += 0.3;\n      evidence.push(\"returns new instance\");\n    }\n\n    // If confidence is high enough, add to results\n    if (confidence >= 0.5) {\n      results.push({\n        patternType: \"Factory\",\n        entities: involvedEntities,\n        confidence,\n        evidence,\n      });\n    }\n  }\n\n  return results;\n}\n\n/**\n * Detects Observer pattern\n *\n * @param {CodeEntity[]} entities - Code entities to analyze\n * @param {Array} relationships - Relationships between entities\n * @returns {Array<{patternType: string, entities: string[], confidence: number}>} Detected patterns\n * @private\n */\nasync function detectObserverPattern(entities, relationships) {\n  const results = [];\n\n  // Find class entities\n  const classEntities = entities.filter((entity) => entity.type === \"class\");\n\n  // Look for potential subject classes\n  for (const potentialSubject of classEntities) {\n    let confidence = 0;\n    let evidence = [];\n    const involvedEntities = [potentialSubject.id];\n\n    const content = potentialSubject.raw_content || potentialSubject.content;\n    if (!content) continue;\n\n    // Look for observer list/collection\n    const hasObserverCollection =\n      /(\\w+)?\\s*observers\\s*=|(\\w+)?\\s*listeners\\s*=/.test(content);\n    if (hasObserverCollection) {\n      confidence += 0.2;\n      evidence.push(\"has observer collection\");\n    }\n\n    // Look for add/remove/notify observer methods\n    const hasAddObserver =\n      /add(Observer|Listener|Subscriber|Handler)|subscribe/.test(content);\n    if (hasAddObserver) {\n      confidence += 0.2;\n      evidence.push(\"has add observer method\");\n    }\n\n    const hasRemoveObserver =\n      /remove(Observer|Listener|Subscriber|Handler)|unsubscribe/.test(content);\n    if (hasRemoveObserver) {\n      confidence += 0.2;\n      evidence.push(\"has remove observer method\");\n    }\n\n    const hasNotifyMethod =\n      /notify|notifyObservers|emit|trigger|dispatch|fire/.test(content);\n    if (hasNotifyMethod) {\n      confidence += 0.3;\n      evidence.push(\"has notify method\");\n    }\n\n    // Look for potential observers\n    let potentialObservers = [];\n\n    // Check relationships for \"observes\" relationship\n    const observerRelationships = relationships.filter(\n      (rel) =>\n        rel.target_entity_id === potentialSubject.id &&\n        rel.relationship_type === \"observes\"\n    );\n\n    if (observerRelationships.length > 0) {\n      confidence += 0.3;\n      evidence.push(`has ${observerRelationships.length} explicit observers`);\n\n      // Add observer entities\n      observerRelationships.forEach((rel) => {\n        const observerId = rel.source_entity_id;\n        if (!involvedEntities.includes(observerId)) {\n          involvedEntities.push(observerId);\n          potentialObservers.push(observerId);\n        }\n      });\n    }\n\n    // If no explicit observers found, look for classes with \"update\" or \"handle\" methods\n    if (potentialObservers.length === 0) {\n      for (const potentialObserver of classEntities) {\n        if (potentialObserver.id === potentialSubject.id) continue;\n\n        const observerContent =\n          potentialObserver.raw_content || potentialObserver.content;\n        if (!observerContent) continue;\n\n        const hasUpdateMethod =\n          /\\bupdate\\s*\\(|\\bhandle\\w+\\s*\\(|\\bon\\w+\\s*\\(/.test(observerContent);\n        if (hasUpdateMethod) {\n          potentialObservers.push(potentialObserver.id);\n          if (!involvedEntities.includes(potentialObserver.id)) {\n            involvedEntities.push(potentialObserver.id);\n          }\n\n          confidence += 0.1;\n          evidence.push(`found potential observer: ${potentialObserver.name}`);\n        }\n      }\n    }\n\n    // If confidence is high enough and we have potential observers, add to results\n    if (confidence >= 0.5 && potentialObservers.length > 0) {\n      results.push({\n        patternType: \"Observer\",\n        entities: involvedEntities,\n        confidence,\n        evidence,\n      });\n    }\n  }\n\n  return results;\n}\n", "/**\n * finalizeConversationContext.tool.js\n *\n * MCP tool implementation for finalizing a conversation context\n * This tool performs learning extraction, pattern promotion, and generates insights\n * when a conversation ends.\n */\n\nimport { z } from \"zod\";\nimport { executeQuery } from \"../db.js\";\nimport * as ConversationIntelligence from \"../logic/ConversationIntelligence.js\";\nimport * as TimelineManagerLogic from \"../logic/TimelineManagerLogic.js\";\nimport * as ActiveContextManager from \"../logic/ActiveContextManager.js\";\nimport * as LearningSystems from \"../logic/LearningSystems.js\";\nimport * as GlobalPatternRepository from \"../logic/GlobalPatternRepository.js\";\nimport * as SmartSearchServiceLogic from \"../logic/SmartSearchServiceLogic.js\";\nimport * as ContextCompressorLogic from \"../logic/ContextCompressorLogic.js\";\nimport * as TextTokenizerLogic from \"../logic/TextTokenizerLogic.js\";\nimport { logMessage } from \"../utils/logger.js\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nimport {\n  finalizeConversationContextInputSchema,\n  finalizeConversationContextOutputSchema,\n} from \"../schemas/toolSchemas.js\";\n\n/**\n * Handler for finalize_conversation_context tool\n *\n * @param {object} input - Tool input parameters\n * @param {object} sdkContext - SDK context\n * @returns {Promise<object>} Tool output\n */\nasync function handler(input, sdkContext) {\n  try {\n    logMessage(\"INFO\", `finalize_conversation_context tool started`, {\n      conversationId: input.conversationId,\n      outcome: input.outcome || \"completed\",\n      clearActiveContext: input.clearActiveContext || false,\n    });\n\n    // 1. Extract input parameters\n    const {\n      conversationId,\n      clearActiveContext = false,\n      extractLearnings = true,\n      promotePatterns = true,\n      synthesizeRelatedTopics = true,\n      generateNextSteps = true,\n      outcome = \"completed\",\n    } = input;\n\n    // Validate conversation ID\n    if (!conversationId) {\n      const error = new Error(\"Conversation ID is required\");\n      error.code = \"MISSING_CONVERSATION_ID\";\n      throw error;\n    }\n\n    logMessage(\"DEBUG\", `Processing options`, {\n      extractLearnings,\n      promotePatterns,\n      synthesizeRelatedTopics,\n      generateNextSteps,\n    });\n\n    // 2. Fetch conversation history, purpose, and topics\n    let conversationHistory = [];\n    let conversationPurpose = null;\n    let conversationTopics = [];\n\n    try {\n      conversationHistory =\n        await ConversationIntelligence.getConversationHistory(conversationId);\n\n      if (!conversationHistory || conversationHistory.length === 0) {\n        const error = new Error(\n          `No conversation history found for ID: ${conversationId}`\n        );\n        error.code = \"CONVERSATION_NOT_FOUND\";\n        throw error;\n      }\n\n      logMessage(\"DEBUG\", `Retrieved conversation history`, {\n        messageCount: conversationHistory.length,\n      });\n    } catch (historyErr) {\n      logMessage(\"ERROR\", `Failed to retrieve conversation history`, {\n        error: historyErr.message,\n        conversationId,\n      });\n      throw historyErr; // This is critical, rethrow\n    }\n\n    // Get conversation purpose\n    try {\n      conversationPurpose =\n        await ConversationIntelligence.getConversationPurpose(conversationId);\n      logMessage(\n        \"DEBUG\",\n        `Retrieved conversation purpose: ${conversationPurpose || \"Unknown\"}`\n      );\n    } catch (purposeErr) {\n      logMessage(\"WARN\", `Failed to retrieve conversation purpose`, {\n        error: purposeErr.message,\n        conversationId,\n      });\n      // Continue without purpose\n    }\n\n    // Get conversation topics\n    try {\n      conversationTopics = await ConversationIntelligence.getConversationTopics(\n        conversationId\n      );\n      logMessage(\n        \"DEBUG\",\n        `Retrieved ${conversationTopics.length} conversation topics`\n      );\n    } catch (topicsErr) {\n      logMessage(\"WARN\", `Failed to retrieve conversation topics`, {\n        error: topicsErr.message,\n        conversationId,\n      });\n      // Continue with empty topics\n      conversationTopics = [];\n    }\n\n    // 3. Generate overall conversation summary\n    let summary = \"\";\n    try {\n      summary = await ConversationIntelligence.summarizeConversation(\n        conversationId\n      );\n      logMessage(\"INFO\", `Generated conversation summary`, {\n        summaryLength: summary.length,\n      });\n    } catch (summaryErr) {\n      logMessage(\"WARN\", `Failed to generate conversation summary`, {\n        error: summaryErr.message,\n        conversationId,\n      });\n      // Use a basic summary as fallback\n      summary = `Conversation ${conversationId} with ${conversationHistory.length} messages`;\n    }\n\n    // 4. Record conversation_end event in the timeline\n    try {\n      await TimelineManagerLogic.recordEvent(\n        \"conversation_end\",\n        {\n          summary,\n          purpose: conversationPurpose,\n          topics: conversationTopics.length,\n          outcome,\n        },\n        [], // No specific entities for conversation end\n        conversationId\n      );\n      logMessage(\"DEBUG\", `Recorded conversation_end event in timeline`);\n    } catch (timelineErr) {\n      logMessage(\"WARN\", `Failed to record conversation_end event`, {\n        error: timelineErr.message,\n        conversationId,\n      });\n      // Continue despite timeline error\n    }\n\n    // 5. Initialize result objects\n    let extractedLearnings = null;\n    let promotedPatterns = null;\n    let relatedConversations = null;\n    let nextSteps = null;\n\n    // 6. Extract learnings if requested\n    if (extractLearnings) {\n      try {\n        logMessage(\"INFO\", `Extracting learnings from conversation`);\n        extractedLearnings = await _extractConversationLearnings(\n          conversationId,\n          conversationHistory\n        );\n        logMessage(\n          \"INFO\",\n          `Extracted ${\n            extractedLearnings?.patterns?.length || 0\n          } patterns and ${\n            extractedLearnings?.bugPatterns?.length || 0\n          } bug patterns`\n        );\n      } catch (learningErr) {\n        logMessage(\"WARN\", `Failed to extract learnings`, {\n          error: learningErr.message,\n          conversationId,\n        });\n        // Continue without learnings\n        extractedLearnings = {\n          patterns: [],\n          bugPatterns: [],\n          conceptualInsights: [],\n          error: learningErr.message,\n        };\n      }\n    } else {\n      logMessage(\"DEBUG\", `Skipping learning extraction (not requested)`);\n    }\n\n    // 7. Promote patterns if requested\n    if (promotePatterns) {\n      try {\n        logMessage(\"INFO\", `Promoting patterns from conversation`);\n        promotedPatterns = await _promoteConversationPatterns(\n          conversationId,\n          outcome\n        );\n        logMessage(\"INFO\", `Promoted ${promotedPatterns?.count || 0} patterns`);\n      } catch (patternErr) {\n        logMessage(\"WARN\", `Failed to promote patterns`, {\n          error: patternErr.message,\n          conversationId,\n        });\n        // Continue without pattern promotion\n        promotedPatterns = {\n          count: 0,\n          patterns: [],\n          error: patternErr.message,\n        };\n      }\n    } else {\n      logMessage(\"DEBUG\", `Skipping pattern promotion (not requested)`);\n    }\n\n    // 8. Synthesize related topics if requested\n    if (synthesizeRelatedTopics) {\n      try {\n        logMessage(\"INFO\", `Finding and synthesizing related conversations`);\n        relatedConversations = await _findAndSynthesizeRelatedConversations(\n          conversationId,\n          conversationTopics,\n          conversationPurpose\n        );\n        logMessage(\n          \"INFO\",\n          `Found ${\n            relatedConversations?.conversations?.length || 0\n          } related conversations`\n        );\n      } catch (relatedErr) {\n        logMessage(\"WARN\", `Failed to synthesize related conversations`, {\n          error: relatedErr.message,\n          conversationId,\n        });\n        // Continue without related conversations\n        relatedConversations = {\n          conversations: [],\n          insights: [],\n          error: relatedErr.message,\n        };\n      }\n    } else {\n      logMessage(\"DEBUG\", `Skipping related topic synthesis (not requested)`);\n    }\n\n    // 9. Generate next step suggestions if requested\n    if (generateNextSteps) {\n      try {\n        logMessage(\"INFO\", `Generating next step suggestions`);\n        nextSteps = await _generateNextStepSuggestions(\n          conversationId,\n          conversationPurpose,\n          summary,\n          extractedLearnings\n        );\n        logMessage(\n          \"INFO\",\n          `Generated ${\n            nextSteps?.suggestions?.length || 0\n          } next step suggestions`\n        );\n      } catch (nextStepsErr) {\n        logMessage(\"WARN\", `Failed to generate next step suggestions`, {\n          error: nextStepsErr.message,\n          conversationId,\n        });\n        // Continue without next steps\n        nextSteps = {\n          suggestions: [],\n          error: nextStepsErr.message,\n        };\n      }\n    } else {\n      logMessage(\"DEBUG\", `Skipping next step generation (not requested)`);\n    }\n\n    // 10. Clear active context if requested\n    if (clearActiveContext) {\n      try {\n        await ActiveContextManager.clearActiveContext();\n        logMessage(\"INFO\", `Cleared active context`);\n      } catch (clearErr) {\n        logMessage(\"WARN\", `Failed to clear active context`, {\n          error: clearErr.message,\n        });\n        // Continue despite error\n      }\n    }\n\n    // Mark all active conversation purposes as ended\n    try {\n      const currentTime = new Date().toISOString();\n      const updatePurposeQuery = `\n        UPDATE conversation_purposes\n        SET end_timestamp = ?\n        WHERE conversation_id = ? AND end_timestamp IS NULL\n      `;\n      await executeQuery(updatePurposeQuery, [currentTime, conversationId]);\n      logMessage(\"INFO\", `Marked all active conversation purposes as ended`);\n\n      // Check if we have any purpose records at all for this conversation\n      const checkPurposeQuery = `\n        SELECT COUNT(*) as count FROM conversation_purposes \n        WHERE conversation_id = ?\n      `;\n      const purposeCount = await executeQuery(checkPurposeQuery, [\n        conversationId,\n      ]);\n      const hasAnyPurpose = purposeCount?.rows?.[0]?.count > 0;\n\n      // If no purpose exists, create a general_query purpose that's already ended\n      if (!hasAnyPurpose) {\n        const purposeId = uuidv4();\n        const startTime = new Date(Date.now() - 60000).toISOString(); // 1 minute ago\n\n        const insertPurposeQuery = `\n          INSERT INTO conversation_purposes (\n            purpose_id, conversation_id, purpose_type, confidence,\n            start_timestamp, end_timestamp, metadata\n          ) VALUES (?, ?, ?, ?, ?, ?, ?)\n        `;\n\n        await executeQuery(insertPurposeQuery, [\n          purposeId,\n          conversationId,\n          \"general_query\",\n          0.8,\n          startTime,\n          currentTime,\n          JSON.stringify({ source: \"finalization\", outcome }),\n        ]);\n\n        logMessage(\n          \"INFO\",\n          `Created general_query purpose record for finalization`\n        );\n      }\n    } catch (purposeErr) {\n      logMessage(\"WARN\", `Failed to finalize conversation purposes`, {\n        error: purposeErr.message,\n        conversationId,\n      });\n      // Continue despite purpose update error\n    }\n\n    // 11. Return the finalized conversation data\n    logMessage(\n      \"INFO\",\n      `finalize_conversation_context tool completed successfully`\n    );\n\n    const responseData = {\n      message: `Conversation ${conversationId} finalized successfully with outcome: ${outcome}`,\n      status: \"success\",\n      summary,\n      purpose: conversationPurpose || \"Unknown purpose\",\n      extractedLearnings,\n      promotedPatterns,\n      relatedConversations,\n      nextSteps,\n    };\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify(responseData),\n        },\n      ],\n    };\n  } catch (error) {\n    // Log detailed error information\n    logMessage(\"ERROR\", `Error in finalize_conversation_context tool`, {\n      error: error.message,\n      stack: error.stack,\n      input: {\n        conversationId: input.conversationId,\n        outcome: input.outcome,\n      },\n    });\n\n    // Return error response\n    const errorResponse = {\n      error: true,\n      errorCode: error.code || \"FINALIZATION_FAILED\",\n      errorDetails: error.message,\n      summary: \"Failed to finalize conversation context\",\n      purpose: \"Unknown due to error\",\n      extractedLearnings: null,\n      promotedPatterns: null,\n      relatedConversations: null,\n      nextSteps: null,\n    };\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify(errorResponse),\n        },\n      ],\n    };\n  }\n}\n\n/**\n * Extracts learnings from a conversation history - patterns, bugs, etc.\n *\n * @param {string} conversationId - Conversation ID\n * @param {boolean} extractPatterns - Whether to extract code patterns\n * @param {boolean} promotePatterns - Whether to promote high-quality patterns to global\n * @returns {Promise<{patternCount: number, bugPatternCount: number}>} Counts of extracted items\n */\nasync function _extractConversationLearnings(\n  conversationId,\n  extractPatterns = true,\n  promotePatterns = false\n) {\n  try {\n    logMessage(\"INFO\", \"Extracting learnings from conversation\");\n\n    let patternCount = 0;\n    let bugPatternCount = 0;\n\n    // 1. Extract code patterns if requested\n    if (extractPatterns) {\n      try {\n        const extractedPatterns =\n          await LearningSystems.extractPatternsFromConversation(conversationId);\n        if (extractedPatterns && extractedPatterns.length > 0) {\n          patternCount = extractedPatterns.length;\n\n          // Store patterns\n          // TODO: Add storage logic here\n\n          // Promote patterns if requested\n          if (promotePatterns && extractedPatterns.length > 0) {\n            // TODO: Add promotion logic here\n          }\n        }\n      } catch (error) {\n        logMessage(\"WARN\", `Failed to extract patterns: ${error.message}`);\n      }\n    }\n\n    // 2. Extract bug patterns (always do this)\n    try {\n      const bugPatterns =\n        await LearningSystems.extractBugPatternsFromConversation(\n          conversationId\n        );\n      if (bugPatterns && bugPatterns.length > 0) {\n        bugPatternCount = bugPatterns.length;\n\n        // Store bug patterns\n        // TODO: Add storage logic here\n      }\n    } catch (error) {\n      logMessage(\"WARN\", `Failed to extract bug patterns: ${error.message}`);\n    }\n\n    // 3. Extract key-value pairs for potential knowledge base entries\n    try {\n      const keyValuePairs = await LearningSystems.extractKeyValuePairs(\n        conversationId\n      );\n      if (keyValuePairs && keyValuePairs.length > 0) {\n        // Store key-value pairs\n        // TODO: Add storage logic here\n      }\n    } catch (error) {\n      logMessage(\"WARN\", `Failed to extract key-value pairs: ${error.message}`);\n    }\n\n    logMessage(\n      \"INFO\",\n      `Extracted ${patternCount} patterns and ${bugPatternCount} bug patterns`\n    );\n\n    return {\n      patternCount,\n      bugPatternCount,\n    };\n  } catch (error) {\n    logMessage(\n      \"ERROR\",\n      `Error extracting conversation learnings: ${error.message}`\n    );\n    return {\n      patternCount: 0,\n      bugPatternCount: 0,\n    };\n  }\n}\n\n/**\n * Extract conceptual insights from message content\n *\n * @param {Array} userMessages - User messages from the conversation\n * @param {Array} assistantMessages - Assistant messages from the conversation\n * @returns {Promise<Array>} Extracted conceptual insights\n * @private\n */\nasync function _extractConcepts(userMessages, assistantMessages) {\n  try {\n    logMessage(\n      \"DEBUG\",\n      `Extracting concepts from ${userMessages.length} user messages and ${assistantMessages.length} assistant messages`\n    );\n\n    // Combine message content for processing\n    const userContent = userMessages.map((msg) => msg.content).join(\"\\n\");\n    const assistantContent = assistantMessages\n      .map((msg) => msg.content)\n      .join(\"\\n\");\n\n    // Tokenize content to extract key terms\n    const userTokens = TextTokenizerLogic.tokenize(userContent);\n    const assistantTokens = TextTokenizerLogic.tokenize(assistantContent);\n\n    // Get top terms by frequency\n    const userTerms = _getTopTermsByFrequency(userTokens, 20);\n    const assistantTerms = _getTopTermsByFrequency(assistantTokens, 20);\n\n    // Find common terms that appear in both user and assistant messages\n    const commonTerms = userTerms.filter((term) =>\n      assistantTerms.some((aterm) => aterm.term === term.term)\n    );\n\n    // Extract domain-specific insights\n    const domainInsights = commonTerms.map((term) => {\n      // Find relevant snippets containing this term\n      const snippets = _findRelevantSnippets(\n        [...userMessages, ...assistantMessages],\n        term.term\n      );\n\n      return {\n        concept: term.term,\n        frequency: term.frequency,\n        importance: term.frequency / userTokens.length, // Simple importance heuristic\n        relatedTerms: assistantTerms\n          .filter(\n            (aterm) =>\n              _areTermsRelated(term.term, aterm.term) &&\n              aterm.term !== term.term\n          )\n          .map((aterm) => aterm.term)\n          .slice(0, 5),\n        snippets: snippets.slice(0, 3), // Limit to 3 snippets\n      };\n    });\n\n    logMessage(\"DEBUG\", `Extracted ${domainInsights.length} domain insights`);\n    return domainInsights;\n  } catch (error) {\n    logMessage(\"ERROR\", `Error extracting concepts`, {\n      error: error.message,\n    });\n    throw error;\n  }\n}\n\n/**\n * Gets the top terms by frequency from a list of tokens\n *\n * @param {Array} tokens - Array of tokens\n * @param {number} limit - Maximum number of terms to return\n * @returns {Array} Array of objects containing term and frequency\n * @private\n */\nfunction _getTopTermsByFrequency(tokens, limit = 20) {\n  try {\n    if (!tokens || !Array.isArray(tokens) || tokens.length === 0) {\n      return [];\n    }\n\n    // Count term frequencies\n    const termCounts = {};\n    for (const token of tokens) {\n      if (token && typeof token === \"string\" && token.length > 2) {\n        // Skip very short tokens\n        const term = token.toLowerCase();\n        termCounts[term] = (termCounts[term] || 0) + 1;\n      }\n    }\n\n    // Convert to array and sort by frequency\n    const sortedTerms = Object.entries(termCounts)\n      .map(([term, frequency]) => ({ term, frequency }))\n      .sort((a, b) => b.frequency - a.frequency);\n\n    // Return top terms\n    return sortedTerms.slice(0, limit);\n  } catch (error) {\n    logMessage(\"ERROR\", `Error getting top terms by frequency`, {\n      error: error.message,\n    });\n    return [];\n  }\n}\n\n/**\n * Checks if two terms are related\n *\n * @param {string} term1 - First term\n * @param {string} term2 - Second term\n * @returns {boolean} True if the terms are related\n * @private\n */\nfunction _areTermsRelated(term1, term2) {\n  // Simple relation check - one term contains the other\n  return term1.includes(term2) || term2.includes(term1);\n}\n\n/**\n * Finds snippets in messages that contain a specific term\n *\n * @param {Array} messages - Messages to search\n * @param {string} term - Term to search for\n * @returns {Array} Relevant snippets\n * @private\n */\nfunction _findRelevantSnippets(messages, term) {\n  try {\n    if (!messages || !Array.isArray(messages) || messages.length === 0) {\n      return [];\n    }\n\n    const snippets = [];\n    const termRegex = new RegExp(`\\\\b${term}\\\\b`, \"i\");\n\n    for (const message of messages) {\n      if (!message.content) continue;\n\n      // If term found in message\n      if (termRegex.test(message.content)) {\n        // Extract a snippet around the term\n        const sentences = message.content.split(/[.!?]+/);\n        for (const sentence of sentences) {\n          if (termRegex.test(sentence)) {\n            snippets.push({\n              text: sentence.trim(),\n              role: message.role,\n              messageId: message.message_id || message.messageId,\n            });\n          }\n        }\n      }\n    }\n\n    return snippets;\n  } catch (error) {\n    logMessage(\"WARN\", `Error finding relevant snippets`, {\n      error: error.message,\n    });\n    return [];\n  }\n}\n\n/**\n * Promotes patterns from a conversation to the global pattern repository\n *\n * @param {string} conversationId - The ID of the conversation\n * @param {string} outcome - The outcome of the conversation\n * @returns {Promise<Object>} Promoted patterns data\n * @private\n */\nasync function _promoteConversationPatterns(conversationId, outcome) {\n  try {\n    console.log(\n      `[_promoteConversationPatterns] Promoting patterns for conversation ${conversationId}`\n    );\n\n    // 1. Extract patterns from the conversation\n    const patterns = await LearningSystems.extractPatternsFromConversation(\n      conversationId\n    );\n\n    if (!patterns || patterns.length === 0) {\n      console.log(\n        `[_promoteConversationPatterns] No patterns found in conversation ${conversationId}`\n      );\n      return {\n        promoted: 0,\n        patterns: [],\n      };\n    }\n\n    console.log(\n      `[_promoteConversationPatterns] Found ${patterns.length} patterns to evaluate for promotion`\n    );\n\n    // 2. Prepare data for tracking promotion results\n    const promotedPatterns = {\n      promoted: 0,\n      patterns: [],\n    };\n\n    // Set minimum confidence threshold based on outcome\n    let minConfidence = 0.5; // Default threshold\n    if (outcome === \"completed\") minConfidence = 0.6;\n    if (outcome === \"abandoned\") minConfidence = 0.7; // Higher threshold for abandoned conversations\n\n    // 3. Process each pattern for potential promotion\n    for (const pattern of patterns) {\n      try {\n        // Skip patterns that are already global\n        if (pattern.is_global) {\n          promotedPatterns.patterns.push({\n            patternId: pattern.pattern_id,\n            name: pattern.name,\n            type: pattern.pattern_type,\n            promoted: false,\n            confidence: pattern.confidence_score,\n          });\n          continue;\n        }\n\n        // Skip patterns with confidence below threshold\n        if (pattern.confidence_score < minConfidence) {\n          promotedPatterns.patterns.push({\n            patternId: pattern.pattern_id,\n            name: pattern.name,\n            type: pattern.pattern_type,\n            promoted: false,\n            confidence: pattern.confidence_score,\n          });\n          continue;\n        }\n\n        // Promote pattern to global repository\n        await GlobalPatternRepository.promotePatternToGlobal(\n          pattern.pattern_id,\n          pattern.confidence_score\n        );\n\n        // Reinforce the pattern based on conversation outcome\n        const observationType =\n          outcome === \"completed\" || outcome === \"reference_only\"\n            ? \"confirmation\"\n            : \"usage\";\n\n        await GlobalPatternRepository.reinforcePattern(\n          pattern.pattern_id,\n          observationType,\n          { conversationId }\n        );\n\n        // Record successful promotion\n        promotedPatterns.promoted++;\n        promotedPatterns.patterns.push({\n          patternId: pattern.pattern_id,\n          name: pattern.name,\n          type: pattern.pattern_type,\n          promoted: true,\n          confidence: pattern.confidence_score,\n        });\n\n        console.log(\n          `[_promoteConversationPatterns] Successfully promoted pattern ${pattern.pattern_id}`\n        );\n      } catch (error) {\n        console.warn(\n          `[_promoteConversationPatterns] Error processing pattern ${pattern.pattern_id}:`,\n          error\n        );\n        // Continue with next pattern\n      }\n    }\n\n    console.log(\n      `[_promoteConversationPatterns] Promoted ${promotedPatterns.promoted} patterns to global repository`\n    );\n    return promotedPatterns;\n  } catch (error) {\n    console.error(\n      `[_promoteConversationPatterns] Error promoting patterns:`,\n      error\n    );\n    return {\n      promoted: 0,\n      patterns: [],\n      error: error.message,\n    };\n  }\n}\n\n/**\n * Finds and synthesizes insights from related conversations\n *\n * @param {string} conversationId - The ID of the current conversation\n * @param {Array} conversationTopics - Topics from the current conversation\n * @param {string} conversationPurpose - Purpose of the current conversation\n * @returns {Promise<Object>} Related conversations data with synthesized insights\n * @private\n */\nasync function _findAndSynthesizeRelatedConversations(\n  conversationId,\n  conversationTopics,\n  conversationPurpose\n) {\n  try {\n    console.log(\n      `[_findAndSynthesizeRelatedConversations] Finding related conversations for ${conversationId}`\n    );\n\n    // 1. Extract keywords from conversation topics\n    const topicKeywords = new Set();\n\n    // Ensure conversationTopics is an array before using forEach\n    if (conversationTopics && Array.isArray(conversationTopics)) {\n      conversationTopics.forEach((topic) => {\n        if (topic.keywords && Array.isArray(topic.keywords)) {\n          topic.keywords.forEach((kw) => topicKeywords.add(kw));\n        }\n      });\n    } else {\n      console.warn(\n        `[_findAndSynthesizeRelatedConversations] conversationTopics is not an array:`,\n        typeof conversationTopics\n      );\n    }\n\n    const keywordArray = Array.from(topicKeywords);\n\n    // 2. Get recent conversation events from timeline (excluding current conversation)\n    const recentConversationEvents = await TimelineManagerLogic.getEvents({\n      types: [\"conversation_end\", \"conversation_completed\"],\n      limit: 10,\n      excludeConversationId: conversationId,\n    });\n\n    if (!recentConversationEvents || recentConversationEvents.length === 0) {\n      console.log(\n        `[_findAndSynthesizeRelatedConversations] No recent conversations found to compare`\n      );\n      return {\n        relatedCount: 0,\n        conversations: [],\n        synthesizedInsights: [],\n      };\n    }\n\n    // 3. Score conversations by relevance\n    const scoredConversations = [];\n\n    for (const event of recentConversationEvents) {\n      try {\n        if (!event.data || !event.conversation_id) continue;\n\n        // Get conversation topics for comparison\n        const eventTopics =\n          await ConversationIntelligence.getConversationTopics(\n            event.conversation_id\n          );\n\n        // Extract keywords from event topics\n        const eventKeywords = new Set();\n\n        // Ensure eventTopics is an array before using forEach\n        if (eventTopics && Array.isArray(eventTopics)) {\n          eventTopics.forEach((topic) => {\n            if (topic.keywords && Array.isArray(topic.keywords)) {\n              topic.keywords.forEach((kw) => eventKeywords.add(kw));\n            }\n          });\n        } else {\n          console.warn(\n            `[_findAndSynthesizeRelatedConversations] eventTopics for ${event.conversation_id} is not an array`\n          );\n          continue; // Skip this event if topics aren't available\n        }\n\n        // Calculate keyword overlap (Jaccard similarity)\n        const overlapCount = keywordArray.filter((kw) =>\n          eventKeywords.has(kw)\n        ).length;\n        const totalUniqueKeywords = new Set([...keywordArray, ...eventKeywords])\n          .size;\n\n        const similarityScore =\n          totalUniqueKeywords > 0 ? overlapCount / totalUniqueKeywords : 0;\n\n        // Find common topics by name\n        const commonTopics = [];\n\n        // Make sure both are arrays before finding common topics\n        if (\n          eventTopics &&\n          Array.isArray(eventTopics) &&\n          conversationTopics &&\n          Array.isArray(conversationTopics)\n        ) {\n          eventTopics.forEach((eventTopic) => {\n            conversationTopics.forEach((currentTopic) => {\n              if (\n                eventTopic.topic_name &&\n                currentTopic.topic_name &&\n                eventTopic.topic_name.toLowerCase() ===\n                  currentTopic.topic_name.toLowerCase()\n              ) {\n                commonTopics.push(eventTopic.topic_name);\n              }\n            });\n          });\n        }\n\n        // Only consider conversations with some similarity\n        if (similarityScore > 0.2 || commonTopics.length > 0) {\n          scoredConversations.push({\n            conversationId: event.conversation_id,\n            summary: event.data.summary || \"No summary available\",\n            timestamp: event.timestamp,\n            similarityScore,\n            commonTopics,\n          });\n        }\n      } catch (error) {\n        console.warn(\n          `[_findAndSynthesizeRelatedConversations] Error processing event ${event.event_id}:`,\n          error\n        );\n        // Continue with next event\n      }\n    }\n\n    // Sort by similarity score descending\n    scoredConversations.sort((a, b) => b.similarityScore - a.similarityScore);\n\n    // Limit to top 5 most similar\n    const relatedConversations = scoredConversations.slice(0, 5);\n\n    console.log(\n      `[_findAndSynthesizeRelatedConversations] Found ${relatedConversations.length} related conversations`\n    );\n\n    // 4. Synthesize insights from related conversations\n    const synthesizedInsights =\n      await _synthesizeInsightsFromRelatedConversations(\n        relatedConversations,\n        conversationPurpose\n      );\n\n    return {\n      relatedCount: relatedConversations.length,\n      conversations: relatedConversations,\n      synthesizedInsights,\n    };\n  } catch (error) {\n    console.error(\n      `[_findAndSynthesizeRelatedConversations] Error finding related conversations:`,\n      error\n    );\n    return {\n      relatedCount: 0,\n      conversations: [],\n      synthesizedInsights: [],\n      error: error.message,\n    };\n  }\n}\n\n/**\n * Synthesizes insights from related conversations\n *\n * @param {Array} relatedConversations - Array of related conversation data\n * @param {string} currentPurpose - Purpose of the current conversation\n * @returns {Promise<Array>} Array of synthesized insights by topic\n * @private\n */\nasync function _synthesizeInsightsFromRelatedConversations(\n  relatedConversations,\n  currentPurpose\n) {\n  try {\n    // If no related conversations, return empty insights\n    if (!relatedConversations || relatedConversations.length === 0) {\n      return [];\n    }\n\n    // Group conversations by common topics\n    const conversationsByTopic = {};\n\n    // First, identify common topics across conversations\n    relatedConversations.forEach((conversation) => {\n      if (conversation.commonTopics && conversation.commonTopics.length > 0) {\n        conversation.commonTopics.forEach((topic) => {\n          if (!conversationsByTopic[topic]) {\n            conversationsByTopic[topic] = [];\n          }\n          conversationsByTopic[topic].push(conversation);\n        });\n      }\n    });\n\n    // If there are no common topics, create a synthetic topic based on purpose\n    if (Object.keys(conversationsByTopic).length === 0 && currentPurpose) {\n      const syntheticTopic = `Conversations about ${currentPurpose}`;\n      conversationsByTopic[syntheticTopic] = relatedConversations;\n    }\n\n    // Generate insights for each topic group\n    const insights = [];\n\n    for (const [topic, conversations] of Object.entries(conversationsByTopic)) {\n      // Only synthesize if we have enough conversations on this topic\n      if (conversations.length >= 2) {\n        // Combine summaries for synthesis\n        const combinedSummaries = conversations\n          .map((c) => c.summary)\n          .join(\" | \");\n\n        // Generate synthesized insight using ContextCompressorLogic\n        const insight = await ContextCompressorLogic.summarizeText(\n          combinedSummaries,\n          {\n            targetLength: 150,\n            preserveKeyPoints: true,\n          }\n        );\n\n        insights.push({\n          topic,\n          insight,\n          conversationCount: conversations.length,\n          sourceSummaries: conversations.map((c) => ({\n            conversationId: c.conversationId,\n            summary: c.summary,\n          })),\n        });\n      }\n    }\n\n    return insights;\n  } catch (error) {\n    console.error(\n      `[_synthesizeInsightsFromRelatedConversations] Error synthesizing insights:`,\n      error\n    );\n    return [];\n  }\n}\n\n/**\n * Generates next step suggestions based on conversation analysis\n *\n * @param {string} conversationId - The ID of the conversation\n * @param {string|Object} purpose - The purpose of the conversation (string or object with purposeType)\n * @param {string} summary - The conversation summary\n * @param {Object} extractedLearnings - The extracted learnings from the conversation\n * @returns {Promise<Object>} Next steps recommendations\n * @private\n */\nasync function _generateNextStepSuggestions(\n  conversationId,\n  purpose,\n  summary,\n  extractedLearnings\n) {\n  try {\n    console.log(\n      `[_generateNextStepSuggestions] Generating next steps for conversation ${conversationId}`\n    );\n\n    // Initialize results\n    const result = {\n      suggestedNextSteps: [],\n      followUpTopics: [],\n      referenceMaterials: [],\n    };\n\n    // 1. Extract key terms from summary for searching reference materials\n    const tokens = TextTokenizerLogic.tokenize(summary);\n    const keywords = TextTokenizerLogic.extractKeywords(tokens, 10);\n\n    // Extract purposeType from purpose object or use purpose directly if it's a string\n    let purposeType = \"general_query\"; // Default purpose type\n\n    if (purpose) {\n      if (typeof purpose === \"string\") {\n        purposeType = purpose;\n      } else if (typeof purpose === \"object\" && purpose.purposeType) {\n        purposeType = purpose.purposeType;\n      } else if (typeof purpose === \"object\" && purpose.purpose_type) {\n        purposeType = purpose.purpose_type;\n      }\n    }\n\n    console.log(\n      `[_generateNextStepSuggestions] Using purpose type: ${purposeType}`\n    );\n\n    // Use purpose to determine likely next steps\n    let nextSteps = [];\n    let followUpTopics = [];\n\n    if (purposeType) {\n      // Convert purposeType to lowercase string for safer comparison\n      const purposeTypeLower =\n        typeof purposeType === \"string\"\n          ? purposeType.toLowerCase()\n          : \"general_query\";\n\n      // Different next steps based on conversation purpose\n      switch (purposeTypeLower) {\n        case \"debugging\":\n        case \"bug_fixing\":\n          nextSteps.push({\n            action: \"Create a test case that verifies the bug fix\",\n            priority: \"high\",\n            rationale: \"Ensure the bug doesn't reoccur in the future\",\n          });\n          nextSteps.push({\n            action: \"Document the root cause and solution\",\n            priority: \"medium\",\n            rationale: \"Help prevent similar issues in the future\",\n          });\n          break;\n\n        case \"feature_planning\":\n        case \"design_discussion\":\n          nextSteps.push({\n            action: \"Create tickets/tasks for implementation work\",\n            priority: \"high\",\n            rationale: \"Break down the feature into manageable pieces\",\n          });\n          nextSteps.push({\n            action: \"Draft initial implementation plan with milestones\",\n            priority: \"medium\",\n            rationale: \"Establish a timeline and checkpoints\",\n          });\n          break;\n\n        case \"code_review\":\n          nextSteps.push({\n            action: \"Address feedback points and resubmit for review\",\n            priority: \"high\",\n            rationale: \"Incorporate the suggested improvements\",\n          });\n          nextSteps.push({\n            action: \"Update documentation to reflect changes\",\n            priority: \"medium\",\n            rationale: \"Keep documentation in sync with code\",\n          });\n          break;\n\n        case \"onboarding\":\n        case \"knowledge_sharing\":\n          nextSteps.push({\n            action: \"Create summary documentation of discussed topics\",\n            priority: \"high\",\n            rationale: \"Solidify knowledge transfer\",\n          });\n          nextSteps.push({\n            action: \"Schedule follow-up session for additional questions\",\n            priority: \"medium\",\n            rationale: \"Address remaining questions after initial processing\",\n          });\n          break;\n\n        default:\n          // Generic next steps\n          nextSteps.push({\n            action: \"Document key decisions from the conversation\",\n            priority: \"medium\",\n            rationale: \"Preserve important context for future reference\",\n          });\n      }\n    }\n\n    // 2. Add follow-up topics based on extracted learnings\n    if (extractedLearnings && extractedLearnings.learnings) {\n      // Find design decisions that may need follow-up\n      const designDecisions = extractedLearnings.learnings.filter(\n        (l) => l.type === \"design_decision\"\n      );\n\n      if (designDecisions.length > 0) {\n        const highConfidenceDecisions = designDecisions\n          .filter((d) => d.confidence >= 0.7)\n          .slice(0, 2);\n\n        highConfidenceDecisions.forEach((decision) => {\n          followUpTopics.push({\n            topic: `Implementation details for: ${decision.content}`,\n            priority: \"high\",\n            rationale: \"Turn design decision into concrete implementation\",\n          });\n        });\n      }\n\n      // Find bug patterns that may need follow-up\n      const bugPatterns = extractedLearnings.learnings.filter(\n        (l) => l.type === \"bug_pattern\"\n      );\n\n      if (bugPatterns.length > 0) {\n        const criticalBugs = bugPatterns\n          .filter((b) => b.confidence >= 0.8)\n          .slice(0, 2);\n\n        criticalBugs.forEach((bug) => {\n          followUpTopics.push({\n            topic: `Root cause analysis for: ${bug.content}`,\n            priority: \"medium\",\n            rationale: \"Prevent similar bugs in the future\",\n          });\n        });\n      }\n    }\n\n    // 3. Search for reference materials based on keywords\n    try {\n      // Only proceed with search if keywords are valid strings\n      const validKeywords = Array.isArray(keywords)\n        ? keywords.filter((kw) => typeof kw === \"string\")\n        : [];\n\n      if (validKeywords.length > 0) {\n        const referenceResults = await SmartSearchServiceLogic.searchByKeywords(\n          validKeywords,\n          {\n            fileTypes: [\"md\", \"txt\", \"rst\", \"pdf\", \"doc\"],\n            maxResults: 5,\n            searchDocumentation: true,\n          }\n        );\n\n        const referenceMaterials = referenceResults.map((result) => ({\n          title: result.name || result.file_path || \"Unnamed reference\",\n          path: result.file_path,\n          type: result.entity_type || \"document\",\n          relevance: result.score || 0.5,\n        }));\n\n        result.referenceMaterials = referenceMaterials;\n      }\n    } catch (error) {\n      console.error(`Error in searchByKeywords:`, error);\n      // Continue with empty reference materials\n    }\n\n    // 4. Combine all results\n    result.suggestedNextSteps = nextSteps;\n    result.followUpTopics = followUpTopics;\n\n    console.log(\n      `[_generateNextStepSuggestions] Generated ${nextSteps.length} next steps and ${followUpTopics.length} follow-up topics`\n    );\n\n    return result;\n  } catch (error) {\n    console.error(\n      `[_generateNextStepSuggestions] Error generating next steps:`,\n      error\n    );\n    return {\n      suggestedNextSteps: [],\n      followUpTopics: [],\n      referenceMaterials: [],\n      error: error.message,\n    };\n  }\n}\n\n// Export the tool definition for server registration\nexport default {\n  name: \"finalize_conversation_context\",\n  description:\n    \"Finalizes a conversation context, extracting learnings, promoting patterns, and generating insights\",\n  inputSchema: finalizeConversationContextInputSchema,\n  outputSchema: finalizeConversationContextOutputSchema,\n  handler,\n};\n", "/**\n * LearningSystems.js\n *\n * Provides functionality for extracting patterns, insights and learnings from conversations.\n */\n\nimport * as ConversationIntelligence from \"./ConversationIntelligence.js\";\n\n/**\n * Extracts patterns from a conversation's history\n *\n * @param {string} conversationId - The conversation ID\n * @returns {Promise<Array>} Array of extracted patterns\n */\nexport async function extractPatternsFromConversation(conversationId) {\n  try {\n    console.log(\n      `[LearningSystem] Extracting patterns from conversation ${conversationId}`\n    );\n\n    // Fetch the conversation history\n    const conversationHistory =\n      await ConversationIntelligence.getConversationHistory(\n        conversationId,\n        50, // Limit to the most recent 50 messages\n        0 // No offset\n      );\n\n    if (!conversationHistory || conversationHistory.length === 0) {\n      console.log(\n        `[LearningSystem] No messages found in conversation ${conversationId}`\n      );\n      return [];\n    }\n\n    // For now, return an empty array since this is a placeholder implementation\n    // In a real implementation, we would have logic to detect code patterns\n    return [];\n  } catch (error) {\n    console.error(\n      `[LearningSystem] Error extracting patterns: ${error.message}`\n    );\n    return [];\n  }\n}\n\n/**\n * Extracts bug patterns from a conversation's history\n *\n * @param {string} conversationId - The conversation ID\n * @returns {Promise<Array>} Array of extracted bug patterns\n */\nexport async function extractBugPatternsFromConversation(conversationId) {\n  try {\n    console.log(\n      `[LearningSystem] Extracting bug patterns from conversation ${conversationId}`\n    );\n\n    // Fetch the conversation history\n    const conversationHistory =\n      await ConversationIntelligence.getConversationHistory(\n        conversationId,\n        50, // Limit to the most recent 50 messages\n        0 // No offset\n      );\n\n    if (!conversationHistory || conversationHistory.length === 0) {\n      console.log(\n        `[LearningSystem] No messages found in conversation ${conversationId}`\n      );\n      return [];\n    }\n\n    // Filter to focus on user messages about errors/bugs and assistant responses\n    const errorKeywords = [\n      \"error\",\n      \"bug\",\n      \"issue\",\n      \"problem\",\n      \"crash\",\n      \"fail\",\n      \"exception\",\n      \"TypeError\",\n      \"undefined\",\n    ];\n\n    // Find messages discussing errors\n    const errorDiscussions = [];\n\n    for (let i = 0; i < conversationHistory.length; i++) {\n      const message = conversationHistory[i];\n\n      // Check if this is a user message mentioning errors\n      if (\n        message.role === \"user\" &&\n        errorKeywords.some((keyword) =>\n          message.content.toLowerCase().includes(keyword)\n        )\n      ) {\n        // If this has a response, create a pair\n        if (\n          i + 1 < conversationHistory.length &&\n          conversationHistory[i + 1].role === \"assistant\"\n        ) {\n          errorDiscussions.push({\n            errorMessage: message.content,\n            solutionMessage: conversationHistory[i + 1].content,\n          });\n        }\n      }\n    }\n\n    // Convert these discussions into bug patterns\n    const bugPatterns = errorDiscussions.map((discussion, index) => {\n      // Extract the error description from the user message\n      const errorDescription = discussion.errorMessage.substring(0, 100);\n\n      // Extract the solution from the assistant message\n      const solution = discussion.solutionMessage.substring(0, 150);\n\n      // Generate a reasonable name based on the error\n      let name = `Bug Pattern ${index + 1}`;\n\n      // Find specific error types mentioned in the message\n      const errorTypeMatches = discussion.errorMessage.match(\n        /(TypeError|ReferenceError|SyntaxError|RangeError|Error):/\n      );\n      if (errorTypeMatches && errorTypeMatches[1]) {\n        name = `${errorTypeMatches[1]} Pattern`;\n      } else {\n        // Or try to extract a key term\n        const keyTerms = errorKeywords.filter((term) =>\n          discussion.errorMessage.toLowerCase().includes(term)\n        );\n\n        if (keyTerms.length > 0) {\n          name = `${\n            keyTerms[0].charAt(0).toUpperCase() + keyTerms[0].slice(1)\n          } Pattern`;\n        }\n      }\n\n      // Create a complete bug pattern with all required fields\n      return {\n        name: name,\n        description: errorDescription,\n        solution: solution || \"No specific solution identified\",\n        detected_at: new Date().toISOString(),\n        source_conversation_id: conversationId,\n        frequency: 1,\n        confidence_score: 0.7,\n      };\n    });\n\n    console.log(\n      `[LearningSystem] Extracted ${bugPatterns.length} bug patterns from conversation ${conversationId}`\n    );\n    return bugPatterns;\n  } catch (error) {\n    console.error(\n      `[LearningSystem] Error extracting bug patterns: ${error.message}`\n    );\n    return [];\n  }\n}\n\n/**\n * Extracts key-value pairs from a conversation's history\n *\n * @param {string} conversationId - The conversation ID\n * @returns {Promise<Array>} Array of extracted key-value pairs\n */\nexport async function extractKeyValuePairsFromConversation(conversationId) {\n  try {\n    console.log(\n      `[LearningSystem] Extracting key-value pairs from conversation ${conversationId}`\n    );\n\n    // Fetch the conversation history\n    const conversationHistory =\n      await ConversationIntelligence.getConversationHistory(\n        conversationId,\n        50, // Limit to the most recent 50 messages\n        0 // No offset\n      );\n\n    if (!conversationHistory || conversationHistory.length === 0) {\n      console.log(\n        `[LearningSystem] No messages found in conversation ${conversationId}`\n      );\n      return [];\n    }\n\n    // Key-value pairs are typically in formats like:\n    // \"X is Y\", \"X = Y\", \"X: Y\", \"The X of Y is Z\"\n    const keyValuePairs = [];\n\n    // Simple pattern matching for key-value pairs\n    const keyValuePatterns = [\n      /(\\w+[\\s\\w]*)\\s+is\\s+([\\w\\s]+)/i, // \"X is Y\"\n      /(\\w+[\\s\\w]*)\\s*=\\s*([\\w\\s]+)/i, // \"X = Y\"\n      /(\\w+[\\s\\w]*)\\s*:\\s*([\\w\\s]+)/i, // \"X: Y\"\n      /the\\s+(\\w+[\\s\\w]*)\\s+of\\s+(\\w+[\\s\\w]*)\\s+is\\s+([\\w\\s]+)/i, // \"The X of Y is Z\"\n    ];\n\n    // Extract key-value pairs from messages\n    for (const message of conversationHistory) {\n      const content = message.content || \"\";\n      const sentences = content.split(/[.!?]+/);\n\n      for (const sentence of sentences) {\n        if (sentence.trim().length === 0) continue;\n\n        // Try each pattern\n        for (const pattern of keyValuePatterns) {\n          const match = sentence.match(pattern);\n          if (match) {\n            if (pattern.toString().includes(\"of\")) {\n              // For \"The X of Y is Z\" pattern\n              keyValuePairs.push({\n                key: `${match[1].trim()} of ${match[2].trim()}`,\n                value: match[3].trim(),\n                confidence: 0.7,\n                source: \"conversation\",\n                source_id: conversationId,\n                timestamp: new Date().toISOString(),\n              });\n            } else {\n              // For other patterns\n              keyValuePairs.push({\n                key: match[1].trim(),\n                value: match[2].trim(),\n                confidence: 0.8,\n                source: \"conversation\",\n                source_id: conversationId,\n                timestamp: new Date().toISOString(),\n              });\n            }\n          }\n        }\n      }\n    }\n\n    console.log(\n      `[LearningSystem] Extracted ${keyValuePairs.length} key-value pairs from conversation ${conversationId}`\n    );\n    return keyValuePairs;\n  } catch (error) {\n    console.error(\n      `[LearningSystem] Error extracting key-value pairs: ${error.message}`\n    );\n    return [];\n  }\n}\n\n/**\n * Extracts key-value pairs from conversation messages\n *\n * @param {string|Array} conversationIdOrMessages - The conversation ID or array of messages\n * @returns {Promise<Array>} Array of extracted key-value pairs\n */\nexport async function extractKeyValuePairs(conversationIdOrMessages) {\n  try {\n    let messages;\n\n    // Check if input is a string (conversationId) or array (messages)\n    if (typeof conversationIdOrMessages === \"string\") {\n      console.log(\n        `[LearningSystem] Extracting key-value pairs from conversation ${conversationIdOrMessages}`\n      );\n\n      // Get the conversation messages\n      messages = await ConversationIntelligence.getConversationHistory(\n        conversationIdOrMessages,\n        50, // Limit to most recent 50 messages\n        0 // No offset\n      );\n    } else if (Array.isArray(conversationIdOrMessages)) {\n      messages = conversationIdOrMessages;\n    } else {\n      console.error(\n        `[LearningSystem] Invalid input type for extractKeyValuePairs: ${typeof conversationIdOrMessages}`\n      );\n      return [];\n    }\n\n    // Return early if no messages found\n    if (!messages || !Array.isArray(messages) || messages.length === 0) {\n      return [];\n    }\n\n    // Key-value pairs are typically in formats like:\n    // \"X is Y\", \"X = Y\", \"X: Y\", \"The X of Y is Z\"\n    const keyValuePairs = [];\n\n    // Simple pattern matching for key-value pairs\n    const keyValuePatterns = [\n      /(\\w+[\\s\\w]*)\\s+is\\s+([\\w\\s]+)/i, // \"X is Y\"\n      /(\\w+[\\s\\w]*)\\s*=\\s*([\\w\\s]+)/i, // \"X = Y\"\n      /(\\w+[\\s\\w]*)\\s*:\\s*([\\w\\s]+)/i, // \"X: Y\"\n      /the\\s+(\\w+[\\s\\w]*)\\s+of\\s+(\\w+[\\s\\w]*)\\s+is\\s+([\\w\\s]+)/i, // \"The X of Y is Z\"\n    ];\n\n    // Extract key-value pairs from messages\n    for (const message of messages) {\n      const content = message.content || \"\";\n      const sentences = content.split(/[.!?]+/);\n\n      for (const sentence of sentences) {\n        if (sentence.trim().length === 0) continue;\n\n        // Try each pattern\n        for (const pattern of keyValuePatterns) {\n          const match = sentence.match(pattern);\n          if (match) {\n            if (pattern.toString().includes(\"of\")) {\n              // For \"The X of Y is Z\" pattern\n              keyValuePairs.push({\n                key: `${match[1].trim()} of ${match[2].trim()}`,\n                value: match[3].trim(),\n                confidence: 0.7,\n                source: \"conversation\",\n                source_id:\n                  typeof conversationIdOrMessages === \"string\"\n                    ? conversationIdOrMessages\n                    : message.conversation_id,\n                timestamp: new Date().toISOString(),\n              });\n            } else {\n              // For other patterns\n              keyValuePairs.push({\n                key: match[1].trim(),\n                value: match[2].trim(),\n                confidence: 0.8,\n                source: \"conversation\",\n                source_id:\n                  typeof conversationIdOrMessages === \"string\"\n                    ? conversationIdOrMessages\n                    : message.conversation_id,\n                timestamp: new Date().toISOString(),\n              });\n            }\n          }\n        }\n      }\n    }\n\n    console.log(\n      `[LearningSystem] Extracted ${keyValuePairs.length} key-value pairs`\n    );\n    return keyValuePairs;\n  } catch (error) {\n    console.error(\n      `[LearningSystem] Error extracting key-value pairs: ${error.message}`\n    );\n    return [];\n  }\n}\n", "/**\n * tools/index.js\n *\n * Aggregates and exports all MCP tool definitions for registration with the MCP server.\n */\n\nimport initializeConversationContextTool from \"./initializeConversationContext.tool.js\";\nimport updateConversationContextTool from \"./updateConversationContext.tool.js\";\nimport retrieveRelevantContextTool from \"./retrieveRelevantContext.tool.js\";\nimport recordMilestoneContextTool from \"./recordMilestoneContext.tool.js\";\nimport finalizeConversationContextTool from \"./finalizeConversationContext.tool.js\";\n\nconst allTools = [\n  initializeConversationContextTool,\n  updateConversationContextTool,\n  retrieveRelevantContextTool,\n  recordMilestoneContextTool,\n  finalizeConversationContextTool,\n];\n\nexport default allTools;\n", "/**\n * mcpDevContextTools.js\n *\n * Provides wrapper functions for the MCP DevContext tools\n * to ensure proper callback handling and compatibility with MCP SDK.\n */\n\nimport { logMessage } from \"../utils/logger.js\";\n\n// Store conversation ID globally for this session\nif (typeof global.lastConversationId === \"undefined\") {\n  global.lastConversationId = null;\n}\n\n/**\n * Creates a wrapped handler for DevContext MCP tools that follows the MCP SDK pattern\n *\n * @param {Function} handler - The original tool handler function\n * @param {string} toolName - The name of the tool for logging purposes\n * @returns {Function} A wrapped handler function compatible with MCP SDK\n */\nexport function createToolHandler(handler, toolName) {\n  return async (params, context) => {\n    try {\n      logMessage(\"DEBUG\", `${toolName} tool handler invoked`, {\n        paramsKeys: Object.keys(params),\n      });\n\n      // Handle weird parameter structure with signal property\n      let actualParams = params;\n      if (\n        params &&\n        typeof params === \"object\" &&\n        Object.keys(params).length === 1 &&\n        params.signal &&\n        Object.keys(params.signal).length === 0\n      ) {\n        // If we're just getting a signal object with no real params, use defaults\n        actualParams = {};\n        logMessage(\n          \"WARN\",\n          `${toolName} received only signal object, using defaults`,\n          { params }\n        );\n      } else if (params && params.signal && Object.keys(params).length > 1) {\n        // If params contains signal plus other properties, extract just the other properties\n        const { signal, ...otherParams } = params;\n        actualParams = otherParams;\n        logMessage(\n          \"DEBUG\",\n          `${toolName} extracted parameters from signal object`,\n          {\n            extractedParams: Object.keys(actualParams),\n          }\n        );\n      }\n\n      // Extract additional parameters from any special formats\n      const extractedParams = extractParamsFromInput(actualParams);\n\n      // Log the extracted parameters for debugging\n      logMessage(\"DEBUG\", `${toolName} extracted parameters`, {\n        extractedParams: extractedParams,\n      });\n\n      // Generate default parameters for this specific tool\n      const defaultParams = createDefaultParamsForTool(toolName);\n\n      // Merge extracted parameters with defaults, prioritizing user-provided values\n      const mergedParams = { ...defaultParams, ...extractedParams };\n\n      // Log the merged parameters for debugging\n      logMessage(\"DEBUG\", `${toolName} merged parameters`, {\n        mergedParams: mergedParams,\n      });\n\n      // If conversation ID was provided, store it for future use\n      if (mergedParams.conversationId) {\n        global.lastConversationId = mergedParams.conversationId;\n      } else if (global.lastConversationId) {\n        // Use the last conversation ID if one wasn't provided\n        mergedParams.conversationId = global.lastConversationId;\n        logMessage(\n          \"INFO\",\n          `Using last conversation ID: ${global.lastConversationId}`\n        );\n      }\n\n      // Now call the handler with the properly merged parameters\n      const result = await handler(mergedParams, context);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: typeof result === \"string\" ? result : JSON.stringify(result),\n          },\n        ],\n      };\n    } catch (error) {\n      logMessage(\"ERROR\", `Error in ${toolName} tool handler`, {\n        error: error.message,\n        stack: error.stack,\n      });\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify({\n              error: true,\n              message: error.message,\n              details: error.stack,\n            }),\n          },\n        ],\n      };\n    }\n  };\n}\n\n/**\n * Extracts parameters from various input formats\n *\n * @param {any} input - The input parameters (could be object, string, etc.)\n * @returns {Object} Extracted parameters\n */\nfunction extractParamsFromInput(input) {\n  const extractedParams = {};\n\n  try {\n    // Case 1: Input is already an object\n    if (input && typeof input === \"object\") {\n      // Copy all properties except signal and requestId\n      Object.keys(input).forEach((key) => {\n        if (key !== \"signal\" && key !== \"requestId\") {\n          extractedParams[key] = input[key];\n        }\n      });\n\n      // Special case: If there's a random_string property, try to parse it\n      if (input.random_string) {\n        try {\n          // Try to parse as JSON\n          const parsedJson = JSON.parse(input.random_string);\n          Object.assign(extractedParams, parsedJson);\n        } catch (e) {\n          // If not JSON, use as-is if it looks like a conversationId\n          if (\n            typeof input.random_string === \"string\" &&\n            input.random_string.length > 30 &&\n            input.random_string.includes(\"-\")\n          ) {\n            extractedParams.conversationId = input.random_string;\n          }\n        }\n      }\n\n      // Handle direct parameters from cursor API or user input\n      if (input.conversationId) {\n        extractedParams.conversationId = input.conversationId;\n      }\n\n      if (input.initialQuery) {\n        extractedParams.initialQuery = input.initialQuery;\n      }\n\n      if (input.contextDepth) {\n        extractedParams.contextDepth = input.contextDepth;\n      }\n\n      if (input.query) {\n        extractedParams.query = input.query;\n      }\n\n      if (input.name) {\n        extractedParams.name = input.name;\n      }\n\n      // Process message array if present\n      if (input.newMessages) {\n        extractedParams.newMessages = Array.isArray(input.newMessages)\n          ? input.newMessages\n          : [input.newMessages];\n      }\n\n      // Process code changes if present\n      if (input.codeChanges) {\n        extractedParams.codeChanges = Array.isArray(input.codeChanges)\n          ? input.codeChanges\n          : [input.codeChanges];\n      }\n    }\n    // Case 2: Input is a string\n    else if (typeof input === \"string\") {\n      try {\n        // Try to parse as JSON\n        const parsedJson = JSON.parse(input);\n        Object.assign(extractedParams, parsedJson);\n      } catch (e) {\n        // If not JSON, use as conversationId if it looks like one\n        if (input.length > 30 && input.includes(\"-\")) {\n          extractedParams.conversationId = input;\n        }\n      }\n    }\n  } catch (e) {\n    logMessage(\"ERROR\", `Error extracting params: ${e.message}`);\n  }\n\n  return extractedParams;\n}\n\n/**\n * Creates default parameters for each tool type\n *\n * @param {string} toolName - The name of the tool\n * @returns {Object} Default parameters for the tool\n */\nfunction createDefaultParamsForTool(toolName) {\n  switch (toolName) {\n    case \"initialize_conversation_context\":\n      return {\n        initialQuery: \"Starting a new conversation with DevContext\",\n        includeArchitecture: true,\n        includeRecentConversations: true,\n        maxCodeContextItems: 5,\n        maxRecentChanges: 5,\n        contextDepth: \"standard\",\n      };\n    case \"update_conversation_context\":\n      return {\n        conversationId: global.lastConversationId,\n        newMessages: [\n          {\n            role: \"user\",\n            content: \"Working with DevContext tools\",\n          },\n        ],\n        preserveContextOnTopicShift: true,\n        contextIntegrationLevel: \"balanced\",\n        trackIntentTransitions: true,\n      };\n    case \"retrieve_relevant_context\":\n      return {\n        conversationId: global.lastConversationId,\n        query: \"DevContext tools and functionality\",\n        constraints: {\n          includeConversation: true,\n          crossTopicSearch: false,\n        },\n        contextFilters: {\n          minRelevanceScore: 0.3,\n        },\n        weightingStrategy: \"balanced\",\n        balanceStrategy: \"proportional\",\n        contextBalance: \"auto\",\n      };\n    case \"record_milestone_context\":\n      return {\n        conversationId: global.lastConversationId,\n        name: \"DevContext Tool Milestone\",\n        description: \"Milestone recorded during DevContext tools testing\",\n        milestoneCategory: \"uncategorized\",\n        assessImpact: true,\n      };\n    case \"finalize_conversation_context\":\n      return {\n        conversationId: global.lastConversationId,\n        clearActiveContext: false,\n        extractLearnings: true,\n        promotePatterns: true,\n        synthesizeRelatedTopics: true,\n        generateNextSteps: true,\n        outcome: \"completed\",\n      };\n    default:\n      return {};\n  }\n}\n\n/**\n * Creates a specialized wrapped handler for initialize_conversation_context\n *\n * @param {Function} handler - The original handler function\n * @returns {Function} A wrapped handler function\n */\nexport function createInitializeContextHandler(handler) {\n  return createToolHandler(handler, \"initialize_conversation_context\");\n}\n\n/**\n * Creates a specialized wrapped handler for finalize_conversation_context\n *\n * @param {Function} handler - The original handler function\n * @returns {Function} A wrapped handler function\n */\nexport function createFinalizeContextHandler(handler) {\n  return createToolHandler(handler, \"finalize_conversation_context\");\n}\n"],
  "mappings": "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,MACA,QACA,KACA,SACA,OACA,QACA,WACA,SACA,MACA,QACA,UACA,QACA,SACA,SACA,UACA,YACA,SACA,QACA,WACA,YACA,UACA,aACA,SACA,SACA,UACA,YACA,MACA,MACA,QACA,MACA,OACA,QACA,OACA,YACA,OACA,OACF,CAAC,EAGKZ,EAAY,IAAI,IAAI,CACxB,GAAGW,EACH,GAAGC,CACL,CAAC,EAGD,OAAQvC,EAAU,CAChB,IAAK,aACL,IAAK,aACL,IAAK,MACL,IAAK,MAEH,CACE,SACA,aACA,QACA,QACA,QACA,OACA,SACA,SACA,UACA,UACA,MACA,SACA,WACA,QACA,YACA,cACA,SACA,SACA,UACA,SACA,OACF,EAAE,QAASwC,GAASb,EAAU,IAAIa,CAAI,CAAC,EACvC,MAEF,IAAK,SAEH,CACE,MACA,SACA,OACA,KACA,SACA,OACA,KACA,KACA,MACA,MACA,KACA,SACA,WACA,OACA,QACA,SACA,MACA,QACA,SACA,QACA,OACA,OACA,OACA,OACA,QACA,QACA,MACA,MACF,EAAE,QAASA,GAASb,EAAU,IAAIa,CAAI,CAAC,EACvC,MAEF,IAAK,OAEH,CACE,OACA,UACA,OACA,OACA,QACA,MACA,OACA,QACA,SACA,aACA,WACA,eACA,YACA,WACA,SACA,UACA,SACA,QACA,YACA,SACA,MACF,EAAE,QAASA,GAASb,EAAU,IAAIa,CAAI,CAAC,EACvC,MAEF,IAAK,SACL,IAAK,KAEH,CACE,QACA,YACA,QACA,SACA,OACA,QACA,OACA,UACA,OACA,SACA,MACA,MACA,KACA,QACA,KACA,KACA,OACA,MACA,SACA,OACA,UACA,SACA,OACA,OACA,QACA,OACA,OACA,QACA,QACA,SACA,SACA,QACA,UACA,WACA,QACA,QACA,QACA,UACA,UACA,WACA,SACA,MACF,EAAE,QAASA,GAASb,EAAU,IAAIa,CAAI,CAAC,EACvC,MAEF,IAAK,OAEH,CACE,MACA,MACA,SACA,UACA,UACA,SACA,OACA,cACA,cACA,gBACA,SACA,OACA,QACA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CD,EAAM,QAAQ,IACrDC,CACF,EAEAD,EAAM,iBAAmB,CAAC,EAC1BA,EAAM,SAAW,CAAC,EAClBA,EAAM,SAAW,CAAC,EAGlBD,EAASC,EAAM,QAAQ,EAAIA,CAC7B,CAIF,IAAME,EAAa,CAAC,EAEpB,QAAWF,KAASF,EACdE,EAAM,iBAAmBD,EAASC,EAAM,eAAe,EAEzDD,EAASC,EAAM,eAAe,EAAE,SAAS,KAAKA,CAAK,EAGnDE,EAAW,KAAKF,CAAK,EAIzB,MAAO,CAAE,WAAAE,EAAY,SAAAH,CAAS,CAChC,OAASJ,EAAO,CACd,cAAQ,MACN,mDAAmDE,CAAc,IACjEF,CACF,EACM,IAAI,MAAM,oCAAoCA,EAAM,OAAO,EAAE,CACrE,CACF,CCn4BAQ,IACAC,IACA,OAAS,MAAMC,OAAc,OAa7B,IAAMC,GAAgB,CACpB,UAAW,CACT,SAAU,CACR,QACA,aACA,MACA,MACA,cACA,YACA,QACA,SACA,UACA,QACA,QACA,SACA,YACA,UACA,UACA,aACA,WACA,aACF,EACA,SAAU,CACR,cACA,UACA,cACA,eACA,gBACA,eACA,sBACF,EACA,OAAQ,CACV,EAEA,iBAAkB,CAChB,SAAU,CACR,cACA,SACA,cACA,YACA,WACA,UACA,OACA,gBACA,OACA,eACA,YACA,UACA,cACA,cACA,MACA,SACA,UACA,QACF,EACA,SAAU,CACR,gBACA,wBACA,cACA,eACA,mBACA,oBACF,EACA,OAAQ,EACV,EAEA,YAAa,CACX,SAAU,CACR,KACA,eACA,OACA,aACA,iBACA,SACA,UACA,WACA,UACA,WACA,aACA,QACA,QACA,aACA,cACA,SACF,EACA,SAAU,CACR,qBACA,WACA,iBACA,oBACA,qBACA,iBACF,EACA,OAAQ,GACV,EAEA,SAAU,CACR,SAAU,CACR,QACA,aACA,cACA,WACA,UACA,WACA,UACA,UACA,UACA,aACA,qBACA,gBACA,QACA,UACA,UACA,OACF,EACA,SAAU,CACR,2BACA,sBACA,qBACA,4BACA,cACF,EACA,OAAQ,EACV,EAEA,gBAAiB,CACf,SAAU,CACR,WACA,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",
  "names": ["dotenv", "TURSO_DATABASE_URL", "TURSO_AUTH_TOKEN", "LOG_LEVEL", "DB_LOGGING_ENABLED", "DEFAULT_TOKEN_BUDGET", "CONTEXT_DECAY_RATE", "MAX_CACHE_SIZE", "init_config", "__esmMin", "isInMcpMode", "LOG_LEVELS", "IN_MCP_MODE", "logMessage", "init_logger", "__esmMin", "init_config", "level", "message", "data", "upperLevel", "LOG_LEVEL", "logString", "dataString", "createClient", "migrateProjectPatternsTable", "inMcpMode", "tableExists", "tableExistsQuery", "executeQuery", "tableCheckError", "logMessage", "hasLanguageColumn", "columnCheckQuery", "row", "columnCheckError", "alterError", "indexError", "error", "dbClient", "getDbClient", "testDbConnection", "initializeDatabaseSchema", "init_db", "__esmMin", "init_config", "init_logger", "TURSO_DATABASE_URL", "errorMsg", "TURSO_AUTH_TOKEN", "client", "retryCount", "connError", "waitTime", "resolve", "sqlQuery", "args", "maxRetries", "result", "queryError", "isConnectionError", "success", "migrationError", "schemaStatements", "statement", "tokenize", "text", "language", "normalizedText", "tokenizeJavaScript", "tokenizePython", "tokenizeJavaLike", "tokenizeRuby", "tokenizeGo", "tokenizeGeneric", "identifyLanguageSpecificIdioms", "idioms", "identifyJavaScriptIdioms", "identifyPythonIdioms", "identifyCSharpIdioms", "promiseChainRegex", "match", "asyncAwaitRegex", "arrowCallbackRegex", "idiom", "listComprehensionRegex", "dictComprehensionRegex", "lambdaRegex", "generatorRegex", "linqMethodRegex", "linqQueryRegex", "extractKeywords", "tokens", "topN", "stopWords", "getStopWords", "termFrequencies", "token", "scoredKeywords", "frequency", "score", "isDomainSpecificToken", "applyLanguageSpecificBoosts", "a", "b", "commonStopWords", "commonProgrammingStopWords", "word", "commentPlaceholders", "commentCounter", "withoutComments", "placeholder", "stringPlaceholders", "stringCounter", "withoutImports", "expressions", "expContent", "exp", "expTokens", "tagName", "attributes", "attrMatches", "decoratorName", "paramMatch", "paramTokens", "moduleMatch", "importedMatch", "importSection", "namedImports", "part", "nsMatch", "mainTokens", "processedTokens", "camelTokens", "finalTokens", "strContent", "contentTokens", "commentTokens", "placeholderCounter", "withSpecialOps", "partTokens", "lines", "previousIndentLevel", "line", "indentMatch", "leadingSpaces", "dedentLevels", "i", "lineContent", "pythonKeywords", "keyword", "lineTokens", "snakeCaseTokens", "parts", "prefixLength", "withoutLambdas", "annotationName", "keyValuePairs", "pair", "valueTokens", "typeParams", "param", "lambdaTokens", "accessModifiers", "withAccessModifiers", "modifier", "regex", "packageName", "packageParts", "importName", "importParts", "linqKeywords", "withoutBlocks", "symbolName", "blockContent", "withRangeOps", "methodName", "className", "genericTokens", "rubyKeywords", "withBuiltins", "tagPairs", "key", "quotedValue", "value", "valueParts", "funcCallMatch", "cases", "caseStr", "caseContent", "caseTokens", "funcMatch", "typeName", "fieldMatches", "fieldMatch", "methodMatches", "methodMatch", "goBuiltins", "builtin", "goKeywords", "rawContent", "stem", "lowerWord", "stemmed", "init_TextTokenizerLogic", "__esmMin", "uuidv4", "addRelationship", "sourceEntityId", "targetEntityId", "relationshipType", "weight", "metadata", "relationshipId", "metadataJson", "executeQuery", "error", "getRelationships", "entityId", "direction", "types", "query", "queryParams", "typePlaceholders", "relationship", "init_RelationshipContextManagerLogic", "__esmMin", "init_db", "ContextCompressorLogic_exports", "__export", "compressContext", "manageTokenBudget", "summarizeCodeEntity", "summarizeText", "contextSnippets", "budget", "queryKeywords", "processedSnippets", "remainingBudget", "totalScore", "sum", "snippet", "budgetAllocations", "i", "content", "snippetBudget", "summarizedContent", "remainingSnippets", "remainingScores", "s", "j", "redistributeRemainingBudget", "originalSnippets", "processedMap", "ps", "snippetsToExpand", "a", "b", "additionalBudgetPerSnippet", "processedSnippet", "currentLength", "newBudget", "expandedContent", "text", "maxLength", "method", "ruleBased", "entity", "summarizeFunction", "summarizeClass", "summarizeFile", "lines", "signatureLine", "extractFunctionSignature", "truncateToMaxLength", "scoredLines", "scoreCodeLines", "summary", "commentBlock", "extractCommentBlock", "selectImportantLines", "classSignature", "extractClassSignature", "methodList", "extractMethodList", "importStatements", "line", "exportStatements", "remainingAfterImports", "signature", "methods", "methodRegex", "startFromLine", "match", "inComment", "commentLines", "entityType", "importantPatterns", "commonPatterns", "patterns", "score", "tokens", "tokenize", "keywordMatches", "keyword", "pattern", "selectedLines", "usedBudget", "highScoreLines", "item", "remainingLines", "sentences", "splitIntoSentences", "scoredSentences", "sentence", "index", "scoreSentence", "selectedSentences", "scored", "sentenceRegex", "matches", "totalSentences", "wordCount", "importantPhrases", "lowerSentence", "phrase", "contextItems", "options", "detailLevel", "targetTokens", "tokensPerChar", "charBudget", "scoredSnippets", "modifiedBudget", "processed", "originalItem", "init_ContextCompressorLogic", "__esmMin", "init_TextTokenizerLogic", "init_config", "init_db", "init_logger", "McpServer", "StdioServerTransport", "init_db", "uuidv4", "init_db", "init_TextTokenizerLogic", "uuidv4", "init_db", "init_TextTokenizerLogic", "init_RelationshipContextManagerLogic", "uuidv4", "crypto", "path", "init_db", "init_logger", "acorn", "buildAST", "content", "language", "inMcpMode", "logMessage", "normalizedLanguage", "ast", "error", "init_db", "init_TextTokenizerLogic", "searchByKeywords", "keywords", "options", "kw", "searchResults", "searchUsingFTS", "keywordResults", "searchUsingKeywords", "mergeSearchResults", "result", "error", "processedKeywords", "keyword", "stem", "char", "booleanOperator", "ftsQuery", "distance", "sql", "queryParams", "placeholders", "filePathConditions", "pathPattern", "sqlPattern", "limit", "results", "executeQuery", "mapToSearchResults", "term", "stemmedKeywords", "applyFilters", "rows", "row", "resultsA", "resultsB", "entityMap", "entityId", "existingResult", "combinedScore", "a", "b", "init_RelationshipContextManagerLogic", "init_db", "init_config", "calculateImportanceScore", "entity", "typeScores", "entityType", "score", "contentLength", "lineCount", "sizeBonus", "references", "executeQuery", "refCount", "refBonus", "error", "now", "lastModified", "daysSinceModified", "recencyBonus", "lastAccessed", "daysSinceAccessed", "accessBonus", "importantNamePatterns", "pattern", "applyDecayToAll", "accessThreshold", "query", "params", "CONTEXT_DECAY_RATE", "result", "executeQuery", "error", "init_logger", "calculateContentHash", "content", "crypto", "extractFilename", "filePath", "path", "detectLanguage", "languageHint", "extension", "getLineFromPosition", "position", "extractEntitiesWithRegex", "language", "entities", "patterns", "functionPattern", "match", "name", "startPosition", "startLine", "endLine", "classPattern", "extractEntitiesFromAST", "ast", "inMcpMode", "relationships", "idMap", "lines", "logMessage", "createEntity", "type", "endPosition", "rawContent", "parentEntity", "customMetadata", "entity", "visit", "node", "parentNode", "scope", "currentScope", "stmt", "params", "p", "functionEntity", "classEntity", "member", "methodEntity", "decl", "key", "child", "item", "indexCodeFile", "fileContent", "contentHash", "filename", "existingFile", "executeQuery", "fileEntityId", "uuidv4", "importanceScore", "calculateImportanceScore", "scoreError", "codeEntities", "buildAST", "entityRelationships", "parseError", "entityId", "entityForScoring", "summary", "summarizeCodeEntity", "entityForSummary", "summaryError", "keywords", "extractKeywords", "keyword", "keywordError", "rel", "addRelationship", "relError", "error", "indexConversationMessage", "message", "relatedContextEntityIds", "semanticMarkers", "sentimentIndicators", "timestamp", "existingMessageQuery", "existingMessage", "updateQuery", "updateParams", "updateResult", "updateError", "insertQuery", "insertParams", "insertResult", "insertError", "tokens", "tokenize", "init_TextTokenizerLogic", "init_db", "init_ContextCompressorLogic", "uuidv4", "TOPIC_SHIFT_MARKERS", "QUESTION_STARTERS", "detectTopicShift", "newMessage", "conversationHistory", "recentHistory", "keywordNoveltyScore", "calculateKeywordNovelty", "entityShiftScore", "calculateEntityShift", "hasConversationalMarkers", "detectConversationalMarkers", "questionShiftScore", "detectQuestionAnswerShift", "error", "newTokens", "tokenize", "newKeywords", "extractKeywords", "newKeywordSet", "historyKeywordSet", "message", "historyTokens", "keyword", "novelKeywordCount", "historyEntitySet", "id", "newEntityCount", "entityId", "messageContent", "lowerContent", "marker", "isQuestion", "previousQuestionCount", "questionAnswerPairCount", "i", "lastUserQuestionIndex", "findLastIndex", "msg", "lastUserQuestion", "calculateQuestionDifference", "content", "starter", "newQuestion", "previousQuestion", "prevTokens", "newSet", "prevSet", "intersectionSize", "token", "unionSize", "array", "predicate", "createNewTopicSegment", "conversationId", "startMessageId", "topicInfo", "topic_id", "topic_name", "messageResult", "executeQuery", "words", "primary_entities", "keywords", "start_timestamp", "insertQuery", "params", "closeTopicSegment", "topicId", "endMessageId", "messageTimestamp", "getActiveTopicForConversation", "result", "topic", "parsedTopic", "parseError", "generateTopicName", "messageIds", "messagesQuery", "messages", "executeQuery", "concatenatedContent", "msg", "tokens", "tokenize", "keywords", "extractKeywords", "entityReferences", "message", "entityIds", "entityQuery", "entities", "entity", "err", "topicName", "firstMsg", "firstFewWords", "error", "buildTopicHierarchy", "conversationId", "topics", "topicMap", "topic", "jsonError", "rootTopics", "init_TextTokenizerLogic", "init_db", "uuidv4", "PURPOSE_TYPES", "detectConversationPurpose", "messages", "messageArray", "concatenatedContent", "normalizedMessages", "msg", "userMessages", "tokens", "tokenize", "extractedKeywords", "extractKeywords", "purposeScores", "purposeType", "purposeData", "score", "keyword", "k", "pattern", "highestScore", "detectedPurpose", "maxPossibleScore", "confidence", "error", "getActivePurpose", "conversationId", "result", "executeQuery", "rows", "trackPurposeTransition", "previousPurposeType", "newPurposeType", "triggerMessageId", "activePurpose", "currentTime", "purpose_id", "start_timestamp", "metadata", "detectInitialPurpose", "conversationId", "initialQuery", "result", "detectConversationPurpose", "trackPurposeTransition", "trackingError", "error", "init_ContextCompressorLogic", "init_logger", "recordMessage", "messageContent", "role", "conversationId", "relatedContextEntityIds", "topicSegmentId", "userIntent", "message_id", "uuidv4", "timestamp", "logMessage", "semantic_markers", "identifyLanguageSpecificIdioms", "positiveKeywords", "negativeKeywords", "foundPositive", "kw", "foundNegative", "sentiment_indicators", "messageObject", "indexConversationMessage", "error", "detectTopicShift", "newMessageContent", "history", "getConversationHistory", "getConversationTopics", "hierarchical", "buildTopicHierarchy", "result", "executeQuery", "topic", "newTopic", "err", "summarizeConversation", "conversationId", "messages", "executeQuery", "logMessage", "concatenated", "m", "summarizeText", "initializeConversation", "initialQuery", "timestamp", "userMessageId", "uuidv4", "systemMessageId", "detectInitialPurpose", "createNewTopicSegment", "error", "getConversationHistory", "limit", "offset", "results", "message", "mappedMessage", "err", "getConversationPurpose", "activePurpose", "getActivePurpose", "getRecentMessages", "count", "init_ContextCompressorLogic", "init_TextTokenizerLogic", "init_db", "uuidv4", "init_db", "uuidv4", "recordEvent", "type", "data", "associatedEntityIds", "conversationId", "eventId", "dataJson", "entityIdsJson", "timestamp", "executeQuery", "error", "createSnapshot", "activeContextData", "name", "description", "timeline_event_id", "snapshot_id", "snapshot_data", "getEvents", "options", "types", "limit", "conversationId", "includeMilestones", "excludeConversationId", "query", "params", "milestoneEventTypes", "events", "executeQuery", "rows", "event", "error", "getRecentEventsForConversation", "conversationId", "limit", "eventTypes", "query", "params", "placeholders", "results", "executeQuery", "rows", "event", "error", "inferIntentFromQuery", "query", "conversationHistory", "intents", "intentScores", "normalizedQuery", "tokens", "tokenize", "keywords", "extractKeywords", "codePatterns", "pattern", "keywordPatterns", "patterns", "intent", "score", "recentMessages", "msg", "message", "normalizedContent", "maxScore", "inferredIntent", "predictFocusArea", "recentActivity", "currentCodeEdits", "pathFrequency", "entityFrequency", "activityTypes", "keywordsSet", "event", "path", "segments", "i", "dirPath", "entityId", "textFields", "text", "keyword", "edit", "primaryFocusPath", "maxFrequency", "focusType", "frequency", "primaryActivityType", "type", "description", "relatedEntityIds", "a", "b", "focusArea", "uuidv4", "updateFocusAreaInDb", "error", "focus", "lastActivated", "executeQuery", "existingFocus", "updateIntent", "params", "conversationId", "newMessage", "isUser", "activeFile", "codeChanges", "newIntent", "focusUpdated", "currentFocus", "messages", "executeQuery", "msg", "intent", "keywords", "inferIntentFromQuery", "activeFocusAreas", "focusArea", "rawFocusArea", "confidence", "matchingKeywords", "k", "codeActivity", "recentEvents", "getEvents", "newFocusArea", "predictFocusArea", "error", "init_db", "init_ContextCompressorLogic", "activeEntityIds", "activeFocus", "contextHistory", "getActiveFocus", "setActiveFocus", "focus", "updateActiveContext", "addEntityIds", "removeEntityIds", "changeRecord", "id", "getActiveContextEntityIds", "clearActiveContext", "getActiveContextAsEntities", "entityIds", "getActiveContextEntityIds", "query", "executeQuery", "error", "getActiveContextState", "entities", "getActiveContextAsEntities", "focus", "getActiveFocus", "recentHistory", "contextHistory", "activeEntityIds", "error", "activeFocus", "init_db", "uuidv4", "retrieveGlobalPatterns", "filterOptions", "type", "minConfidence", "limit", "language", "query", "params", "patterns", "executeQuery", "rows", "pattern", "error", "promotePatternToGlobal", "patternId", "newConfidence", "updated_at", "success", "reinforcePattern", "observationType", "contextData", "observation_id", "uuidv4", "timestamp", "observation_data", "confidenceAdjustments", "utilityAdjustments", "patternResult", "newConfidenceScore", "newUtilityScore", "updatePatternQuery", "updateLastDetected", "updatePatternParams", "finalUpdateQuery", "calculatePatternSimilarity", "pattern1", "pattern2", "representationSimilarity", "rulesSimilarity", "typeSimilarity", "languageSimilarity", "calculateJaccardSimilarity", "extractTokensFromField", "combinedSimilarity", "field", "content", "parsed", "token", "tokens1", "tokens2", "set1", "set2", "intersectionSize", "unionSize", "consolidateSessionPatterns", "options", "minReinforcementCount", "similarityThreshold", "promotedCount", "mergedCount", "sessionPatterns", "globalPatterns", "sessionPattern", "shouldPromote", "similarGlobalPattern", "globalPattern", "scheduleConsolidation", "intervalMinutes", "intervalMs", "result", "init_config", "z", "initializeConversationContextInputSchema", "DEFAULT_TOKEN_BUDGET", "initializeConversationContextOutputSchema", "updateConversationContextInputSchema", "updateConversationContextOutputSchema", "retrieveRelevantContextInputSchema", "retrieveRelevantContextOutputSchema", "recordMilestoneContextInputSchema", "recordMilestoneContextOutputSchema", "finalizeConversationContextInputSchema", "finalizeConversationContextOutputSchema", "init_logger", "handler", "input", "sdkContext", "logMessage", "conversationId", "uuidv4", "initialQuery", "focusHint", "includeArchitecture", "includeRecentConversations", "maxCodeContextItems", "maxRecentChanges", "contextDepth", "tokenBudget", "clearActiveContext", "setActiveFocus", "err", "recordEvent", "initializeConversation", "recentMessages", "getRecentMessages", "m", "predictedIntent", "intentResult", "inferIntentFromQuery", "comprehensiveContext", "gatherComprehensiveContext", "contextCounts", "initialContextSummary", "generateInitialContextSummary", "responseData", "error", "errorResponse", "options", "context", "gatherCodeContext", "gatherArchitectureContext", "gatherProjectStructure", "gatherRecentConversations", "gatherRecentChanges", "gatherActiveWorkflows", "gatherGlobalPatterns", "query", "searchConstraints", "searchTerms", "extractKeywords", "codeItems", "searchByKeywords", "result", "compressionOptions", "compressContext", "docSearchResults", "docSources", "docContents", "directories", "executeQuery", "rows", "dir", "sum", "recentConversationEvents", "getEvents", "event", "maxChanges", "recentChangeEvents", "milestoneEvents", "globalPatterns", "retrieveGlobalPatterns", "pattern", "intent", "summary", "text", "word", "initializeConversationContext_tool_default", "initializeConversationContextInputSchema", "initializeConversationContextOutputSchema", "init_db", "init_db", "processCodeChange", "change", "inMcpMode", "contentHash", "skipProcessing", "existingFile", "executeQuery", "dbError", "entities", "indexCodeFile", "indexError", "getEntitiesFromChangedFiles", "entitiesError", "error", "getEntitiesFromChangedFiles", "filePaths", "inMcpMode", "allEntities", "processedPaths", "filePath", "fileEntities", "executeQuery", "entities", "fileEntityIds", "entity", "entityId", "childEntities", "child", "e", "childErr", "fileErr", "error", "init_ContextCompressorLogic", "init_logger", "handler", "input", "sdkContext", "logMessage", "conversationId", "newMessages", "codeChanges", "preserveContextOnTopicShift", "contextIntegrationLevel", "trackIntentTransitions", "tokenBudget", "error", "topicShift", "intentTransition", "previousIntent", "currentIntent", "contextPreserved", "currentFocus", "previousContextState", "getActiveContextState", "getActivePurpose", "err", "processedMessages", "processNewMessages", "processedChanges", "processCodeChanges", "intentResult", "updateIntent", "intentErr", "integratedContext", "_integrateContexts", "updateActiveContext", "integrateErr", "clearActiveContext", "recentEvents", "getRecentEventsForConversation", "focusResult", "predictFocusArea", "setActiveFocus", "focusErr", "clearErr", "getActiveFocus", "contextSynthesis", "generateContextSynthesis", "synthesisErr", "recordEvent", "timelineErr", "responseData", "errorResponse", "messages", "options", "result", "message", "isTopicShift", "activeTopicId", "detectTopicShift", "recordedMessageId", "recordMessage", "activeTopic", "getActiveTopicForConversation", "closeTopicSegment", "closeError", "topicName", "generateTopicName", "nameError", "newTopicId", "createNewTopicSegment", "executeQuery", "updateError", "topicError", "recentHistory", "getConversationHistory", "purposeResult", "detectConversationPurpose", "newPurpose", "currentPurpose", "trackPurposeTransition", "purposeError", "intentUpdateResult", "intentError", "msgError", "processingPromises", "change", "processCodeChange", "processErr", "processedResults", "promiseResult", "successCount", "r", "failureCount", "mostSignificantChange", "prev", "current", "prevChangedLines", "newFocus", "focusError", "changes", "integrationLevel", "changedFilePaths", "item", "path", "b", "contextChanged", "activeContext", "activeFocus", "recentMessages", "getRecentMessages", "summaryText", "intentStr", "messageContent", "msg", "messageSummary", "summarizeText", "topPriorities", "priorityItems", "updateConversationContext_tool_default", "updateConversationContextInputSchema", "updateConversationContextOutputSchema", "init_db", "init_RelationshipContextManagerLogic", "init_ContextCompressorLogic", "init_RelationshipContextManagerLogic", "init_config", "init_logger", "handler", "input", "sdkContext", "logMessage", "DEFAULT_TOKEN_BUDGET", "conversationId", "query", "tokenBudget", "constraints", "contextFilters", "weightingStrategy", "balanceStrategy", "contextBalance", "sourceTypePreferences", "error", "conversationHistory", "currentTopic", "currentPurpose", "getConversationHistory", "err", "simplifiedResult", "msg", "acc", "_estimateTokenCount", "_estimateTokenCount", "text", "error", "logMessage", "retrieveRelevantContext_tool_default", "retrieveRelevantContextInputSchema", "retrieveRelevantContextOutputSchema", "handler", "init_db", "uuidv4", "init_db", "init_TextTokenizerLogic", "init_RelationshipContextManagerLogic", "init_db", "uuidv4", "init_TextTokenizerLogic", "init_logger", "uuidv4", "analyzePatternsAroundMilestone", "milestoneSnapshotId", "logMessage", "snapshots", "executeQuery", "snapshot", "created_at", "focus_areas", "conversation_id", "milestoneTime", "windowBeforeMs", "windowAfterMs", "windowStart", "windowEnd", "events", "eventRows", "messages", "messageRows", "entityAccessCounts", "event", "data", "file", "searchQueries", "e", "topicCounts", "purposeCounts", "msg", "a", "b", "error", "init_RelationshipContextManagerLogic", "init_logger", "handler", "input", "sdkContext", "logMessage", "conversationId", "name", "description", "customData", "milestoneCategory", "assessImpact", "error", "activeContextEntities", "activeFocus", "activeContextIds", "getActiveContextAsEntities", "getActiveFocus", "entity", "contextErr", "snapshotData", "milestoneEventId", "recordEvent", "timelineErr", "milestoneId", "createSnapshot", "stateId", "uuidv4", "currentTime", "stateData", "insertStateQuery", "stateParams", "executeQuery", "stateErr", "snapshotErr", "impactAssessment", "_assessMilestoneImpact", "impactErr", "analyzePatternsAroundMilestone", "responseData", "errorResponse", "category", "entities", "id", "result", "queryErr", "fetchErr", "impactedEntityIds", "criticalPaths", "componentImpacts", "entityTypeMap", "outgoingRelationships", "getRelationships", "rel", "component", "currentCount", "relErr", "directlyModifiedCount", "potentiallyImpactedCount", "impactedComponentsCount", "criticalPathsCount", "impactScore", "impactLevel", "baseImpactScore", "categoryMultiplier", "calcErr", "impactSummary", "_generateImpactSummary", "summaryErr", "directCount", "indirectCount", "componentCount", "criticalPathCount", "summary", "recordMilestoneContext_tool_default", "recordMilestoneContextInputSchema", "recordMilestoneContextOutputSchema", "init_db", "extractPatternsFromConversation", "conversationId", "conversationHistory", "getConversationHistory", "error", "extractBugPatternsFromConversation", "errorKeywords", "errorDiscussions", "i", "message", "keyword", "bugPatterns", "discussion", "index", "errorDescription", "solution", "name", "errorTypeMatches", "keyTerms", "term", "extractKeyValuePairs", "conversationIdOrMessages", "messages", "getConversationHistory", "keyValuePairs", "keyValuePatterns", "message", "sentences", "sentence", "pattern", "match", "error", "init_ContextCompressorLogic", "init_TextTokenizerLogic", "init_logger", "uuidv4", "handler", "input", "sdkContext", "logMessage", "conversationId", "clearActiveContext", "extractLearnings", "promotePatterns", "synthesizeRelatedTopics", "generateNextSteps", "outcome", "error", "conversationHistory", "conversationPurpose", "conversationTopics", "getConversationHistory", "historyErr", "getConversationPurpose", "purposeErr", "getConversationTopics", "topicsErr", "summary", "summarizeConversation", "summaryErr", "recordEvent", "timelineErr", "extractedLearnings", "promotedPatterns", "relatedConversations", "nextSteps", "_extractConversationLearnings", "learningErr", "_promoteConversationPatterns", "patternErr", "_findAndSynthesizeRelatedConversations", "relatedErr", "_generateNextStepSuggestions", "nextStepsErr", "clearErr", "currentTime", "executeQuery", "purposeId", "uuidv4", "startTime", "responseData", "errorResponse", "extractPatterns", "patternCount", "bugPatternCount", "extractedPatterns", "extractPatternsFromConversation", "bugPatterns", "extractBugPatternsFromConversation", "keyValuePairs", "extractKeyValuePairs", "_promoteConversationPatterns", "conversationId", "outcome", "patterns", "extractPatternsFromConversation", "promotedPatterns", "minConfidence", "pattern", "promotePatternToGlobal", "observationType", "reinforcePattern", "error", "_findAndSynthesizeRelatedConversations", "conversationTopics", "conversationPurpose", "topicKeywords", "topic", "kw", "keywordArray", "recentConversationEvents", "getEvents", "scoredConversations", "event", "eventTopics", "getConversationTopics", "eventKeywords", "overlapCount", "totalUniqueKeywords", "similarityScore", "commonTopics", "eventTopic", "currentTopic", "b", "relatedConversations", "synthesizedInsights", "_synthesizeInsightsFromRelatedConversations", "currentPurpose", "conversationsByTopic", "conversation", "syntheticTopic", "insights", "conversations", "combinedSummaries", "c", "insight", "summarizeText", "_generateNextStepSuggestions", "purpose", "summary", "extractedLearnings", "result", "tokens", "tokenize", "keywords", "extractKeywords", "purposeType", "nextSteps", "followUpTopics", "designDecisions", "l", "d", "decision", "bugPatterns", "bug", "validKeywords", "referenceMaterials", "searchByKeywords", "finalizeConversationContext_tool_default", "finalizeConversationContextInputSchema", "finalizeConversationContextOutputSchema", "handler", "allTools", "initializeConversationContext_tool_default", "updateConversationContext_tool_default", "retrieveRelevantContext_tool_default", "recordMilestoneContext_tool_default", "finalizeConversationContext_tool_default", "tools_default", "init_logger", "createToolHandler", "handler", "toolName", "params", "context", "logMessage", "actualParams", "signal", "otherParams", "extractedParams", "extractParamsFromInput", "mergedParams", "createDefaultParamsForTool", "result", "error", "input", "key", "parsedJson", "e", "createInitializeContextHandler", "createFinalizeContextHandler", "originalStdoutWrite", "originalStderrWrite", "originalConsoleLog", "originalConsoleError", "originalConsoleWarn", "originalConsoleInfo", "originalConsoleDebug", "isValidMcpOutput", "str", "trimmed", "chunk", "encoding", "callback", "originalStdoutWrite", "originalStderrWrite", "args", "originalConsoleLog", "originalConsoleError", "originalConsoleWarn", "originalConsoleInfo", "originalConsoleDebug", "decayTimer", "startServer", "isMcpMode", "getDbClient", "testDbConnection", "initializeDatabaseSchema", "TURSO_DATABASE_URL", "TURSO_AUTH_TOKEN", "logMessage", "dbClient", "error", "scheduleConsolidation", "decayInterval", "applyDecayToAll", "err", "server", "McpServer", "tool", "tools_default", "wrappedHandler", "createInitializeContextHandler", "createFinalizeContextHandler", "createToolHandler", "transport", "StdioServerTransport", "setupGracefulShutdown", "cleanupTimers"]
}
